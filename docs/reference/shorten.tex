\chapter{Shorten}
\begin{figure}[h]
\includegraphics{figures/shorten/stream.pdf}
\end{figure}
A Shorten file is almost entirely comprised of three variable-length
data types which we'll call \texttt{unsigned}, \texttt{signed} and
\texttt{long}.
\subsubsection{Reading \texttt{unsigned}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream, a bit count $c$}{an unsigned value}
  \SetKwData{MSB}{MSB}
  \SetKwData{LSB}{LSB}
  $\text{\MSB} \leftarrow$ \UNARY with stop bit 1\;
  $\text{\LSB} \leftarrow$ \READ $c$ unsigned bits\;
  \Return $\text{\MSB} \times 2 ^ c + \text{\LSB}$\;
  \EALGORITHM
}
\subsubsection{Reading \texttt{signed}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream, a bit count $c$}{a signed value}
  \SetKwData{UNSIGNED}{unsigned}
  $\text{\UNSIGNED} \leftarrow$ read \texttt{unsigned}($c + 1$)\;
  \eIf(\tcc*[f]{positive}){$\UNSIGNED \bmod 2 = 0$}{
    \Return $\lfloor\UNSIGNED \div 2\rfloor$\;
  }(\tcc*[f]{negative}){
    \Return $-\lfloor\UNSIGNED \div 2\rfloor - 1$\;
  }
  \EALGORITHM
}
\subsubsection{Reading \texttt{long}}
{\relsize{-1}
  \ALGORITHM{the Shorten file stream}{an unsigned value}
  \Return \texttt{unsigned}(\texttt{unsigned}(2))\;
  \EALGORITHM
}

\clearpage

\section{Shorten Decoding}
{\relsize{-1}
\ALGORITHM{a Shorten encoded file}{PCM samples}
\SetKwData{MAGIC}{magic number}
\SetKwData{VERSION}{version}
\SetKwData{FILETYPE}{file type}
\SetKwData{CHANNELS}{channels}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{MAXLPC}{max LPC}
\SetKwData{MEANCOUNT}{mean count}
\SetKwData{SKIPBYTES}{bytes to skip}
\SetKwData{COMMAND}{command}
\SetKwData{SAMPLES}{samples}
$\MAGIC \leftarrow$ \READ 4 bytes\;
\ASSERT $\MAGIC = \texttt{"ajkg"}$\;
$\VERSION \leftarrow$ \READ 8 unsigned bits\;
\ASSERT $\VERSION = 2$\;
\BlankLine
\tcc{read Shorten header}
\begin{tabular}{r>{$}c<{$}l}
  \FILETYPE & \leftarrow & read \texttt{long}()\; \\
  \CHANNELS & \leftarrow & read \texttt{long}()\; \\
  \BLOCKLENGTH & \leftarrow & read \texttt{long}()\; \\
  \MAXLPC & \leftarrow & read \texttt{long}()\; \\
  \MEANCOUNT & \leftarrow & read \texttt{long}()\; \\
  \SKIPBYTES & \leftarrow & read \texttt{long}()\; \\
\end{tabular}\;
\SKIP $(\SKIPBYTES)$ bytes\;
\EALGORITHM
}

\begin{table}[h]
{\relsize{-1}
\begin{tabular}{|r|l||r|l|}
\hline
file type & format & file type & format \\
\hline
0 & lossless \textmu-Law &
7 & lossy \textmu-Law \\
1 & signed 8 bit &
8 & new \textmu-Law with zero mapping \\
2 & unsigned 8 bit &
9 & lossless a-Law \\
3 & signed 16 bit, big-endian &
10 & lossy a-Law \\
4 & unsigned 16 bit, big-endian &
11 & Microsoft .wav \\
5 & signed 16 bit, little-endian &
12 & Apple .aiff \\
6 & unsigned 16 bit, little-endian &
& \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
\VAR{channels} is the total number of channels in the stream
and \VAR{block length} is the number of PCM frames output
from the next command, which is typically constant
until the final set of commands in the stream.
\par
The \texttt{shnmean} function is defined as:
\begin{equation*}
  \texttt{shnmean}(values~,~count) =
  \left\lfloor
  \frac{\left\lfloor\frac{count}{2}\right\rfloor +
    \overset{count - 1}{\underset{i = 0}{\sum}}{values}_i }{count}
  \right\rfloor
\end{equation*}
where $values$ is a list and $count$ is the length of that list.

\clearpage

{\relsize{-1}
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetKw{OR}{or}
  \SetKwData{CHANNELS}{channels}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{COMMAND}{command}
  \SetKwData{LEFTSHIFT}{left shift}
  \SetKwData{SAMPLES}{samples}
  \SetKwData{MEANCOUNT}{mean count}
  \SetKwData{MEANS}{means}
  \SetKwData{SHIFTED}{unshifted}
  \tcc{setup initial variables}
  $i \leftarrow 0$\;
  $\LEFTSHIFT \leftarrow 0$\;
  \BlankLine
  \tcc{process commands}
  \Repeat{$\COMMAND = 4$}{
    $\COMMAND \leftarrow$ read \texttt{unsigned}(2)\;
    \eIf(\tcc*[f]{audio data commands}){$(0 \leq \COMMAND \leq 3)$ \OR $(7 \leq \COMMAND \leq 8)$}{
      $c \leftarrow i \bmod \CHANNELS$\tcc*{current channel}
      $m \leftarrow \lfloor i \div \CHANNELS\rfloor$\;
      \Switch{\COMMAND}{
        \uCase(\tcc*[f]{DIFF0}){0}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF0} with \BLOCKLENGTH,
          and $\text{\MEANS}_{c~[m - \text{\MEANCOUNT} \IDOTS m - 1]}$\;
        }
        \uCase(\tcc*[f]{DIFF1}){1}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF1} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{DIFF2}){2}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF2} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{DIFF3}){3}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{DIFF3} with \BLOCKLENGTH and
          previous $\text{\SAMPLES}_c$\;
        }
        \uCase(\tcc*[f]{QLPC}){7}{
          $\text{\SAMPLES}_c \leftarrow$ read \texttt{QLPC} with \BLOCKLENGTH,
          $\text{\MEANS}_{c~[m - \text{\MEANCOUNT} \IDOTS m - 1]}$\newline and previous $\text{\SAMPLES}_c$\;
        }
        \Case(\tcc*[f]{ZERO}){8}{
          \For{j = 0 \emph{\KwTo}\BLOCKLENGTH}{
            $\text{\SAMPLES}_{c~j} \leftarrow 0$\;
          }
        }
      }
      $\text{\MEANS}_{c~m} \leftarrow \texttt{shnmean}(\text{\SAMPLES}_c~,~\BLOCKLENGTH)$\;
      wrap $\text{\SAMPLES}_c$ for next set of channels\;
      $\text{\SHIFTED}_c \leftarrow$ apply \LEFTSHIFT to $\text{\SAMPLES}_c$\;
      $i \leftarrow i + 1$\;
      \If{$i \bmod \CHANNELS = 0$}{
        \Return \SHIFTED as a complete set of PCM frames\;
      }
    }(\tcc*[f]{non audio commands}){
      \Switch{\COMMAND}{
        \uCase(\tcc*[f]{QUIT}){4}{
          \tcc{do nothing}
        }
        \uCase(\tcc*[f]{BLOCKSIZE}){5}{
          $\BLOCKLENGTH \leftarrow$ read \texttt{long}()\;
        }
        \uCase(\tcc*[f]{BITSHIFT}){6}{
          $\LEFTSHIFT \leftarrow$ read \texttt{unsigned}(2)\;
        }
        \uCase(\tcc*[f]{VERBATIM}){9}{
          handle verbatim block of non-audio data\;
        }
        \Other{unknown command}
      }
    }
  }(\tcc*[f]{QUIT command})
\end{algorithm}
}

\clearpage

\subsection{Header Decoding Example}

\begin{figure}[h]
\includegraphics{figures/shorten/header_parse.pdf}
\end{figure}
In this example, \VAR{magic number} is \texttt{"ajkg"} and
\VAR{version} is 2.
Since \VAR{file type} is a \texttt{long}\footnote{which is defined as
\texttt{unsigned}(\texttt{unsigned}(2))}
it breaks down as follows:
\par
\noindent
\begin{wrapfigure}[3]{r}{140pt}
\includegraphics{figures/shorten/filetype.pdf}
\end{wrapfigure}
{\relsize{-1}
\begin{align*}
\text{MSB}_0 &\leftarrow 0
\text{ (number of \texttt{0} bits until next \texttt{1})} \\
\text{LSB}_0 &\leftarrow 3
\text{ (read 2 unsigned bits)} \\
\texttt{unsigned}(2) &\leftarrow 0 \times 2 ^ 2 + 3 = 3 \\
\text{MSB}_1 &\leftarrow 0
\text{ (number of \texttt{0} bits until next \texttt{1})} \\
\text{LSB}_1 &\leftarrow 5
\text{ (read 3 unsigned bits)} \\
\text{file type} &\leftarrow 0 \times 2 ^ 3 + 5 = 5 \\
\end{align*}
}
\par
\noindent
meaning our file consists of signed, 16-bit, little-endian data.
The remainding fields are determined as follows:
\begin{table}[h]
  \begin{tabular}{r>{$}c<{$}rr>{$}r<{$}rr>{$}r<{$}}
    & & $\text{MSB}_0$ & $\text{LSB}_0$ & $\texttt{unsigned}(2)$ &
    $\text{MSB}_1$ & $\text{LSB}_1$ & \texttt{long} \text{ value} \\
    \hline
    channels & \leftarrow & {\color{red} 0} & {\color{orange} 2} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 2} = {\color{fuchsia} 2} &
    {\color{blue} 0} & {\color{green} 2} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 2} + {\color{green} 2} =
    \textbf{2} \\
    block length & \leftarrow & {\color{red} 2} & {\color{orange} 1} &
    {\color{red} 2} \times 2 ^ 2 + {\color{orange} 1} = {\color{fuchsia} 9} &
    {\color{blue} 0} & {\color{green} 256} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 9} + {\color{green} 256} =
    \textbf{256} \\
    max LPC & \leftarrow & {\color{red} 0} & {\color{orange} 0} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 0} = {\color{fuchsia} 0} &
    {\color{blue} 0} & {\color{green} 0} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 0} + {\color{green} 0} =
    \textbf{0} \\
    bytes to skip & \leftarrow & {\color{red} 0} & {\color{orange} 0} &
    {\color{red} 0} \times 2 ^ 2 + {\color{orange} 0} = {\color{fuchsia} 0} &
    {\color{blue} 0} & {\color{green} 0} &
    {\color{blue} 0} \times 2 ^ {\color{fuchsia} 0} + {\color{green} 0} =
    \textbf{0} \\
\end{tabular}
\end{table}

\clearpage

\subsection{Handling Verbatim Data}

These are non-audio blocks designed to hold Wave/AIFF headers or footers.
They are expected to be in the Shorten file in the same order
they would be output to disk.
\par
\noindent
\ALGORITHM{Shorten stream}{1 or more bytes of non-audio file data}
$size \leftarrow$ read \texttt{unsigned}(5)\;
\For{i = 0 \emph{\KwTo}size}{
  $\text{bytes}_i \leftarrow$ read \texttt{unsigned}(8)\;
}
\Return bytes\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/shorten/verbatim.pdf}
\end{figure}

\clearpage

\subsection{Reading \texttt{DIFF0}}
{\relsize{-1}
\ALGORITHM{block length, previous \VAR{mean count} means for channel $c$}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{OFFSET}{offset}
\SetKwData{MEANS}{previous means}
\SetKwData{ENERGY}{energy}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLES}{samples}
$\text{\OFFSET} \leftarrow \texttt{shnmean}(\text{\MEANS}_c~,~\text{mean count})$\;
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
\BlankLine
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\RESIDUAL}_i + \OFFSET$\;
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
}

\subsection{Reading \texttt{DIFF1}}
{\relsize{-1}
\ALGORITHM{block length, previously decoded samples}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{ENERGY}{energy}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLES}{samples}
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
\BlankLine
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\SAMPLES}_{c~(i - 1)} + \text{\RESIDUAL}_i$\;
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
\par
\noindent
$\text{samples}_{c~(-1)}$ is from the previously
decoded samples on channel $c$,
or 0 if there are none
}

\subsection{Reading \texttt{DIFF2}}
{\relsize{-1}
  \ALGORITHM{block length, previously decoded samples}{decoded samples}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{ENERGY}{energy}
  \SetKwData{RESIDUAL}{residual}
  \SetKwData{SAMPLES}{samples}
  $\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
  \BlankLine
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
    $\text{\SAMPLES}_{c~i} \leftarrow (2 \times \text{\SAMPLES}_{c~(i - 1)}) - \text{\SAMPLES}_{c~(i - 2)} + \text{\RESIDUAL}_i$\;
  }
  \Return $\text{\SAMPLES}_c$\;
  \EALGORITHM
  \par
  \noindent
  $\text{samples}_{c~(-1)}$ and $\text{samples}_{c~(-2)}$ are from
  the previously decoded samples on channel $c$,
  or 0 if there are none
}

\subsection{Reading \texttt{DIFF3}}
{\relsize{-1}
  \ALGORITHM{block length, previously decoded samples}{decoded samples}
  \SetKwData{BLOCKLENGTH}{block length}
  \SetKwData{ENERGY}{energy}
  \SetKwData{RESIDUAL}{residual}
  \SetKwData{SAMPLES}{samples}
  $\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
  \BlankLine
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
    $\text{\SAMPLES}_{c~i} \leftarrow (3 \times (\text{\SAMPLES}_{c~(i - 1)} - \text{\SAMPLES}_{c~(i - 2)})) + \text{\SAMPLES}_{c~(i - 3)} + \text{\RESIDUAL}_i$\;
  }
  \Return $\text{\SAMPLES}_c$\;
  \EALGORITHM
  \par
  \noindent
  $\text{samples}_{c~(-1)}$, $\text{samples}_{c~(-2)}$ and
  $\text{samples}_{c~(-3)}$ are from
  the previously decoded samples on channel $c$,
  or 0 if there are none
}

\clearpage

\subsection{\texttt{DIFF3} Parsing Example}
Given a \texttt{DIFF3} command issued with a current \VAR{block length} of 15
and the bytes:
\begin{figure}[h]
\includegraphics{figures/shorten/block1.pdf}
\end{figure}
\begin{equation*}
\text{energy} \leftarrow 0 \times 2 ^ 3 + 1 = 1
\end{equation*}
\begin{table}[h]
  {\relsize{-1}
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{rrr>{$}r<{$}>{$}r<{$}>{$}r<{$}}
    $i$ & $\text{MSB}_i$ & $\text{LSB}_i$ &
    \text{unsigned}_i & \text{residual}_i & \text{sample}_i \\
    \hline
    -3 & & & & & 0 \\
    -2 & & & & & 0 \\
    -1 & & & & & 0 \\
    \hline
    0 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (0 - 0)) + 0 + 0 = 0 \\
    1 &
    8 & 0 & 8 \times 2 ^ {2} + 0 = 32 &
    \lfloor 32 \div 2 \rfloor = 16 &
    (3 \times (0 - 0)) + 0 + 16 = 16 \\
    2 &
    8 & 1 & 8 \times 2 ^ {2} + 1 = 33 &
    -\lfloor 33 \div 2 \rfloor - 1 = -17 &
    (3 \times (16 - 0)) + 0 - 17 = 31 \\
    3 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (31 - 16)) + 0 - 1 = 44 \\
    4 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (44 - 31)) + 16 - 1 = 54 \\
    5 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (54 - 44)) + 31 + 0 = 61 \\
    6 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (61 - 54)) + 44 - 1 = 64 \\
    7 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (64 - 61)) + 54 + 0 = 63 \\
    8 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (63 - 64)) + 61 + 0 = 58 \\
    9 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (58 - 63)) + 64 + 0 = 49 \\
    10 &
    1 & 0 & 1 \times 2 ^ {2} + 0 = 4 &
    \lfloor 4 \div 2 \rfloor = 2 &
    (3 \times (49 - 58)) + 63 + 2 = 38 \\
    11 &
    0 & 1 & 0 \times 2 ^ {2} + 1 = 1 &
    -\lfloor 1 \div 2 \rfloor - 1 = -1 &
    (3 \times (38 - 49)) + 58 - 1 = 24 \\
    12 &
    0 & 2 & 0 \times 2 ^ {2} + 2 = 2 &
    \lfloor 2 \div 2 \rfloor = 1 &
    (3 \times (24 - 38)) + 49 + 1 = 8 \\
    13 &
    1 & 0 & 1 \times 2 ^ {2} + 0 = 4 &
    \lfloor 4 \div 2 \rfloor = 2 &
    (3 \times (8 - 24)) + 38 + 2 = -8 \\
    14 &
    0 & 0 & 0 \times 2 ^ {2} + 0 = 0 &
    \lfloor 0 \div 2 \rfloor = 0 &
    (3 \times (-8 - 8)) + 24 + 0 = -24 \\
    \hline
  \end{tabular}
    \renewcommand{\arraystretch}{1.0}
  }
\end{table}
\par
\noindent
Note that the negative $i$ samples are only used
for calculation and not re-output by the \texttt{DIFF} command.

\clearpage

\subsection{\texttt{DIFF3} Parsing Example 2}
Given a \texttt{DIFF3} command issued from the same channel as
the previous example with a current \VAR{block length} of 10
and the bytes:

\begin{figure}[h]
\includegraphics{figures/shorten/block2.pdf}
\end{figure}
\begin{equation*}
  \text{energy} \leftarrow 0 \times 2 ^ 3 + 0 = 0
\end{equation*}
\begin{table}[h]
  {\relsize{-1}
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{rrr>{$}r<{$}>{$}r<{$}>{$}r<{$}}
      $i$ & $\text{MSB}_i$ & $\text{LSB}_i$ &
      \text{unsigned}_i & \text{residual}_i & \text{sample}_i \\
      \hline
      -3 & & & & & 8 \\
      -2 & & & & & -8 \\
      -1 & & & & & -24 \\
      \hline
      0 &
      2 & 0 & 2 \times 2 ^ {1} + 0 = 4 &
      \lfloor 4 \div 2 \rfloor = 2 &
      (3 \times (-24 + 8)) + 8 + 2 = -38 \\
      1 &
      1 & 0 & 1 \times 2 ^ {1} + 0 = 2 &
      \lfloor 2 \div 2 \rfloor = 1 &
      (3 \times (-38 + 24)) - 8 + 1 = -49 \\
      2 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-49 + 38)) - 24 - 1 = -58 \\
      3 &
      2 & 0 & 2 \times 2 ^ {1} + 0 = 4 &
      \lfloor 4 \div 2 \rfloor = 2 &
      (3 \times (-58 + 49)) - 38 + 2 = -63 \\
      4 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-63 + 58)) - 49 + 0 = -64 \\
      5 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-64 + 63)) - 58 + 0 = -61 \\
      6 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-61 + 64)) - 63 + 0 = -54 \\
      7 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-54 + 61)) - 64 - 1 = -44 \\
      8 &
      0 & 0 & 0 \times 2 ^ {1} + 0 = 0 &
      \lfloor 0 \div 2 \rfloor = 0 &
      (3 \times (-44 + 54)) - 61 + 0 = -31 \\
      9 &
      0 & 1 & 0 \times 2 ^ {1} + 1 = 1 &
      -\lfloor 1 \div 2 \rfloor - 1 = -1 &
      (3 \times (-31 + 44)) - 54 - 1 = -16 \\
    \end{tabular}
    \renewcommand{\arraystretch}{1.0}
  }
\end{table}
\par
\noindent
Note that because this \texttt{DIFF} is issued on the same channel
as the previous \texttt{DIFF}:
\begin{table}[h]
\begin{tabular}{rcl}
  $\text{current sample}_{(-3)}$ & = & $\text{previous sample}_{12}$ \\
  $\text{current sample}_{(-2)}$ & = & $\text{previous sample}_{13}$ \\
  $\text{current sample}_{(-1)}$ & = & $\text{previous sample}_{14}$ \\
\end{tabular}
\end{table}
\par
\noindent
the samples have been ``wrapped around'' from one channel to the next.
But again, those negative samples are not re-output by
this \texttt{DIFF} command.

\clearpage

\subsection{Reading \texttt{QLPC}}
{\relsize{-1}
\ALGORITHM{block length, previous \VAR{mean count} means for channel $c$, previously decoded samples}{decoded samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{OFFSET}{offset}
\SetKwData{MEANS}{previous means}
\SetKwData{ENERGY}{energy}
\SetKwData{LPCCOUNT}{LPC count}
\SetKwData{COEFF}{LPC coefficient}
\SetKwData{RESIDUAL}{residual}
\SetKwData{UNOFFSET}{unoffset}
\SetKwData{SAMPLES}{samples}
$\text{\OFFSET} \leftarrow \texttt{shnmean}(\text{\MEANS}_c~,~\text{mean count})$\;
$\ENERGY \leftarrow$ read \texttt{unsigned}(3)\;
$\LPCCOUNT \leftarrow$ read \texttt{unsigned}(2)\;
\For{i = 0 \emph{\KwTo}\LPCCOUNT}{
  $\text{\COEFF}_i \leftarrow$ read \texttt{signed}(5)\;
}
\For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\RESIDUAL}_i \leftarrow$ read \texttt{signed}(\ENERGY)\;
  $\text{sum} \leftarrow 2 ^ 5$\;
  \For{j = 0 \emph{\KwTo}\LPCCOUNT}{
    \eIf(\tcc*[f]{remove offset from warm-up samples}){$i - j - 1 < 0$}{
      $\text{sum} \leftarrow \text{sum} + \text{\COEFF}_j \times (\text{\SAMPLES}_{c~(i - j - 1)} - \OFFSET)$\;
    }{
      $\text{sum} \leftarrow \text{sum} + \text{\COEFF}_j \times \text{\UNOFFSET}_{(i - j - 1)}$\;
    }
  }
  $\text{\UNOFFSET}_{i} \leftarrow \left\lfloor\frac{\text{sum}}{2 ^ 5}\right\rfloor + \text{\RESIDUAL}_i$\;
}
\For(\tcc*[f]{add offset to output samples}){i = 0 \emph{\KwTo}\BLOCKLENGTH}{
  $\text{\SAMPLES}_{c~i} \leftarrow \text{\UNOFFSET}_i + \OFFSET$
}
\Return $\text{\SAMPLES}_c$\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/shorten/qlpc.pdf}
\end{figure}
\par
\noindent
As with the \texttt{DIFF} commands, negative samples are from the
previously decoded samples on channel $c$, or 0 if there are none.

In practice, encoded Shorten files typically contain no
\texttt{QLPC} commands at all.
Because the reference implementation uses a 32-bit
accumulator for the LPC sum,
calculation will overflow when using a nontrivial number of
coefficients.
Instead, files usually contain only \texttt{DIFF1}, \texttt{DIFF2},
\texttt{DIFF3}, and \texttt{ZERO} audio commands.

\clearpage

\subsection{Reading \texttt{QLPC} Example}
\begin{figure}[h]
\includegraphics{figures/shorten/qlpc1.pdf}
\end{figure}

In this example:
\begin{table}[h]
  \begin{tabular}{r>{$}c<{$}>{$}l<{$}}
    offset & \leftarrow & 0 \\
    $\text{LPC count}$ & \leftarrow & 1 \\
    $\text{LPC coefficient}_0$ & \leftarrow & 29 \\
  \end{tabular}
\end{table}
\begin{table}[h]
{\relsize{-1}
  \renewcommand{\arraystretch}{1.25}
  \begin{tabular}{rr>{$}r<{$}>{$}r<{$}||>{$}r<{$}}
    $i$ & $\text{residual}_i$ & \text{sum}_i & \text{unoffset}_i &
    \text{sample}_{c~i} \\
    \hline
    0 & -1 &
    2 ^ 5 + 29 \times (0 - 0) = 32 &
    \left\lfloor\frac{32}{2 ^ 5}\right\rfloor - 1 = 0 &
    0 + 0 = 0 \\
    1 & 15 &
    2 ^ 5 + 29 \times 0 = 32 &
    \left\lfloor\frac{32}{2 ^ 5}\right\rfloor + 15 = 16 &
    16 + 0 = 16 \\
    2 & 16 &
    2 ^ 5 + 29 \times 16 = 496 &
    \left\lfloor\frac{496}{2 ^ 5}\right\rfloor + 16 = 31 &
    31 + 0 = 31 \\
    3 & 15 &
    2 ^ 5 + 29 \times 31 = 931 &
    \left\lfloor\frac{931}{2 ^ 5}\right\rfloor + 15 = 44 &
    44 + 0 = 44 \\
    4 & 14 &
    2 ^ 5 + 29 \times 44 = 1308 &
    \left\lfloor\frac{1308}{2 ^ 5}\right\rfloor + 14 = 54 &
    54 + 0 = 54 \\
    5 & 12 &
    2 ^ 5 + 29 \times 54 = 1598 &
    \left\lfloor\frac{1598}{2 ^ 5}\right\rfloor + 12 = 61 &
    61 + 0 = 61 \\
    6 & 8 &
    2 ^ 5 + 29 \times 61 = 1801 &
    \left\lfloor\frac{1801}{2 ^ 5}\right\rfloor + 8 = 64 &
    64 + 0 = 64 \\
    7 & 4 &
    2 ^ 5 + 29 \times 64 = 1888 &
    \left\lfloor\frac{1888}{2 ^ 5}\right\rfloor + 4 = 63 &
    63 + 0 = 63 \\
    8 & 0 &
    2 ^ 5 + 29 \times 63 = 1859 &
    \left\lfloor\frac{1859}{2 ^ 5}\right\rfloor + 0 = 58 &
    58 + 0 = 58 \\
    9 & -4 &
    2 ^ 5 + 29 \times 58 = 1714 &
    \left\lfloor\frac{1714}{2 ^ 5}\right\rfloor - 4 = 49 &
    49 + 0 = 49 \\
    %% 10 & -7 &
    %% 2 ^ 5 + 29 \times 49 = 1453 &
    %% \left\lfloor\frac{1453}{2 ^ 5}\right\rfloor - 7 = 38 &
    %% 38 + 0 = 38 \\
    %% 11 & -11 &
    %% 2 ^ 5 + 29 \times 38 = 1134 &
    %% \left\lfloor\frac{1134}{2 ^ 5}\right\rfloor - 11 = 24 &
    %% 24 + 0 = 24 \\
    %% 12 & -14 &
    %% 2 ^ 5 + 29 \times 24 = 728 &
    %% \left\lfloor\frac{728}{2 ^ 5}\right\rfloor - 14 = 8 &
    %% 8 + 0 = 8 \\
    %% 13 & -16 &
    %% 2 ^ 5 + 29 \times 8 = 264 &
    %% \left\lfloor\frac{264}{2 ^ 5}\right\rfloor - 16 = -8 &
    %% -8 + 0 = -8 \\
    %% 14 & -17 &
    %% 2 ^ 5 + 29 \times -8 = -200 &
    %% \left\lfloor\frac{-200}{2 ^ 5}\right\rfloor - 17 = -24 &
    %% -24 + 0 = -24 \\
    %% 15 & -17 &
    %% 2 ^ 5 + 29 \times -24 = -664 &
    %% \left\lfloor\frac{-664}{2 ^ 5}\right\rfloor - 17 = -38 &
    %% -38 + 0 = -38 \\
    %% 16 & -15 &
    %% 2 ^ 5 + 29 \times -38 = -1070 &
    %% \left\lfloor\frac{-1070}{2 ^ 5}\right\rfloor - 15 = -49 &
    %% -49 + 0 = -49 \\
    %% 17 & -14 &
    %% 2 ^ 5 + 29 \times -49 = -1389 &
    %% \left\lfloor\frac{-1389}{2 ^ 5}\right\rfloor - 14 = -58 &
    %% -58 + 0 = -58 \\
    %% 18 & -11 &
    %% 2 ^ 5 + 29 \times -58 = -1650 &
    %% \left\lfloor\frac{-1650}{2 ^ 5}\right\rfloor - 11 = -63 &
    %% -63 + 0 = -63 \\
    %% 19 & -7 &
    %% 2 ^ 5 + 29 \times -63 = -1795 &
    %% \left\lfloor\frac{-1795}{2 ^ 5}\right\rfloor - 7 = -64 &
    %% -64 + 0 = -64 \\
  \end{tabular}
  \renewcommand{\arraystretch}{1.0}
}
\end{table}

\clearpage

\subsection{Applying Left Shift to Samples}
\ALGORITHM{a list of samples for a given channel $c$, a left shift value}{a list of unshifted samples}
\SetKwData{LEFTSHIFT}{left shift}
\SetKwData{SAMPLES}{samples}
\SetKwData{BLOCKLENGTH}{block length}
\SetKwData{UNSHIFTED}{unshifted}
\eIf{$\LEFTSHIFT = 0$}{
  \Return $\text{\SAMPLES}_c$\tcc*{no change}
}{
  \For{i = 0 \emph{\KwTo}\BLOCKLENGTH}{
    $\text{\UNSHIFTED}_{c~i} \leftarrow \text{\SAMPLES}_{c~i} \times 2 ^ {\LEFTSHIFT}$\;
  }
  \Return $\text{\UNSHIFTED}_{c}$\;
}
\EALGORITHM

%% Shorten is one of the earliest lossless audio compression formats.
%% Though superseded by FLAC and other formats, it remains interesting
%% from a historical perspective.

%% \section{Shorten Data Types}
%% Notably, almost nothing in the Shorten file format is byte-aligned.
%% Instead, it uses its own set of variable-length types which I'll
%% refer to as \texttt{unsigned}, \texttt{signed} and \texttt{long}.

%% \begin{wrapfigure}[16]{r}{2in}
%% \includegraphics{figures/shorten/unsigned.pdf}
%% \caption{Unsigned}
%% \includegraphics{figures/shorten/signed.pdf}
%% \caption{Signed}
%% \end{wrapfigure}
%% An \texttt{unsigned} field of a certain \VAR{size} means we first
%% take a unary-encoded\footnote{In this instance, unary-encoding is a simple
%% matter of counting the number of 0 bits before the next 1 bit.
%% The resulting sum is the value.}, number of high bits and combine
%% the resulting value with \VAR{size} number of low bits.
%% For example, given a \VAR{size} of 2 and the bits `\texttt{0 0 1 1 1}',
%% the high unary value of `\texttt{0 0 1}' combines with the low
%% raw value of `\texttt{1 1}' resulting in a decimal value of 11.

%% A \texttt{signed} field is similar, but its low value contains
%% one additional trailing bit for the sign value.
%% {\relsize{-2}
%% \begin{equation*}
%% \text{signed value} =
%% \begin{cases}
%% \text{unsigned value} & \text{if sign bit} = 0 \\
%% -\text{unsigned value} - 1 & \text{if sign bit} = 1
%% \end{cases}
%% \end{equation*}
%% }
%% For example, given a \VAR{size} of 3 and the bits `\texttt{0 1 1 0 1 1}',
%% the high unary value of `\texttt{0 1}' combines with the low
%% raw value of `\texttt{1 0 1}' and the sign bit `\texttt{1}'
%% resulting in a decimal value of -14.
%% Note that the sign bit is counted separately, so we're
%% actually reading 4 additional bits after the unary value in this case.

%% Lastly, and most confusingly, a \texttt{long} field is the combination
%% of two separate \texttt{unsigned} fields.
%% The first, of size 2, determines the size value of the second.
%% For example, given the bits `\texttt{1 1 1 1 1 0 1}',
%% the first \texttt{unsigned} field of `\texttt{1 1 1}' has the value
%% of 3 (unary 0 combined with a raw value of 3) - which is the size
%% of the next \texttt{unsigned} field.
%% That field, in turn, consists of the bits `\texttt{1 1 0 1}'
%% which is 5 (unary 0 combined with a raw value of 5).
%% So, the value of the entire \texttt{long} field is 5.

%% A Shorten file consists almost entirely of these three types
%% in various sizes.
%% Therefore, when one reads ``\texttt{unsigned(3)}'' in a Shorten field
%% description, it means an \texttt{unsigned} field of size 3.

%% \pagebreak

%% \section{the Shorten File Stream}
%% \label{shorten_stream}

%% \par
%% \noindent
%% \VAR{Channels} is the number of channels in the audio stream.
%% \VAR{Block Length} is the length of each command block, in samples.
%% \VAR{Max LPC} is the maximum LPC value a block may have.
%% \VAR{Samples to Wrap} is the number of samples to be wrapped around
%% from the top of an output block to the bottom.
%% This will be explained in more detail in the decoding section.

%% \pagebreak

%% \section{Shorten Decoding}
%% \begin{wrapfigure}[4]{r}{2.75in}
%% \begin{tabular}{|r|l||r|l|}
%% \hline
%% value & command & value & command \\
%% \hline
%% 0 & \texttt{DIFF0} & 5 & \texttt{BLOCKSIZE} \\
%% 1 & \texttt{DIFF1} & 6 & \texttt{BITSHIFT} \\
%% 2 & \texttt{DIFF2} & 7 & \texttt{QLPC} \\
%% 3 & \texttt{DIFF3} & 8 & \texttt{ZERO} \\
%% 4 & \texttt{QUIT} & 9 & \texttt{VERBATIM} \\
%% \hline
%% \end{tabular}
%% \end{wrapfigure}
%% Internally,
%% a Shorten file acts as a list of commands to be executed by a tiny
%% virtual machine.\footnote{Interestingly, although
%% Shorten's successor, FLAC, presents its input as frames and subframes,
%% references to a FLAC virtual machine are still present in its source code.}
%% Each command is a \texttt{unsigned(2)} field followed by zero or more
%% arguments.

%% \subsection{the DIFF Command}
%% All four \texttt{DIFF} commands are structured the same:
%% \begin{figure}[h]
%% \includegraphics{figures/shorten/diff.pdf}
%% \end{figure}
%% \par
%% \noindent
%% There are \VAR{Block Size} number of residuals per \texttt{DIFF}
%% (whose initial value is determined by the Shorten header)
%% and each one's size is determined by \VAR{Energy Size}.
%% The process of transforming these residuals into samples
%% depends on the \texttt{DIFF} command and the values of
%% previously decoded samples.

%% \begin{minipage}{\linewidth}
%% \renewcommand\thefootnote{\thempfootnote}
%% \begin{tabular}{|c| >{$}l<{$} |}
%% \hline
%% Command & \text{Calculation} \\
%% \hline
%% \texttt{DIFF0} & Sample_i = Residual_i + Coffset\footnote{See page \pageref{shorten_coffset}} \\
%% \texttt{DIFF1} & Sample_i = Sample_{i - 1} + Residual_i  \\
%% \texttt{DIFF2} & Sample_i = (2 \times Sample_{i - 1}) - Sample_{i - 2} + Residual_i \\
%% \texttt{DIFF3} & Sample_i = (3 \times (Sample_{i - 1} - Sample_{i - 2})) + Sample_{i - 3} + Residual_i \\
%% \hline
%% \end{tabular}
%% \end{minipage}
%% \par
%% \noindent
%% For example, given a \texttt{DIFF1} command at the stream's beginning
%% and the residual values 10, 1, 2, -2, 1 and -1, samples are
%% calculated as follows:
%% \begin{table}[h]
%% \begin{tabular}{|c|r|>{$}r<{$}|}
%% \hline
%% Index & Residual & \text{Sample} \\
%% \hline
%% -1 & (before stream) & \text{(not output) } \bf0 \\
%% \hline
%% 0 & 10 & 0 + 10 = \bf10 \\
%% 1 & 1 & 10 + 1 = \bf11 \\
%% 2 & 2 & 11 + 2 = \bf13 \\
%% 3 & -2 & 13 - 2 = \bf11 \\
%% 4 & 1 & 11 + 1 = \bf12 \\
%% 5 & -1 & 12 - 1 = \bf11 \\
%% \hline
%% \end{tabular}
%% \end{table}

%% \pagebreak

%% \subsection{Channels and Wrapping}
%% The audio commands \texttt{DIFF}, \texttt{QLPC} and \texttt{ZERO} send
%% their samples to channels in order.
%% For example, a stream of \texttt{DIFF} commands in a 2 channel stereo
%% stream (a very typical configuration) sends $\texttt{DIFF}_1$ to
%% the left channel, $\texttt{DIFF}_2$ to the right channel,
%% $\texttt{DIFF}_3$ to left channel, $\texttt{DIFF}_4$ to the right channel
%% and so on.

%% However, recall that most of the \texttt{DIFF} commands require
%% previously decoded samples as part of their calculation.
%% What this means is that $\texttt{DIFF}_3$ takes the last
%% few samples from $\texttt{DIFF}_1$ in order to apply its residuals
%% (since both are on the left channel) and $\texttt{DIFF}_4$
%% takes the last few samples from $\texttt{DIFF}_2$.

%% This is where the header's \VAR{Samples to Wrap} field comes into play.
%% Its value is the number of samples to be wrapped from the top of the buffer
%% to its pre-zero values.
%% For example, if \VAR{Sample Count} is 256 and \VAR{Samples to Wrap} is 3
%% (another typical configuration),
%% $\text{Buffer}_{-1}$ takes the value of $\text{Buffer}_{255}$,
%% $\text{Buffer}_{-2}$ takes the value of $\text{Buffer}_{254}$, and
%% $\text{Buffer}_{-3}$ takes the value of $\text{Buffer}_{253}$.
%% However, these pre-zero starting-point values are obviously not
%% re-output when the buffer is finally completed and returned.

%% \subsection{the QUIT Command}

%% This command takes no arguments.
%% It indicates the Shorten stream is finished and decoding is completed.

%% \subsection{the BLOCKSIZE Command}

%% This command takes a single \texttt{long} argument
%% whose value is the new \VAR{Block Size}.
%% In effect, it modifies that variable in the Shorten virtual machine.

%% \subsection{the ZERO Command}

%% This command takes no arguments.
%% It simply generates \VAR{Block Size} number of zero samples
%% into the current channel's output buffer.

%% \subsection{the BITSHIFT Command}

%% This commands takes a single \texttt{unsigned(2)} value
%% and modifies the \VAR{bitshift} variable in the Shorten virtual machine.
%% This value is how many bits to left-shift all output samples
%% prior to returning them.

%% For example, imagine a scenario in which all the samples in a set of
%% blocks have 0 for their rightmost (least significant) bit.
%% Setting a bitshift of 1 allows us to ignore that bit during
%% calculation which, in turn, allows us to store those samples more
%% efficiently.

%% Note that bit shifting is applied \textit{after} channel wrapping
%% and \VAR{coffset} calculation\footnote{See page \pageref{shorten_coffset}}.

%% \pagebreak

%% \subsection{the QLPC Command}

%% The \texttt{QLPC} command is structured as follows:

%% \begin{figure}[h]
%% \includegraphics{figures/shorten/qlpc.pdf}
%% \end{figure}
%% \par
%% \noindent
%% So, given a set of LPC coefficients and a set of residuals,
%% samples are calculated using the following formula:
%% \begin{equation}
%% \text{Sample}_i = \left\lfloor \frac{2 ^ 5 + \overset{Count - 1}{\underset{j = 0}{\sum}}
%%   \text{LPC Coefficient}_j \times \text{Sample}_{i - j - 1} } {2 ^ 5}\right\rfloor + \text{Residual}_i
%% \end{equation}
%% This simply means we're taking the sum of the calculated values from
%% 0 to LPC Count - 1, bit-shifting that sum down and added the residual
%% when determining the current sample.
%% As with the \texttt{DIFF} commands, previously encoded samples
%% (possibly from previous commands) are used to calculate the current
%% sample.

%% For example, given the LPC Coefficients and previously encoded samples:
%% \begin{table}[h]
%% \begin{tabular}{>{$}r<{$} r || >{$}r<{$} r}
%% \text{LPC Coefficient}_0 & 21 & \text{Sample}_1 & -2 \\
%% \text{LPC Coefficient}_1 & 2 & \text{Sample}_2 & -3 \\
%% \text{LPC Coefficient}_2 & 7 & \text{Sample}_3 & -2
%% \end{tabular}
%% \end{table}
%% \begin{figure}[h]
%% \begin{tabular}{|c|r|>{$}r<{$}|}
%% \hline
%% Index & Residual & \text{Sample} \\
%% \hline
%% 1 & & \bf-2 \\
%% 2 & & \bf-3 \\
%% 3 & & \bf-2 \\
%% \hline
%% 4 & 1 & \left \lfloor \frac{2 ^ 5 + (21 \times -2) + (2 \times -3) + (7 \times -2)}{2 ^ 5} \right \rfloor + 1 = \left \lfloor \frac{32 - 62}{32} \right \rfloor + 1 = -1 + 1 = \bf0 \\
%% 5 & -2 & \left \lfloor \frac{2 ^ 5 + (21 \times \textbf{0}) + (2 \times -2) + (7 \times -3)}{2 ^ 5} \right \rfloor - 2 = \left \lfloor \frac{32 - 25}{32} \right \rfloor - 2 = 0 - 2 = \bf-2 \\
%% 6 & -1 & \left \lfloor \frac{2 ^ 5 + (21 \times \textbf{-2}) + (2 \times \textbf{0}) + (7 \times -2)}{2 ^ 5} \right \rfloor - 1 = \left \lfloor \frac{32 - 56}{32} \right \rfloor - 1 = -1 - 1 = \bf-2 \\
%% \hline
%% \end{tabular}
%% \end{figure}
%% \par
%% Unfortunately, there's one more wrinkle to consider for proper
%% \texttt{QLPC} command decoding: the \VAR{coffset}.
%% How to calculate this value will be covered in the next section.
%% But when a \texttt{QLPC} command is encountered, the coffset value
%% is subtracted from the \texttt{QLPC}'s warm-up samples
%% (taken from the top of the previous command, for the current channel).
%% Then that coffset value is re-added to our output samples after
%% calculation.

%% For example, given a \VAR{coffset} value of 5, one would subtract 5 from
%% $\text{Sample}_{-3}$, $\text{Sample}_{-2}$ and $\text{Sample}_{-1}$,
%% perform the QLPC calculation and then add 5 to our
%% $\text{Sample}_{0}$, $\text{Sample}_{1}$, $\text{Sample}_{2}$, ... ,
%% $\text{Sample}_{255}$
%% before returning those values.

%% \pagebreak

%% \label{shorten_coffset}
%% \subsection{the Coffset}

%% Calculating the \VAR{coffset} value for a given command on a given channel
%% requires a set of \VAR{offset} values
%% (whose count equals the \VAR{Number of Means}, from the Shorten header)
%% and the \VAR{Number of Means} value itself.
%% \begin{equation}
%% \text{coffset} = \frac{\frac{\text{nmeans}}{2} +
%% \overset{\text{nmeans} - 1}{\underset{i = 0}{\sum}} \text{offset}_i }{\text{nmeans}}
%% \end{equation}
%% For example, given a \VAR{Number of Means} value of 4 and offsets of:
%% \begin{table}[h]
%% \begin{tabular}{>{$}r<{$} r}
%% \text{offset}_0 & 32 \\
%% \text{offset}_1 & 28 \\
%% \text{offset}_2 & 17 \\
%% \text{offset}_3 & 14 \\
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% \begin{equation}
%% \text{coffset} = \frac{\frac{4}{2} + (32 + 28 + 17 + 14)}{4} = \frac{93}{4} = \bf23
%% \end{equation}
%% \par
%% The next obvious question is where to those \VAR{offset} values come from?
%% They're actually a queue of (mostly) sample value averages on the
%% given channel.
%% So once we've decoded offset for $\text{command}_5$ on channel 0,
%% $\text{offset}_0$ takes the value of $\text{offset}_1$,
%% $\text{offset}_1$ takes the value of $\text{offset}_2$,
%% $\text{offset}_2$ takes the value of $\text{offset}_3$,
%% and $\text{command}_5$'s offset becomes the new $\text{offset}_3$.

%% However, the offset is not entirely a sample average.
%% Its actual formula is as follows:
%% \begin{equation}
%% \text{offset} = \frac{\frac{\text{block size}}{2} +
%% \overset{\text{block size} - 1}{\underset{i = 0}{\sum}} \text{sample}_i }{\text{block size}}
%% \end{equation}
%% \par
%% \noindent
%% For example, if a command with a \VAR{block size} of 256 has samples
%% that total 1056, its offset value is:
%% \begin{equation}
%% \text{offset} = \frac{\frac{\text{256}}{2} + 1056}{\text{256}} = \frac{1184}{256} = \bf4
%% \end{equation}

%% \subsection{the VERBATIM Command}

%% This command is for generating raw, non-audio data such
%% as .wav or .aiff chunks and is structured as follows:
%% \begin{figure}[h]
%% \includegraphics{figures/shorten/verbatim.pdf}
%% \end{figure}
%% \par
%% \noindent
%% These chunks of raw data are expected to be written in the order
%% they appear in the Shorten file.

%% \pagebreak

%% \section{Shorten Encoding}

%% For the purposes of Shorten encoding,
%% one needs an entire PCM container file and its
%% PCM values, number of channels and bits per sample.
%% Recall that nearly the entire Shorten file format is made up
%% of three variable-length data types with no byte-alignment of any sort.
%% Because of that, there's no way to ``rewind'' the Shorten stream
%% and replace values.
%% Therefore, everything encoded to Shorten must be written in order.

%% \begin{figure}[h]
%% \includegraphics{figures/shorten/stream.pdf}
%% \end{figure}
%% \par
%% \noindent
%% Remember that \texttt{long} variables contain a size \texttt{unsigned(2)}
%% field followed by its value.
%% So what's the best size to use for a given value?
%% Quite frankly, in my opinion, any small size will do.
%% Most of a Shorten file is encoded residuals, so wasting a handful
%% of bytes in the header won't make any difference.

%% A good set of header values to use are as follows:
%% \begin{table}[h]
%% \begin{tabular}{|r|l|}
%% \hline
%% field & value \\
%% \hline
%% & \textbf{2} for unsigned 8 bit input \\
%% Field Type & \textbf{5} for signed, little-endian, 16 bit input \\
%% & \textbf{3} for signed, big-endian, 16 bit input \\
%% Channels & from input \\
%% Block Length & \textbf{256} \\
%% Max LPC & \textbf{0} \\
%% Number of Means & \textbf{0} \\
%% Bytes to Skip & \textbf{0} \\
%% Samples to Wrap & \textbf{3} \\
%% \hline
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% The remainder of the stream is various Shorten commands.
%% I'll be limiting this encoding documentation to the \texttt{DIFF1},
%% \texttt{DIFF2}, \texttt{DIFF3}, \texttt{QUIT}, \texttt{BLOCKSIZE},
%% \texttt{ZERO} and \texttt{VERBATIM} commands.
%% \texttt{QLPC}'s implementation is actually broken in the reference
%% decoder\footnote{By limiting its accumulator to a 32-bit integer,
%% it's prone to overflow at high LPC counts.} and tends not to
%% produce smaller files.
%% And, by omitting \texttt{DIFF0} which is rarely used,
%% we can avoid \VAR{coffset} calculation during encoding.

%% \pagebreak

%% \subsection{the VERBATIM Command}

%% PCM containers such as Wave and AIFF consist of
%% several blocks of data, one of which contains a large chunk of
%% PCM data.
%% Shorten encodes these files by turning non-audio data at
%% the beginning and end of the container into \texttt{VERBATIM} commands,
%% often in the following format:
%% \begin{figure}[h]
%% \includegraphics{figures/shorten/sandwich.pdf}
%% \end{figure}
%% \par
%% \noindent
%% These \texttt{VERBATIM} commands \textit{must} appear in
%% the Shorten stream in the same order as they appear in the
%% PCM container itself.

%% \subsection{the BLOCKSIZE Command}

%% Most \texttt{DIFF} and \texttt{ZERO} commands should contain
%% \VAR{Block Length} number of samples, as indicated in the header.
%% But when the end of the input stream is reached and a different
%% number of samples are all that remain, a \texttt{BLOCKSIZE}
%% is required.
%% This is simply an \texttt{unsigned(2)} variable with a value of 5
%% (indicating the \texttt{BLOCKSIZE} command)
%% followed by a \texttt{long} variable containing the new \VAR{Block Length}.

%% \subsection{the QUIT Command}

%% When no more samples remain and all \texttt{VERBATIM} commands have
%% been delivered (a Wave file may contain additional chunks after
%% the `data' chunk, for example), the \texttt{QUIT} command indicates
%% the end of the Shorten stream.
%% This is an \texttt{unsigned(2)} variable with the value 4.

%% However, the stream \textit{must} be padded such that the total
%% stream length, minus 5 bytes for the magic number and version,
%% is a multiple of 4 bytes.
%% If this padding is not performed, the reference decoder's bit stream
%% implementation will exit with an error.

%% \subsection{the ZERO Command}

%% When a block's entire set of samples are 0, we can generate
%% a \texttt{ZERO} command to represent them, which is
%% simply the \texttt{unsigned(2)} command variable of 8.

%% \pagebreak

%% \subsection{the DIFF Commands}

%% The bulk of a Shorten file is \texttt{DIFF} commands,
%% which are \texttt{unsigned(2)} command variables 1, 2, and 3
%% for \texttt{DIFF1}, \texttt{DIFF2} and \texttt{DIFF3}, respectively,
%% followed by the same argument syntax:
%% \begin{figure}[h]
%% \includegraphics{figures/shorten/diff.pdf}
%% \end{figure}
%% \par
%% Given a set of input samples, we decide which \texttt{DIFF} command
%% to use by calculating their minimum delta sum, which is best
%% explained by example:
%% \par
%% \begin{table}[h]
%% {\relsize{-2}
%% \begin{tabular}{|c|r|r|r|r|}
%% \hline
%% index & sample & $\Delta^1$ & $\Delta^2$ & $\Delta^3$ \\
%% \hline
%% -1 & 0 & & & \\
%% 0 & 18 & -18 & & \\
%% 1 & 20 & -2 & -16 & \\
%% 2 & 26 & -6 & 4 & -20 \\
%% 3 & 24 & 2 & -8 & 12 \\
%% 4 & 24 & 0 & 2 & -10 \\
%% 5 & 23 & 1 & -1 & 3 \\
%% 6 & 21 & 2 & -1 & 0 \\
%% 7 & 24 & -3 & 5 & -6 \\
%% 8 & 23 & 1 & -4 & 9 \\
%% 9 & 20 & 3 & -2 & -2 \\
%% 10 & 18 & 2 & 1 & -3 \\
%% 11 & 18 & 0 & 2 & -1 \\
%% 12 & 17 & 1 & -1 & 3 \\
%% 13 & 17 & 0 & 1 & -2 \\
%% 14 & 20 & -3 & 3 & -2 \\
%% 15 & 23 & -3 & 0 & 3 \\
%% 16 & 21 & 2 & -5 & 5 \\
%% 17 & 23 & -2 & 4 & -9 \\
%% 18 & 22 & 1 & -3 & 7 \\
%% 19 & 18 & 4 & -3 & 0 \\
%% \hline
%% \multicolumn{2}{|r|}{$| sum |$} & 56 & 66 & 97 \\
%% \hline
%% \end{tabular}
%% }
%% \end{table}
%% \par
%% \noindent
%% In this example, the $|sum|$ of $\Delta^1$ is the smallest value.
%% Therefore, the best command to use for this set of samples is \texttt{DIFF1}.
%% Once we know which \texttt{DIFF} command to use for a given set of
%% input samples, calculating the command's set of residual values
%% can be done automatically:
%% \par
%% \noindent
%% \begin{table}[h]
%% \begin{tabular}{|c|>{$}l<{$}|}
%% \hline
%% command & \text{calculation} \\
%% \hline
%% \texttt{DIFF1} & \text{Residual}_i = \text{Sample}_i - \text{Sample}_{i - 1} \\
%% \texttt{DIFF2} & \text{Residual}_i = \text{Sample}_i - ((2 * \text{Sample}_{i - 1}) - \text{Sample}_{i - 2}) \\
%% \texttt{DIFF3} & \text{Residual}_i = \text{Sample}_i - ((3 \times (Sample_{i - 1} - Sample_{i - 2})) + Sample_{i - 3}) \\
%% \hline
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% In this example, our residuals for \texttt{DIFF1} are:
%% 18, 2, 6, -2, 0, -1, -2, 3, -1, -3, -2, 0, -1, 0, 3, 3, -2, 2, -1, -4.

%% \pagebreak

%% Finally, given a set of residual values, we need to determine
%% their \VAR{Energy Size}.
%% This is done by selecting the smallest value of `x' such that:
%% \begin{equation}
%% \text{sample count} \times 2 ^ x > \overset{\text{residual count} - 1}{\underset{i = 0}{\sum}} |\text{residual}_i|
%% \end{equation}
%% \par
%% \noindent
%% To finish our example, given we have 20 residuals:
%% \begin{table}[h]
%% \begin{tabular}{|c|>{$}r<{$}|>{$}r<{$}|}
%% \hline
%% index & \text{residual}_i & | \text{residual}_i | \\
%% \hline
%% 0 & 18 & 18 \\
%% 1 & 2 & 2 \\
%% 2 & 6 & 6 \\
%% 3 & -2 & 2 \\
%% 4 & 0 & 0 \\
%% 5 & -1 & 1 \\
%% 6 & -2 & 2 \\
%% 7 & 3 & 3 \\
%% 8 & -1 & 1 \\
%% 9 & -3 & 3 \\
%% 10 & -2 & 2 \\
%% 11 & 0 & 0 \\
%% 12 & -1 & 1 \\
%% 13 & 0 & 0 \\
%% 14 & 3 & 3 \\
%% 15 & 3 & 3 \\
%% 16 & -2 & 2 \\
%% 17 & 2 & 2 \\
%% 18 & -1 & 1 \\
%% 19 & -4 & 4 \\
%% \hline
%% \multicolumn{2}{|r|}{$|sum|$} & 56 \\
%% \hline
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% \begin{align*}
%% 20 \times 2^0 & \leq 56 \\
%% 20 \times 2^1 & \leq 56 \\
%% 20 \times 2^2 & > 56
%% \end{align*}
%% Therefore, the best \VAR{Energy Size} for this set of residuals is 2.

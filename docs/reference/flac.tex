\chapter{Free Lossless Audio Codec}
FLAC compresses PCM audio data losslessly using predictors and a
residual.
FLACs contain checksumming to verify their integrity, contain comment tags for
metadata and are streamable.

Except for the contents of the VORBIS\_COMMENT metadata block, everything in FLAC is big-endian.

\section{the FLAC File Stream}
\begin{figure}[h]
\includegraphics{figures/flac_stream.pdf}
\end{figure}
\par
\noindent
``Last'' is 0 when there are no additional metadata blocks and 1 when
it is the final block before the the audio frames.
``Block Length'' is the size of the metadata block data to follow,
not including the header.
\begin{figure}[h]
\begin{tabular}{| r | l |}
\hline
Block Type & Block \\
\hline
\texttt{0} & STREAMINFO \\
\texttt{1} & PADDING \\
\texttt{2} & APPLICATION \\
\texttt{3} & SEEKTABLE \\
\texttt{4} & VORBIS\_COMMENT \\
\texttt{5} & CUESHEET \\
\texttt{6} & PICTURE \\
\texttt{7-126} & reserved \\
\texttt{127} & invalid \\
\hline
\end{tabular}
\end{figure}

\pagebreak

\section{FLAC Metadata Blocks}

\subsection{STREAMINFO}
\begin{figure}[h]
\includegraphics{figures/flac_streaminfo.pdf}
\end{figure}

\subsection{PADDING}

PADDING is simply a block full of NULL (\texttt{0x00}) bytes.
Its purpose is to provide extra metadata space within the FLAC file.
By having a padding block, other metadata blocks can be grown or
shrunk without having to rewrite the entire FLAC file by removing or
adding space to the padding.


\subsection{APPLICATION}
\begin{figure}[h]
\includegraphics{figures/flac_application.pdf}
\end{figure}
\noindent
APPLICATION is a general-purpose metadata block used by a variety of
different programs.
Its contents are defined by the ASCII Application ID value.

\subsection{SEEKTABLE}
\begin{figure}[h]
\includegraphics{figures/flac_seektable.pdf}
\end{figure}

\pagebreak

\subsection{VORBIS\_COMMENT}
\begin{figure}[h]
\includegraphics{figures/flac_vorbiscomment.pdf}
\end{figure}
\par
\noindent
The length fields are all little-endian.
The Vendor String and Comment Strings are all UTF-8 encoded.
Keys are not case-sensitive and may occur multiple times,
indicating multiple values for the same field.
For instance, a track with multiple artists may have
more than one \texttt{ARTIST}.

\begin{minipage}{\linewidth}
\renewcommand\thefootnote{\thempfootnote}
{\relsize{-1}
\begin{tabular}{|r|l|}
\hline
key & value \\
\hline
ALBUM & album name \\
ARTIST & artist name, band name, composer, author, etc. \\
CATALOGNUMBER\footnote{These are proposed extension fields and not part of the official Vorbis comment specification.} & CD spine number \\
COMPOSER\footnotemark[\value{mpfootnote}] & the work's author \\
CONDUCTOR\footnotemark[\value{mpfootnote}] & performing ensemble's leader \\
COPYRIGHT & copyright attribution \\
DATE & recording date \\
DESCRIPTION & a short description \\
DISCNUMBER\footnotemark[\value{mpfootnote}] & disc number for multi-volume work \\
ENGINEER\footnotemark[\value{mpfootnote}] & the recording masterer \\
ENSEMBLE\footnotemark[\value{mpfootnote}] & performing group \\
GENRE & a short music genre label \\
GUEST ARTIST\footnotemark[\value{mpfootnote}] & collaborating artist \\
ISRC & ISRC number for the track \\
LICENSE & license information \\
LOCATION & recording location \\
OPUS\footnotemark[\value{mpfootnote}] & number of the work \\
ORGANIZATION & record label \\
PART\footnotemark[\value{mpfootnote}] & track's movement title \\
PERFORMER & performer name, orchestra, actor, etc. \\
PRODUCER\footnotemark[\value{mpfootnote}] & person responsible for the project \\
PRODUCTNUMBER\footnotemark[\value{mpfootnote}] & UPC, EAN, or JAN code \\
PUBLISHER\footnotemark[\value{mpfootnote}] & album's publisher \\
RELEASE DATE\footnotemark[\value{mpfootnote}] & date the album was published \\
REMIXER\footnotemark[\value{mpfootnote}] & person who created the remix \\
SOURCE ARTIST\footnotemark[\value{mpfootnote}] & artist of the work being performed \\
SOURCE MEDIUM\footnotemark[\value{mpfootnote}] & CD, radio, cassette, vinyl LP, etc. \\
SOURCE WORK\footnotemark[\value{mpfootnote}] & a soundtrack's original work \\
SPARS\footnotemark[\value{mpfootnote}] & DDD, ADD, AAD, etc. \\
SUBTITLE\footnotemark[\value{mpfootnote}] & for multiple track names in a single file \\
TITLE & track name \\
TRACKNUMBER & track number \\
VERSION & track version \\
\hline
\end{tabular}
}
\end{minipage}

\pagebreak

\subsection{CUESHEET}
\begin{figure}[h]
\includegraphics{figures/flac_cuesheet.pdf}
\end{figure}

\subsection{PICTURE}
\begin{figure}[h]
\includegraphics{figures/flac_picture.pdf}
\end{figure}
\begin{tabular}{|r|l|}
\hline
Picture Type & Type \\
\hline
0 & Other \\
1 & 32x32 pixels `file icon' (PNG only) \\
2 & Other file icon \\
3 & Cover (front) \\
4 & Cover (back) \\
5 & Leaflet page \\
6 & Media (e.g. label side of CD) \\
7 & Lead artist / Lead performer / Soloist \\
8 & Artist / Performer \\
9 & Conductor \\
10 & Band / Orchestra \\
11 & Composer \\
12 & Lyricist / Text writer \\
13 & Recording location \\
14 & During recording \\
15 & During performance \\
16 & Movie / Video screen capture \\
17 & A bright coloured fish \\
18 & Illustration \\
19 & Band / Artist logotype \\
20 & Publisher / Studio logotype \\
\hline
\end{tabular}

\section{FLAC Decoding}
A FLAC stream is made up of individual FLAC frames, as follows:
\begin{figure}[h]
\includegraphics{figures/flac_frame.pdf}
\end{figure}

\begin{figure}[h]
\begin{tiny}
\begin{tabular}{|c|r|r|r|l|r|c|}
\hline
Value & Block Size & Sample Rate & Channels & Assignment & Bits per Sample & Value \\
\hline
\texttt{0000} & STREAMINFO & STREAMINFO & 1 & front center & STREAMINFO & \texttt{0000} \\
\texttt{0001} & 192 & 88200 & 2 & front left, front right & 8 & \texttt{0001} \\
\texttt{0010} & 576 & 176400 & 3 & f. left, f. right, f. center & 12 & \texttt{0010} \\
\texttt{0011} & 1152 & 192000 & 4 & f. left, f. right, back left, back right & reserved & \texttt{0011} \\
\texttt{0100} & 2304 & 8000 & 5 & f. L, f. R, f. C, b. L, b. R & 16 & \texttt{0100} \\
\texttt{0101} & 4608 & 16000 & 6 & f. L, f. R, f. C, LFE, b. L, b. R & 20 & \texttt{0101} \\
\texttt{0110} & 8 bits (+1) & 22050 & 7 & undefined & 24 & \texttt{0110} \\
\texttt{0111} & 16 bits (+1) & 24000 & 8 & undefined & reserved & \texttt{0111} \\
\texttt{1000} & 256 & 32000 & 2 & 0 left, 1 difference & & \texttt{1000} \\
\texttt{1001} & 512 & 44100 & 2 & 0 difference, 1 right & & \texttt{1001} \\
\texttt{1010} & 1024 & 48000 & 2 & 0 average, 1 difference & & \texttt{1010} \\
\texttt{1011} & 2048 & 96000 & & reserved & & \texttt{1011} \\
\texttt{1100} & 4096 & 8 bits (in kHz) & & reserved & & \texttt{1100} \\
\texttt{1101} & 8192 & 16 bits (in Hz) & & reserved & & \texttt{1101} \\
\texttt{1110} & 16384 & 16 bits (in 10s of Hz) & & reserved & & \texttt{1110} \\
\texttt{1111} & 32768 & invalid & & reserved & & \texttt{1111} \\
\hline
\end{tabular}
\end{tiny}
\end{figure}
\par
\parpic[r]{
\begin{tabular}{|c|l|}
\hline
Value & Subframe Type \\
\hline
\texttt{000000} & \texttt{SUBFRAME\_CONSTANT} \\
\texttt{000001} & \texttt{SUBFRAME\_VERBATIM} \\
\texttt{00001x} & reserved \\
\texttt{0001xx} & reserved \\
\texttt{001xxx} & \texttt{SUBFRAME\_FIXED} \\
& \texttt{xxx} = predictor order \\
\texttt{01xxxx} & reserved \\
\texttt{1xxxxx} & \texttt{SUBFRAME\_LPC} \\
& \texttt{xxxxx} = predictor order - 1 \\
\hline
\end{tabular}
}
\noindent
Sample/Frame Number is a UTF-8 coded value.
If the blocking strategy is 0, it decodes to a 32-bit frame number.
If the blocking strategy is 1, it decodes to a 36-bit sample number.

There is one Subframe per channel.

`Wasted Bits Per Sample' is typically a single bit set to 0, indicating
no wasted bits per sample.  If set to 1, a unary-encoded value
follows which indicates how many bits are wasted per sample.

Padding is added as needed between the final subframe and CRC-16
in order to byte-align frames.

\pagebreak

\subsection{CONSTANT subframe}

This is the simplest possible subframe.
It consists of a single value whose size is equal to the subframe's
`Bits per Sample'.
For instance, a 16-bit subframe would have CONSTANT subframes
16 bits in length.
The value of the subframe is the value of all samples the subframe
contains.
An obvious use of this subframe is to store an entire subframe's worth
of digital silence (samples with a value of 0) very efficiently.

\subsection{VERBATIM subframe}

\begin{figure}[h]
\includegraphics{figures/flac_verbatim.pdf}
\end{figure}
\noindent
This subframe's length is equal to the subframe's `Bits per Sample'
multiplied by the frame's `Block Size'.
Since it does no compression whatsoever and simply stores
audio samples as-is, this subframe is only suitable for especially
noisy portions of a track where no suitable predictor can be found.

\subsection{FIXED subframe}

\begin{figure}[h]
\includegraphics{figures/flac_fixed.pdf}
\end{figure}
\noindent
The number of warm-up samples equals the `Predictor Order'
(which is encoded in the `Subframe Type').
Each warm-up sample is the same size as the subframe's `Bits per Sample'.
These samples are sent out as-is; they are the subframe's
`starting point' upon which further samples build when decompressing
the stream.
Determining the value of the current sample is then a matter of
looking backwards at previously decoded samples (or warm-up samples),
applying a simple formula on their values (which depends on the
Predictor Order) and adding the residual.

\begin{figure}[h]
{\relsize{-1}
\begin{tabular}{|c| >{$}l<{$} |}
\hline
Order & \text{Calculation} \\
\hline
0 & Sample_i = Residual_i  \\
1 & Sample_i = Sample_{i - 1} + Residual_i \\
2 & Sample_i = ( 2 \times Sample_{i - 1} ) - Sample_{i - 2} + Residual_i \\
3 & Sample_i = ( 3 \times Sample_{i - 1} ) - ( 3 \times Sample_{i - 2} ) + Sample_{i - 3} + Residual_i \\
4 & Sample_i = ( 4 \times Sample_{i - 1} ) - ( 6 \times Sample_{i - 2} ) + (4 \times Sample_{i - 3} ) - Sample_{i - 4} + Residual_i \\
\hline
\end{tabular}
}
\end{figure}
\parpic[r]{
{\relsize{-3} %% need to make this small or it fudges the next page's text
\begin{tabular}{|c|r|>{$}r<{$}|}
\hline
Index & Residual & \text{Sample} \\
\hline
0 & & \text{(warm-up)} \thickspace \bf10 \\
1 & 1 & 10 + 1 = \bf11 \\
2 & 2 & 11 + 2 = \bf13 \\
3 & -2 & 13 - 2 = \bf11 \\
4 & 1 & 11 + 1 = \bf12 \\
5 & -1 & 12 - 1 = \bf11 \\
\hline
\end{tabular}
}
}
\par
Let's run through a simple example in which the Predictor Order is 1.
Note that residual does not apply to warm-up samples.
How to extract the encoded residual will be covered in a later section.

\subsection{LPC Subframe}
\begin{figure}[h]
\includegraphics{figures/flac_lpc.pdf}
\end{figure}
\par
\noindent
The number of warm-up samples equals the `LPC Order'
(which is encoded in the `Subframe Type').
The size of each QLP Coefficient is equal to
`QLP Precision' number of bits, plus 1.
`QLP Shift Needed' and the value of each Coefficient are
signed two's-complement integers.
The number of Coefficients equals the `LPC Order'.
\begin{equation}
Sample_i = \left\lfloor \frac{\overset{Order - 1}{\underset{j = 0}{\sum}}
  \text{QLP Coeffcient}_j \times \text{Sample}_{i - j - 1} } {2 ^ \text{QLP Shift Needed}}\right\rfloor + Residual_i
\end{equation}
This simply means we're taking the sum of the calculated values from
0 to Order - 1, bit-shifting that sum down and added the residual
when determining the current sample.
Much like the FIXED subframe, LPC subframes also contain warm-up
samples which serve as our calculation's starting point.

In this example, the LPC Order is 5, the QLP Shift Needed is 9
and the encoded Coefficients are as follows:

\begin{figure}[h]
{\relsize{-2}
\begin{tabular}{>{$}r<{$} r}
\text{QLP Coefficient}_0 & 1241 \\
\text{QLP Coefficient}_1 & -944 \\
\text{QLP Coefficient}_2 & 14 \\
\text{QLP Coefficient}_3 & 342 \\
\text{QLP Coefficient}_4 & -147 \\
\end{tabular}
}
\end{figure}

\begin{figure}[h]
{\relsize{-2}
\begin{tabular}{|c|r|>{$}r<{$}|}
\hline
Index & Residual & \text{Sample} \\
\hline
0 & & \text{(warm-up)} \thickspace \bf1053 \\
1 & & \text{(warm-up)} \thickspace \bf1116 \\
2 & & \text{(warm-up)} \thickspace \bf1257 \\
3 & & \text{(warm-up)} \thickspace \bf1423 \\
4 & & \text{(warm-up)} \thickspace \bf1529 \\
\hline
5 & 11 & (1241 \times 1529) + (-944 \times 1423) + (14 \times 1257) + (342 \times 1116) + (-147 \times 1053) = 798656 \\
& & \lfloor 798656 \div 2 ^ 9 \rfloor = 1559 + 11 = \bf1570 \\
\hline
6 & 79 & (1241 \times 1570) + (-944 \times 1529) + (14 \times 1423) + (342 \times 1257) + (-147 \times 1116) = 790758 \\
& & \lfloor 790758 \div 2 ^ 9 \rfloor = 1544 + 79 = \bf1623 \\
\hline
7 & 24 & (1241 \times 1623) + (-944 \times 1570) + (14 \times 1529) + (342 \times 1423) + (-147 \times 1257) = 855356 \\
& & \lfloor 855356 \div 2 ^ 9 \rfloor = 1670 + 24 = \bf1694 \\
\hline
8 & -81 & (1241 \times 1694) + (-944 \times 1623) + (14 \times 1570) + (342 \times 1529) + (-147 \times 1423) = 905859 \\
& & \lfloor 905859 \div 2 ^ 9 \rfloor = 1769 - 81 = \bf1688 \\
\hline
9 & -72 & (1241 \times 1688) + (-944 \times 1694) + (14 \times 1623) + (342 \times 1570) + (-147 \times 1529) = 830571 \\
& & \lfloor 830571 \div 2 ^ 9 \rfloor = 1622 - 72 = \bf1550 \\
\hline
\end{tabular}
}
\end{figure}
\noindent
In this instance, division should always round down and \textit{not} towards zero.

\subsection{the Residual}
Though the FLAC format allows for different forms of
residual coding, two forms of partitioned Rice are the only ones
currently supported.
The difference between the two is that when `Coding Method' is 0,
the Rice Parameter in each partition is 4 bits.
When the `Coding Method' is 1, that parameter is 5 bits.
\begin{figure}[h]
\includegraphics{figures/flac_residual.pdf}
\end{figure}
\par
\noindent

There are $2 ^ \text{Partition Order}$ number of Partitions.
The number of decoded samples in a Partition depends on the
its position in the subframe.
The first partition in the subframe contains:
\begin{align}
\text{Total Samples} &= \frac{\text{Frame's Block Size}}{2 ^ {\text{Partition Order}}} - \text{Predictor Order} \\
\intertext{Subsequent partitions contain:}
\text{Total Samples} &= \frac{\text{Frame's Block Size}}{2 ^ {\text{Partition Order}}} \\
\intertext{Unless the Partition Order is 0.  In that case:}
\text{Total Samples} &= \text{Frame's Block Size} - \text{Predictor Order}
\end{align}
\noindent
since there is only one partition which takes up the entire block.

If all of the bits in `Rice Parameter' are set,
the partition is unencoded binary using `Escape Code' number of bits per
sample.

\pagebreak

\subsubsection{Rice Encoding}
The residual uses Rice coding to compress lots of mostly small values
in a very small amount of space.
To decode it, one first needs the Rice parameter.
Take a unary-encoded value\footnote{In this instance, unary-encoding is a simple matter of
counting the number of 0 bits before the next 1 bit.
The resulting sum is the value.}
from the bit stream, which are our most
significant bits (MSB).
Then take `parameter' number of additional bits, which are our least
significant bits (LSB).
Combine the two sets into our new value,
making the MSB set as the high bits and the LSB set as the low bits.
Bit 0 of this new value is the sign bit.
If it is 0, the actual value is equal to the rest of the bits.
If it is 1, the actual value is equal to the rest of the bits,
multiplied by -1 and minus 1.

This is less complicated than it sounds, so let's run through an example
in which the Rice parameter is 1:
\begin{figure}[h]
\includegraphics{figures/flac_rice1.pdf}
\end{figure}

Now, let's run through another example in which the Rice parameter is 4:
\begin{figure}[h]
\includegraphics{figures/flac_rice2.pdf}
\end{figure}

\subsection{Channels}
Since most audio has more than one channel, it is important to
understand how FLAC handles putting it back together.
When channels are stored independently, one simply interleaves
them together in the proper order.
Let's take an example of 2 channel, 16-bit audio stored this way:

\begin{figure}[h]
\includegraphics{figures/flac_channels.pdf}
\end{figure}

This is the simplest case.
However, in the case of difference channels, one subframe will
contain actual channel data and the other channel will contain
signed difference data which is applied to that actual data
in order to reconstruct both channels.
It's very important to remember that the difference channel
has 1 additional bit per sample which will be consumed during
reconstruction.
Why 1 additional bit?
Let's take an example where the left sample's value is -30000
and the right sample's value is +30000.
Storing this pair as left + difference means the left
sample remains -30000 and the difference is -60000
($-30000 - -60000 = +30000$).
-60000 won't fit into a 16-bit signed integer.
Adding that 1 additional bit doubles our range of values
and that's just enough to cover any possible difference between
two samples.

\begin{figure}[h]
{\relsize{-2}
\begin{tabular}{|c||l|l||>{$}l<{$}|>{$}l<{$}|}
\hline
Assignment & Channel 0 & Channel 1 & \text{Left Channel} & \text{Right Channel} \\
\hline
\texttt{1000} & left & difference & \text{left} & \text{left} - \text{difference} \\
\texttt{1001} & difference & right & \text{right} + \text{difference} & \text{right} \\
\texttt{1010} & mid & side & (((\text{mid} \ll 1) | (\text{side} \& 1)) + \text{side}) \gg 1 & (((\text{mid} \ll 1) | (\text{side} \& 1)) - \text{side}) \gg 1 \\
\hline
\end{tabular}
}
\end{figure}

The mid channel case is another unusual exception.
We're prepending the mid channel with bit 0 from the
side channel, performing the addition/subtraction and then
discarding that bit before assigning the results to the left and
right channels.

\subsection{Wasted Bits per Sample}
Though rare in practice, FLAC subframes support `wasted bits per sample'.
Put simply, these wasted bits are removed during subframe calculation
and restored to the subframe's least significant bits as zero value bits
when it is returned.
For instance, a subframe with 1 wasted bit per sample in a 16-bit FLAC
stream is treated as having only 15 bits per sample when reading
warm-up samples and then all through the rest of the subframe
calculation.
That wasted zero bit is then prepended to each sample prior to returning
the subframe.

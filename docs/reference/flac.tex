%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{Free Lossless Audio Codec}
FLAC compresses PCM audio data losslessly using predictors and a
residual.
FLACs contain checksumming to verify their integrity, contain comment tags for
metadata and are streamable.

Except for the contents of the VORBIS\_COMMENT metadata block, everything in FLAC is big-endian.

\section{the FLAC File Stream}
\begin{figure}[h]
\includegraphics{figures/flac/stream.pdf}
\end{figure}
\par
\noindent
\VAR{Last} is 0 when there are no additional metadata blocks and 1 when
it is the final block before the the audio frames.
\VAR{Block Length} is the size of the metadata block data to follow,
not including the header.
\begin{figure}[h]
\begin{tabular}{| r | l |}
\hline
Block Type & Block \\
\hline
\texttt{0} & STREAMINFO \\
\texttt{1} & PADDING \\
\texttt{2} & APPLICATION \\
\texttt{3} & SEEKTABLE \\
\texttt{4} & VORBIS\_COMMENT \\
\texttt{5} & CUESHEET \\
\texttt{6} & PICTURE \\
\texttt{7-126} & reserved \\
\texttt{127} & invalid \\
\hline
\end{tabular}
\end{figure}

\pagebreak

\section{FLAC Metadata Blocks}

\subsection{STREAMINFO}
\begin{figure}[h]
\includegraphics{figures/flac/streaminfo.pdf}
\end{figure}

\subsection{PADDING}

PADDING is simply a block full of NULL (\texttt{0x00}) bytes.
Its purpose is to provide extra metadata space within the FLAC file.
By having a padding block, other metadata blocks can be grown or
shrunk without having to rewrite the entire FLAC file by removing or
adding space to the padding.


\subsection{APPLICATION}
\begin{figure}[h]
\includegraphics{figures/flac/application.pdf}
\end{figure}
\noindent
APPLICATION is a general-purpose metadata block used by a variety of
different programs.
Its contents are defined by the ASCII Application ID value.

\subsection{SEEKTABLE}
\begin{figure}[h]
\includegraphics{figures/flac/seektable.pdf}
\end{figure}

\pagebreak

\subsection{VORBIS\_COMMENT}
\begin{figure}[h]
\includegraphics{figures/flac/vorbiscomment.pdf}
\end{figure}
\par
\noindent
The length fields are all little-endian.
The Vendor String and Comment Strings are all UTF-8 encoded.
Keys are not case-sensitive and may occur multiple times,
indicating multiple values for the same field.
For instance, a track with multiple artists may have
more than one \texttt{ARTIST}.

\begin{multicols}{2}
{\relsize{-2}
\begin{description}
\item[ALBUM] album name
\item[ARTIST] artist name, band name, composer, author, etc.
\item[CATALOGNUMBER*] CD spine number
\item[COMPOSER*] the work's author
\item[CONDUCTOR*] performing ensemble's leader
\item[COPYRIGHT] copyright attribution
\item[DATE] recording date
\item[DESCRIPTION] a short description
\item[DISCNUMBER*] disc number for multi-volume work
\item[ENGINEER*] the recording masterer
\item[ENSEMBLE*] performing group
\item[GENRE] a short music genre label
\item[GUEST ARTIST*] collaborating artist
\item[ISRC] ISRC number for the track
\item[LICENSE] license information
\item[LOCATION] recording location
\item[OPUS*] number of the work
\item[ORGANIZATION] record label
\item[PART*] track's movement title
\item[PERFORMER] performer name, orchestra, actor, etc.
\item[PRODUCER*] person responsible for the project
\item[PRODUCTNUMBER*] UPC, EAN, or JAN code
\item[PUBLISHER*] album's publisher
\item[RELEASE DATE*] date the album was published
\item[REMIXER*] person who created the remix
\item[SOURCE ARTIST*] artist of the work being performed
\item[SOURCE MEDIUM*] CD, radio, cassette, vinyl LP, etc.
\item[SOURCE WORK*] a soundtrack's original work
\item[SPARS*] DDD, ADD, AAD, etc.
\item[SUBTITLE*] for multiple track names in a single file
\item[TITLE] track name
\item[TRACKNUMBER] track number
\item[VERSION] track version
\end{description}
}
\end{multicols}
\par
\noindent
Fields marked with * are proposed extension fields and not part of the official Vorbis comment specification.

\pagebreak

\subsection{CUESHEET}
\begin{figure}[h]
\includegraphics{figures/flac/cuesheet.pdf}
\end{figure}

\subsection{PICTURE}
\begin{figure}[h]
\includegraphics{figures/flac/picture.pdf}
\end{figure}
\begin{tabular}{|r|l|}
\hline
Picture Type & Type \\
\hline
0 & Other \\
1 & 32x32 pixels `file icon' (PNG only) \\
2 & Other file icon \\
3 & Cover (front) \\
4 & Cover (back) \\
5 & Leaflet page \\
6 & Media (e.g. label side of CD) \\
7 & Lead artist / Lead performer / Soloist \\
8 & Artist / Performer \\
9 & Conductor \\
10 & Band / Orchestra \\
11 & Composer \\
12 & Lyricist / Text writer \\
13 & Recording location \\
14 & During recording \\
15 & During performance \\
16 & Movie / Video screen capture \\
17 & A bright colored fish \\
18 & Illustration \\
19 & Band / Artist logotype \\
20 & Publisher / Studio logotype \\
\hline
\end{tabular}

\section{FLAC Decoding}

The basic process for decoding a FLAC file is as follows:
\par
\noindent
\ALGORITHM{a FLAC encoded file}{PCM samples}
file header $\leftarrow$ \READ 4 bytes\;
\ASSERT $\text{file header} = \texttt{"fLaC"}$\;
get $PCM~frame~count$ and MD5 sum from STREAMINFO metadata block\;
skip remaining metadata blocks\;
initialize stream MD5\;
\While{$PCM~frame~count > 0$}{
  decode FLAC frame to 1 or more PCM frames\;
  deduct FLAC frame's block size from $PCM~frame~count$\;
  update stream MD5 sum with decoded PCM frame data\;
  return decoded PCM frames\;
}
\ASSERT STREAMINFO MD5 sum = stream MD5 sum
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/stream3.pdf}
\end{figure}
\par
All of the fields in the FLAC stream are big-endian.\footnote{Except
for the length fields in the VORBIS\_COMMENT metadata block.
However, this block is not needed for decoding.
}

\clearpage

\subsection{Reading Metadata Blocks}
\ALGORITHM{the FLAC file stream}{nine STREAMINFO values used for decoding}
\Repeat{last = 1}{
  $last \leftarrow$ \READ 1 unsigned bit\;
  $type \leftarrow$ \READ 7 unsigned bits\;
  $size \leftarrow$ \READ 24 unsigned bits\;
\eIf(\tcc*[f]{read STREAMINFO metadata block}){type = 0}{
\begin{tabular}{rcl}
minimum block size & $\leftarrow$ & \READ 16 unsigned bits\; \\
maximum block size & $\leftarrow$ & \READ 16 unsigned bits\; \\
mimimum frame size & $\leftarrow$ & \READ 24 unsigned bits\; \\
maximum frame size & $\leftarrow$ & \READ 24 unsigned bits\; \\
sample rate & $\leftarrow$ & \READ 20 unsigned bits\; \\
channels & $\leftarrow$ & (\READ 3 unsigned bits) + 1\; \\
bits per sample & $\leftarrow$ & (\READ 5 unsigned bits) + 1\; \\
total PCM frames & $\leftarrow$ & \READ 36 unsigned bits\; \\
MD5 sum & $\leftarrow$ & \READ 16 bytes\;
\end{tabular}
}(\tcc*[f]{skip other metadata blocks}){
  \SKIP $size$ bytes\;
}
}
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/metadata.pdf}
\end{figure}

\clearpage

For example, given the metadata bytes:
\begin{figure}[h]
\includegraphics{figures/flac/block_header.pdf}
\end{figure}
\par
\noindent
\begin{tabular}{rcrcl}
$last$ & $\leftarrow$ & \texttt{0x1} & = & is last metadata block \\
$type$ & $\leftarrow$ & \texttt{0x0} & = & METADATA block \\
$size$ & $\leftarrow$ & \texttt{0x22} & = & 34 bytes \\
minimum block size & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
maximum block size & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
minimum frame size & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
maximum frame size & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
sample rate & $\leftarrow$ & \texttt{0xAC44} & = & 44100Hz \\
channels & $\leftarrow$ & \texttt{0x1} & = & 1 (+ 1) = 2 \\
bits per sample & $\leftarrow$ & \texttt{0xF} & = & 15 (+ 1) = 16 \\
total PCM frames & $\leftarrow$ & \texttt{0x50} & = & 80
\end{tabular}

\clearpage

\subsection{Decoding a FLAC Frame}

\ALGORITHM{STREAMINFO values and the FLAC file stream}{decoded PCM samples}
read frame header to determine channel count, assignment and bits-per-sample\;
\ForEach{channel \IN channel count}{
  decode subframe to PCM samples based on its effective bits-per-sample\;
}
byte-align file stream\;
verify frame's CRC-16 checksum\;
recombine subframes based on the frame's channel assignment\;
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/frames.pdf}
\end{figure}

\clearpage

\subsection{Reading a FLAC Frame Header}

\ALGORITHM{STREAMINFO values and the FLAC file stream}{stream information and subframe decoding parameters}
\begin{tabular}{rcl}
sync code & $\leftarrow$ & \READ 14 unsigned bits\; \\
& & \ASSERT $\text{sync code} = \texttt{0x3FFE}$\; \\
& & \SKIP 1 bit\; \\
$blocking~strategy$ & $\leftarrow$ & \READ 1 unsigned bit\; \\
$encoded~block~size$ & $\leftarrow$ & \READ 4 unsigned bits\; \\
$encoded~sample~rate$ & $\leftarrow$ & \READ 4 unsigned bits\; \\
$encoded~channels$ & $\leftarrow$ & \READ 4 unsigned bits\; \\
$encoded~bps$ & $\leftarrow$ & \READ 3 unsigned bits\; \\
& & \SKIP 1 bit\; \\
frame number & $\leftarrow$ & \READ UTF-8 value\; \\
block size & $\leftarrow$ & decode $encoded~block~size$\; \\
sample rate & $\leftarrow$ & decode $encoded~sample~rate$\; \\
bits per sample & $\leftarrow$ & decode $encoded~bps$\; \\
channel count & $\leftarrow$ & decode $encoded~channels$\; \\
$CRC8$ & $\leftarrow$ & \READ 8 unsigned bits\; \\
& & verify $CRC8$\;
\end{tabular}
\EALGORITHM

\subsubsection{Reading UTF-8 Frame Number}
\ALGORITHM{FLAC file stream}{UTF-8 value as unsigned integer}
$total~bytes \leftarrow$ \UNARY with stop bit 0\;
$value \leftarrow$ \READ (7 - $total~bytes$) unsigned bits\;
\While{$total~bytes > 0$}{
  $continuation~header \leftarrow$ \READ 2 unsigned bits\;
  \ASSERT $continuation~header = 2$\;
  $continuation~bits \leftarrow$ \READ 6 unsigned bits\;
  $value \leftarrow (value \times 2 ^ 6) + continuation~bits$\;
  $total~bytes \leftarrow total~bytes - 1$\;
}
\Return $value$\;
\EALGORITHM
For example, given the UTF-8 bytes \texttt{E1 82 84}:
\par
\begin{wrapfigure}[5]{l}{2.375in}
\includegraphics{figures/flac/utf8.pdf}
\end{wrapfigure}
\begin{align*}
\text{UTF-8 value} &= \texttt{0001 000010 000100} \\
&= \texttt{0001 0000 1000 0100} \\
&= \texttt{0x1084} \\
&= 4228
\end{align*}

\clearpage

\subsubsection{Decoding Block Size}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & block size (in samples) &
encoded & block size \\
\hline
\texttt{0000} & maximum block size from STREAMINFO &
\texttt{1000} & 256 \\
\texttt{0001} & 192 &
\texttt{1001} & 512 \\
\texttt{0010} & 576 &
\texttt{1010} & 1024 \\
\texttt{0011} & 1152 &
\texttt{1011} & 2048 \\
\texttt{0100} & 2304 &
\texttt{1100} & 4096 \\
\texttt{0101} & 4608 &
\texttt{1101} & 8192 \\
\texttt{0110} & (\textbf{read} 8 unsigned bits) + 1 &
\texttt{1110} & 16384 \\
\texttt{0111} & (\textbf{read} 16 unsigned bits) + 1 &
\texttt{1111} & 32768 \\
\end{tabular}
}

\subsubsection{Decoding Sample Rate}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & sample rate (in Hz) &
encoded & sample rate \\
\hline
\texttt{0000} & from STREAMINFO &
\texttt{1000} & 32000 \\
\texttt{0001} & 88200 &
\texttt{1001} & 44100 \\
\texttt{0010} & 176400 &
\texttt{1010} & 48000 \\
\texttt{0011} & 192000 &
\texttt{1011} & 96000 \\
\texttt{0100} & 8000 &
\texttt{1100} & (\textbf{read} 8 unsigned bits) $\times$ 1000 \\
\texttt{0101} & 16000 &
\texttt{1101} & \textbf{read} 16 unsigned bits \\
\texttt{0110} & 22050 &
\texttt{1110} & (\textbf{read} 16 unsigned bits) $\times$ 10 \\
\texttt{0111} & 24000 &
\texttt{1111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Bits per Sample}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & bits-per-sample &
encoded & bits-per-sample \\
\hline
\texttt{000} & from STREAMINFO &
\texttt{100} & 16 \\
\texttt{001} & 8 &
\texttt{101} & 20 \\
\texttt{010} & 12 &
\texttt{110} & 24 \\
\texttt{011} & invalid &
\texttt{111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Channel Count and Assignment}
{\relsize{-1}
\begin{tabular}{rrl}
& channel & \\
encoded & count & channel assignment \\
\hline
\texttt{0000} & 1 & front Center \\
\texttt{0001} & 2 & front Left, front Right \\
\texttt{0010} & 3 & front Left, front Right, front Center \\
\texttt{0011} & 4 & front Left, front Right, back Left, back Right \\
\texttt{0100} & 5 & fL, fR, fC, back/surround left, back/surround right \\
\texttt{0101} & 6 & fL, fR, fC, LFE, back/surround left, back/surround right \\
\texttt{0110} & 7 & undefined \\
\texttt{0111} & 8 & undefined \\
\texttt{1000} & 2 & front Left, Difference \\
\texttt{1001} & 2 & Difference, front Right \\
\texttt{1010} & 2 & Mid, Side \\
\texttt{1011} & & reserved \\
\texttt{1100} & & reserved \\
\texttt{1101} & & reserved \\
\texttt{1110} & & reserved \\
\texttt{1111} & & reserved \\
\end{tabular}
}

\subsubsection{Frame Header Decoding Example}
\begin{figure}[h]
\includegraphics{figures/flac/header-example.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rcr}
$sync~code$ & = & \texttt{0x3FFE} \\
$encoded~block~size$ & = & \texttt{1100b} \\
$encoded~sample~rate$ & = & \texttt{1001b} \\
$encoded~channels$ & = & \texttt{0001b} \\
$encoded~bps$ & = & \texttt{100b} \\
frame number & = & 0 \\
block size & = & 4096 samples \\
sample rate & = & 44100Hz \\
bits per sample & = & 16 \\
channel count & = & 2 \\
channel assignment & = & front left, front right
\end{tabular}
}
\subsubsection{Calculating Frame Header CRC-8}
Given a header byte and previous CRC-8 checksum,
or 0 as an initial value:
\begin{equation*}
\text{checksum}_i = \text{CRC8}(byte\xor\text{checksum}_{i - 1})
\end{equation*}
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0x00 & 0x07 & 0x0E & 0x09 & 0x1C & 0x1B & 0x12 & 0x15 & 0x38 & 0x3F & 0x36 & 0x31 & 0x24 & 0x23 & 0x2A & 0x2D \\
0x1? & 0x70 & 0x77 & 0x7E & 0x79 & 0x6C & 0x6B & 0x62 & 0x65 & 0x48 & 0x4F & 0x46 & 0x41 & 0x54 & 0x53 & 0x5A & 0x5D \\
0x2? & 0xE0 & 0xE7 & 0xEE & 0xE9 & 0xFC & 0xFB & 0xF2 & 0xF5 & 0xD8 & 0xDF & 0xD6 & 0xD1 & 0xC4 & 0xC3 & 0xCA & 0xCD \\
0x3? & 0x90 & 0x97 & 0x9E & 0x99 & 0x8C & 0x8B & 0x82 & 0x85 & 0xA8 & 0xAF & 0xA6 & 0xA1 & 0xB4 & 0xB3 & 0xBA & 0xBD \\
0x4? & 0xC7 & 0xC0 & 0xC9 & 0xCE & 0xDB & 0xDC & 0xD5 & 0xD2 & 0xFF & 0xF8 & 0xF1 & 0xF6 & 0xE3 & 0xE4 & 0xED & 0xEA \\
0x5? & 0xB7 & 0xB0 & 0xB9 & 0xBE & 0xAB & 0xAC & 0xA5 & 0xA2 & 0x8F & 0x88 & 0x81 & 0x86 & 0x93 & 0x94 & 0x9D & 0x9A \\
0x6? & 0x27 & 0x20 & 0x29 & 0x2E & 0x3B & 0x3C & 0x35 & 0x32 & 0x1F & 0x18 & 0x11 & 0x16 & 0x03 & 0x04 & 0x0D & 0x0A \\
0x7? & 0x57 & 0x50 & 0x59 & 0x5E & 0x4B & 0x4C & 0x45 & 0x42 & 0x6F & 0x68 & 0x61 & 0x66 & 0x73 & 0x74 & 0x7D & 0x7A \\
0x8? & 0x89 & 0x8E & 0x87 & 0x80 & 0x95 & 0x92 & 0x9B & 0x9C & 0xB1 & 0xB6 & 0xBF & 0xB8 & 0xAD & 0xAA & 0xA3 & 0xA4 \\
0x9? & 0xF9 & 0xFE & 0xF7 & 0xF0 & 0xE5 & 0xE2 & 0xEB & 0xEC & 0xC1 & 0xC6 & 0xCF & 0xC8 & 0xDD & 0xDA & 0xD3 & 0xD4 \\
0xA? & 0x69 & 0x6E & 0x67 & 0x60 & 0x75 & 0x72 & 0x7B & 0x7C & 0x51 & 0x56 & 0x5F & 0x58 & 0x4D & 0x4A & 0x43 & 0x44 \\
0xB? & 0x19 & 0x1E & 0x17 & 0x10 & 0x05 & 0x02 & 0x0B & 0x0C & 0x21 & 0x26 & 0x2F & 0x28 & 0x3D & 0x3A & 0x33 & 0x34 \\
0xC? & 0x4E & 0x49 & 0x40 & 0x47 & 0x52 & 0x55 & 0x5C & 0x5B & 0x76 & 0x71 & 0x78 & 0x7F & 0x6A & 0x6D & 0x64 & 0x63 \\
0xD? & 0x3E & 0x39 & 0x30 & 0x37 & 0x22 & 0x25 & 0x2C & 0x2B & 0x06 & 0x01 & 0x08 & 0x0F & 0x1A & 0x1D & 0x14 & 0x13 \\
0xE? & 0xAE & 0xA9 & 0xA0 & 0xA7 & 0xB2 & 0xB5 & 0xBC & 0xBB & 0x96 & 0x91 & 0x98 & 0x9F & 0x8A & 0x8D & 0x84 & 0x83 \\
0xF? & 0xDE & 0xD9 & 0xD0 & 0xD7 & 0xC2 & 0xC5 & 0xCC & 0xCB & 0xE6 & 0xE1 & 0xE8 & 0xEF & 0xFA & 0xFD & 0xF4 & 0xF3 \\
\hline
\end{tabular}
}
\end{table}
\begin{align*}
\text{checksum}_0 = \text{CRC8}(\texttt{FF}\xor\texttt{00}) = \texttt{F3} & &
\text{checksum}_3 = \text{CRC8}(\texttt{18}\xor\texttt{E6}) = \texttt{F4} \\
\text{checksum}_1 = \text{CRC8}(\texttt{F8}\xor\texttt{F3}) = \texttt{31} & &
\text{checksum}_4 = \text{CRC8}(\texttt{00}\xor\texttt{F4}) = \texttt{C2} \\
\text{checksum}_2 = \text{CRC8}(\texttt{C9}\xor\texttt{31}) = \texttt{E6} & &
\text{checksum}_5 = \text{CRC8}(\texttt{C2}\xor\texttt{C2}) = \texttt{00} \\
\end{align*}
Note that the final checksum (including the CRC-8 byte itself)
should always be 0.


\clearpage

\subsection{Decoding a FLAC Subframe}
\ALGORITHM{the frame's block size and bits per sample, the subframe's channel assignment and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{DIFFERENCE}{Difference}
\SetKwData{SIDE}{Side}
\SetKwData{ORDER}{order}
\SetKwData{SAMPLES}{subframe samples}
\SKIP 1 bit\;
$type\_order \leftarrow$ \READ 6 unsigned bits\;
\eIf(\tcc*[f]{account for wasted bits}){(\READ 1 unsigned bit) $ = 1$}{
  $wasted~BPS \leftarrow$ (\UNARY stop bit 1) + 1\;
  subframe's bits per sample $\leftarrow \text{frame header's bits per sample} - wasted~BPS$\;
}{
  $wasted~BPS \leftarrow 0$\;
  subframe's bits per sample $\leftarrow \text{frame header's bits per sample}$\;
}
\If{subframe's channel assignment is \DIFFERENCE or \SIDE}{
  subframe's bits per sample $\leftarrow$ subframe's bits per sample + 1
}
\uIf{$type\_order = 0$}{
  \SAMPLES $\leftarrow$ decode CONSTANT subframe
}
\uElseIf{$type\_order = 1$} {
  \SAMPLES $\leftarrow$ decode VERBATIM subframe\;
}
\uElseIf{$8 \leq type\_order \leq 12$} {
  \SAMPLES $\leftarrow$ decode FIXED subframe with \ORDER ($type\_order - 8$)\;
}
\uElseIf{$32 \leq type\_order \leq 63$} {
  \SAMPLES $\leftarrow$ decode LPC subframe with \ORDER ($type\_order - 31$)\;
}
\Else {
  undefined subframe type error\;
}
\If(\tcc*[f]{prepend any wasted bits to each sample}){$wasted~BPS > 0$}{
  \ForEach{sample \IN \SAMPLES}{
    $sample \leftarrow sample \times 2 ^ {wasted~BPS}$\;
  }
}
\Return \SAMPLES\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/subframes.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding CONSTANT Subframe}
\ALGORITHM{the frame's block size, the subframe's bits per sample and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
constant $\leftarrow$ \READ (\BPS) signed bits\;
\For{i = 0 \emph{\KwTo}block size}{
  $sample_i \leftarrow $ constant\;
}
\Return samples\;
\EALGORITHM

\subsubsection{Decoding VERBATIM Subframe}
\ALGORITHM{the frame's block size, the subframe's bits per sample and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
\For{i = 0 \emph{\KwTo}block size}{
  $sample_i \leftarrow $ \READ (\BPS) signed bits\;
}
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/verbatim.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding FIXED Subframe}
\ALGORITHM{the frame's block size and predictor order, the subframe's bits per sample and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
\SetKwData{ORDER}{order}
\SetKwData{RESIDUALS}{residuals}
\SetKwData{BLOCKSIZE}{block size}
\For(\tcc*[f]{warm-up samples}){i = 0 \emph{\KwTo}\ORDER}{
  $sample_i \leftarrow $ \READ (\BPS) signed bits\;
}
\RESIDUALS $\leftarrow$ read residual block with frame's \BLOCKSIZE and subframe's \ORDER\;
\Switch{\ORDER}{
  \uCase{0} {
    \For{i = 0 \emph{\KwTo}\BLOCKSIZE}{
      $sample_i \leftarrow residual_i$
    }
  }
  \uCase{1} {
    \For{i = 1 \emph{\KwTo}\BLOCKSIZE}{
      $sample_i \leftarrow sample_{i - 1} + residual_{i - 1}$
    }
  }
  \uCase{2} {
    \For{i = 2 \emph{\KwTo}\BLOCKSIZE}{
      $sample_i \leftarrow (2 \times sample_{i - 1}) - sample_{i - 2} + residual_{i - 2}$
    }
  }
  \uCase{3} {
    \For{i = 3 \emph{\KwTo}\BLOCKSIZE}{
      $sample_i \leftarrow (3 \times sample_{i - 1}) - (3 \times sample_{i - 2}) + sample_{i - 3} + residual_{i - 3}$
    }
  }
  \Case{4} {
    \For{i = 4 \emph{\KwTo}\BLOCKSIZE}{
      $sample_i \leftarrow (4 \times sample_{i - 1}) - (6 \times sample_{i - 2}) + (4 \times sample_{i - 3}) - sample_{i - 4} + residual_{i - 4}$
    }
  }
}
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/fixed.pdf}
\end{figure}

\clearpage

\subsubsection{FIXED Subframe Decoding Example}

Given the subframe bytes of a 16 bits per sample stream\footnote{Decoding the residual block is explained on page \pageref{residual_decoding_example}}:
\begin{figure}[h]
\includegraphics{figures/flac/fixed-parse.pdf}
\end{figure}
\par
\noindent
\begin{tabular}{rcl|rcr|rcr}
subframe type & $\leftarrow$ & FIXED &
$\text{residual}_0$ & $\leftarrow$ & -2 &
$\text{residual}_5$ & $\leftarrow$ & -5 \\
subframe order & $\leftarrow$ & 1 &
$\text{residual}_1$ & $\leftarrow$ & 3 &
$\text{residual}_6$ & $\leftarrow$ & 4 \\
wasted BPS & $\leftarrow$ & 0 &
$\text{residual}_2$ & $\leftarrow$ & -1 &
$\text{residual}_7$ & $\leftarrow$ & -2 \\
$\text{sample}_0$ & $\leftarrow$ & 37 &
$\text{residual}_3$ & $\leftarrow$ & -5 &
$\text{residual}_8$ & $\leftarrow$ & -3 \\
& & &
$\text{residual}_4$ & $\leftarrow$ & 1 &
$\text{residual}_9$ & $\leftarrow$ & 1 \\
\end{tabular}
\par
\noindent
our calculated subframe samples are:
\par
\noindent
\begin{tabular}{rcr}
$\text{sample}_0$ & $\leftarrow$ & \textbf{37} \\
$\text{sample}_1$ & $\leftarrow$ & 37 - 2 = \textbf{35} \\
$\text{sample}_2$ & $\leftarrow$ & 35 + 3 = \textbf{38} \\
$\text{sample}_3$ & $\leftarrow$ & 38 - 1 = \textbf{37} \\
$\text{sample}_4$ & $\leftarrow$ & 37 - 5 = \textbf{32} \\
$\text{sample}_5$ & $\leftarrow$ & 32 + 1 = \textbf{33} \\
$\text{sample}_6$ & $\leftarrow$ & 33 - 5 = \textbf{27} \\
$\text{sample}_7$ & $\leftarrow$ & 27 + 4 = \textbf{31} \\
$\text{sample}_8$ & $\leftarrow$ & 31 - 2 = \textbf{29} \\
$\text{sample}_9$ & $\leftarrow$ & 29 - 3 = \textbf{26} \\
$\text{sample}_{10}$ & $\leftarrow$ & 26 + 1 = \textbf{27} \\
\end{tabular}

\clearpage

\subsubsection{Decoding LPC Subframe}
\ALGORITHM{the frame's block size and predictor order, the subframe's bits per sample and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
\SetKwData{ORDER}{order}
\SetKwData{RESIDUALS}{residuals}
\SetKwData{BLOCKSIZE}{block size}
\SetKwFunction{MAX}{max}
\For(\tcc*[f]{warm-up samples}){i = 0 \emph{\KwTo}\ORDER}{
  $sample_i \leftarrow $ \READ (\BPS) signed bits\;
}
QLP precision $\leftarrow$ (\READ 4 unsigned bits) + 1\;
QLP shift needed $\leftarrow$ \MAX(\READ 5 signed bits, 0)\footnote{negative shifts are noops in the decoder}\;
\For{i = 0 \emph{\KwTo}\ORDER}{
  $QLP~coefficient_i \leftarrow$ \READ (QLP precision) signed bits\;
}
\RESIDUALS $\leftarrow$ read residual block with frame's \BLOCKSIZE and subframe's \ORDER\;
\For{i = \ORDER \emph{\KwTo}\BLOCKSIZE}{
  $sample_i \leftarrow \left\lfloor \frac{\overset{\ORDER - 1}{\underset{j = 0}{\sum}}
    QLP~coefficient_j \times sample_{i - j - 1} } {2 ^ \text{QLP shift needed}}\right\rfloor + residual_{i - \ORDER}$\;
}
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/lpc.pdf}
\end{figure}

\subsubsection{LPC Subframe Decoding Example}

\begin{tabular}{rcl|rcr}
subframe type & $\leftarrow$ & LPC &
$\text{residual}_0$ & $\leftarrow$ & 4 \\
subframe order & $\leftarrow$ & 3 &
$\text{residual}_1$ & $\leftarrow$ & 0 \\
wasted BPS & $\leftarrow$ & 0 &
$\text{residual}_2$ & $\leftarrow$ & 1 \\
$\text{sample}_0$ & $\leftarrow$ & 43 &
$\text{residual}_3$ & $\leftarrow$ & -2 \\
$\text{sample}_1$ & $\leftarrow$ & 48 &
$\text{residual}_4$ & $\leftarrow$ & -3 \\
$\text{sample}_2$ & $\leftarrow$ & 50 & & & \\
QLP precision & $\leftarrow$ & 12 & & & \\
QLP shift needed & $\leftarrow$ & 10 & & & \\
$\text{QLP coefficient}_0$ & $\leftarrow$ & 1451 & & & \\
$\text{QLP coefficient}_1$ & $\leftarrow$ & -323 & & & \\
$\text{QLP coefficient}_2$ & $\leftarrow$ & -110 & & & \\
\end{tabular}

\clearpage

\begin{figure}[h]
\includegraphics{figures/flac/lpc-parse.pdf}
\end{figure}
\begin{align*}
\text{sample}_0 &\leftarrow 43 \\
\text{sample}_1 &\leftarrow 48 \\
\text{sample}_2 &\leftarrow 50 \\
\text{sample}_3 &\leftarrow \left\lfloor\frac{(1451 \times 50) + (-323 \times 48) + (-110 \times 43)}{2 ^ {10}}\right\rfloor + 4 = \left\lfloor\frac{52316}{1024}\right\rfloor + 4 = \textbf{55} \\
\text{sample}_4 &\leftarrow \left\lfloor\frac{(1451 \times 55) + (-323 \times 50) + (-110 \times 48)}{2 ^ {10}}\right\rfloor + 0 = \left\lfloor\frac{58375}{1024}\right\rfloor + 0 = \textbf{57} \\
\text{sample}_5 &\leftarrow \left\lfloor\frac{(1451 \times 57) + (-323 \times 55) + (-110 \times 50)}{2 ^ {10}}\right\rfloor + 1 = \left\lfloor\frac{59442}{1024}\right\rfloor + 1 = \textbf{59} \\
\text{sample}_6 &\leftarrow \left\lfloor\frac{(1451 \times 59) + (-323 \times 57) + (-110 \times 55)}{2 ^ {10}}\right\rfloor - 2 = \left\lfloor\frac{61148}{1024}\right\rfloor - 2 = \textbf{57} \\
\text{sample}_7 &\leftarrow \left\lfloor\frac{(1451 \times 57) + (-323 \times 59) + (-110 \times 57)}{2 ^ {10}}\right\rfloor - 3 = \left\lfloor\frac{57380}{1024}\right\rfloor - 3 = \textbf{53} \\
\end{align*}

\clearpage

\subsubsection{Decoding Residual Block}
\label{residual_decoding_example}
\ALGORITHM{the frame's block size and predictor order, the FLAC file stream}{decoded signed residual values}
\SetKwData{ORDER}{predictor order}
\SetKwData{RESIDUALS}{residuals}
coding method $\leftarrow$ \READ 2 unsigned bits\;
partition order $\leftarrow$ \READ 4 unsigned bits\;
\For{p = 0 \emph{\KwTo}$2 ^ {\text{partition order}}$}{
  \eIf{p = 0}{
    $partition~residual~count \leftarrow \lfloor\text{block size} \div 2 ^ {partition~order}\rfloor - \text{\ORDER}$
  }{
    $partition~residual~count \leftarrow \lfloor\text{block size} \div 2 ^ {partition~order}\rfloor$
  }
  partition's residuals $\leftarrow$ decode residual partition\;
  append partition's residuals to block's residual list\;
}
\Return block's residual list\;
\EALGORITHM

\subsubsection{Decoding Residual Partition}
{\relsize{-1}
\ALGORITHM{the residual block's coding method, the partition's residual count, the FLAC file stream}{decoded signed residual values}
  \uIf{coding method = 0}{
    Rice parameter $\leftarrow$ \READ 4 unsigned bits\;
    \If(\tcc*[f]{handle unencoded residuals}){Rice parameter = 15}{
      escape code $\leftarrow$ \READ 5 unsigned bits\;
      \For{i = 0 \emph{\KwTo}partition residual count}{
        $residual_i \leftarrow$ \READ (escape code) signed bits\;
      }
      \Return partition's residual list\;
    }
  }
  \uElseIf{coding method = 1}{
    Rice parameter $\leftarrow$ \READ 5 unsigned bits\;
    \If(\tcc*[f]{handle unencoded residuals}){Rice parameter = 31}{
      escape code $\leftarrow$ \READ 5 unsigned bits\;
      \For{i = 0 \emph{\KwTo}partition residual count}{
        $residual_i \leftarrow$ \READ (escape code) signed bits\;
      }
      \Return partition's residual list\;
    }
  }
  \Else{
    undefined residual coding method error\;
  }

  \For{i = 0 \emph{\KwTo}partition residual count} {
    MSB $\leftarrow$ \UNARY with stop bit 1\;
    LSB $\leftarrow$ \READ (Rice parameter) unsigned bits\;
    unsigned $\leftarrow \text{MSB} \times 2 ^ \text{Rice parameter} + \text{LSB}$\;
    \eIf{unsigned is even}{
      $residual_i \leftarrow unsigned \div 2$\;
    }{
      $residual_i \leftarrow -\lfloor unsigned \div 2 \rfloor - 1$\;
    }
  }
  \Return partition's residual list\;
\EALGORITHM
}

\clearpage

\begin{figure}[h]
\includegraphics{figures/flac/residual.pdf}
\end{figure}
\par
\noindent
As an example, we'll decode 10 residual values from the following bytes:
\begin{figure}[h]
\includegraphics{figures/flac/residual-parse.pdf}
\end{figure}
\par
\noindent
{\relsize{-1}
\begin{tabular}{rcl|rcl}
coding method & $\leftarrow$ & 0 \\
paritition order & $\leftarrow$ & 0 \\
Rice parameter & $\leftarrow$ & 2 \\
\hline
$\text{MSB}_0$ & $\leftarrow$ & 0 &
$\text{MSB}_5$ & $\leftarrow$ & 2 \\
$\text{LSB}_0$ & $\leftarrow$ & 3 &
$\text{LSB}_5$ & $\leftarrow$ & 1 \\
$\text{unsigned}_0$ & $\leftarrow$ & $0 \times 2 ^ 2 + 3 = 3$ &
$\text{unsigned}_5$ & $\leftarrow$ & $2 \times 2 ^ 2 + 1 = 9$ \\
$\text{residual}_0$ & $\leftarrow$ & $-\lfloor 3 \div 2\rfloor - 1 = -2$ &
$\text{residual}_5$ & $\leftarrow$ & $-\lfloor 9 \div 2\rfloor - 1 = -5$ \\
\hline
$\text{MSB}_1$ & $\leftarrow$ & 1 &
$\text{MSB}_6$ & $\leftarrow$ & 2 \\
$\text{LSB}_1$ & $\leftarrow$ & 2 &
$\text{LSB}_6$ & $\leftarrow$ & 0 \\
$\text{unsigned}_1$ & $\leftarrow$ & $1 \times 2 ^ 2 + 2 = 6$ &
$\text{unsigned}_6$ & $\leftarrow$ & $2 \times 2 ^ 2 + 0 = 8$ \\
$\text{residual}_1$ & $\leftarrow$ & $6 \div 2 = 3$ &
$\text{residual}_6$ & $\leftarrow$ & $8 \div 2 = 4$ \\
\hline
$\text{MSB}_2$ & $\leftarrow$ & 0 &
$\text{MSB}_7$ & $\leftarrow$ & 0 \\
$\text{LSB}_2$ & $\leftarrow$ & 1 &
$\text{LSB}_7$ & $\leftarrow$ & 3 \\
$\text{unsigned}_2$ & $\leftarrow$ & $0 \times 2 ^ 2 + 1 = 1$ &
$\text{unsigned}_7$ & $\leftarrow$ & $0 \times 2 ^ 2 + 3 = 3$ \\
$\text{residual}_2$ & $\leftarrow$ & $-\lfloor 1 \div 2\rfloor - 1 = -1$ &
$\text{residual}_7$ & $\leftarrow$ & $-\lfloor 3 \div 2\rfloor - 1 = -2$ \\
\hline
$\text{MSB}_3$ & $\leftarrow$ & 2 &
$\text{MSB}_8$ & $\leftarrow$ & 1 \\
$\text{LSB}_3$ & $\leftarrow$ & 1 &
$\text{LSB}_8$ & $\leftarrow$ & 1 \\
$\text{unsigned}_3$ & $\leftarrow$ & $2 \times 2 ^ 2 + 1 = 9$ &
$\text{unsigned}_8$ & $\leftarrow$ & $1 \times 2 ^ 2 + 1 = 5$ \\
$\text{residual}_3$ & $\leftarrow$ & $-\lfloor 9 \div 2\rfloor - 1 = -5$ &
$\text{residual}_8$ & $\leftarrow$ & $-\lfloor 5 \div 2\rfloor - 1 = -3$ \\
\hline
$\text{MSB}_4$ & $\leftarrow$ & 0 &
$\text{MSB}_9$ & $\leftarrow$ & 0 \\
$\text{LSB}_4$ & $\leftarrow$ & 2 &
$\text{LSB}_9$ & $\leftarrow$ & 2 \\
$\text{unsigned}_4$ & $\leftarrow$ & $0 \times 2 ^ 2 + 2 = 2$ &
$\text{unsigned}_9$ & $\leftarrow$ & $0 \times 2 ^ 2 + 2 = 2$ \\
$\text{residual}_4$ & $\leftarrow$ & $2 \div 2 = 1$ &
$\text{residual}_9$ & $\leftarrow$ & $2 \div 2 = 1$ \\
\end{tabular}
}
\par
\noindent
\vskip .25in
for a final set of residuals: -2, 3, -1, -5, 1, -5, 4, -2, -3 and 1.

\clearpage

\subsection{Calculating Frame CRC-16}

CRC-16 is used to checksum the entire FLAC frame, including the header
and any padding bits after the final subframe.
Given a byte of input and the previous CRC-16 checksum,
or 0 as an initial value, the current checksum can be calculated as follows:
\begin{equation}
\text{checksum}_i = \text{CRC16}(byte\xor(\text{checksum}_{i - 1} \gg 8 ))\xor(\text{checksum}_{i - 1} \ll 8)
\end{equation}
\par
\noindent
and the checksum is always truncated to 16-bits.
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0000 & 8005 & 800f & 000a & 801b & 001e & 0014 & 8011 & 8033 & 0036 & 003c & 8039 & 0028 & 802d & 8027 & 0022 \\
0x1? & 8063 & 0066 & 006c & 8069 & 0078 & 807d & 8077 & 0072 & 0050 & 8055 & 805f & 005a & 804b & 004e & 0044 & 8041 \\
0x2? & 80c3 & 00c6 & 00cc & 80c9 & 00d8 & 80dd & 80d7 & 00d2 & 00f0 & 80f5 & 80ff & 00fa & 80eb & 00ee & 00e4 & 80e1 \\
0x3? & 00a0 & 80a5 & 80af & 00aa & 80bb & 00be & 00b4 & 80b1 & 8093 & 0096 & 009c & 8099 & 0088 & 808d & 8087 & 0082 \\
0x4? & 8183 & 0186 & 018c & 8189 & 0198 & 819d & 8197 & 0192 & 01b0 & 81b5 & 81bf & 01ba & 81ab & 01ae & 01a4 & 81a1 \\
0x5? & 01e0 & 81e5 & 81ef & 01ea & 81fb & 01fe & 01f4 & 81f1 & 81d3 & 01d6 & 01dc & 81d9 & 01c8 & 81cd & 81c7 & 01c2 \\
0x6? & 0140 & 8145 & 814f & 014a & 815b & 015e & 0154 & 8151 & 8173 & 0176 & 017c & 8179 & 0168 & 816d & 8167 & 0162 \\
0x7? & 8123 & 0126 & 012c & 8129 & 0138 & 813d & 8137 & 0132 & 0110 & 8115 & 811f & 011a & 810b & 010e & 0104 & 8101 \\
0x8? & 8303 & 0306 & 030c & 8309 & 0318 & 831d & 8317 & 0312 & 0330 & 8335 & 833f & 033a & 832b & 032e & 0324 & 8321 \\
0x9? & 0360 & 8365 & 836f & 036a & 837b & 037e & 0374 & 8371 & 8353 & 0356 & 035c & 8359 & 0348 & 834d & 8347 & 0342 \\
0xA? & 03c0 & 83c5 & 83cf & 03ca & 83db & 03de & 03d4 & 83d1 & 83f3 & 03f6 & 03fc & 83f9 & 03e8 & 83ed & 83e7 & 03e2 \\
0xB? & 83a3 & 03a6 & 03ac & 83a9 & 03b8 & 83bd & 83b7 & 03b2 & 0390 & 8395 & 839f & 039a & 838b & 038e & 0384 & 8381 \\
0xC? & 0280 & 8285 & 828f & 028a & 829b & 029e & 0294 & 8291 & 82b3 & 02b6 & 02bc & 82b9 & 02a8 & 82ad & 82a7 & 02a2 \\
0xD? & 82e3 & 02e6 & 02ec & 82e9 & 02f8 & 82fd & 82f7 & 02f2 & 02d0 & 82d5 & 82df & 02da & 82cb & 02ce & 02c4 & 82c1 \\
0xE? & 8243 & 0246 & 024c & 8249 & 0258 & 825d & 8257 & 0252 & 0270 & 8275 & 827f & 027a & 826b & 026e & 0264 & 8261 \\
0xF? & 0220 & 8225 & 822f & 022a & 823b & 023e & 0234 & 8231 & 8213 & 0216 & 021c & 8219 & 0208 & 820d & 8207 & 0202 \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
For example, given the frame bytes:
\texttt{FF F8 CC 1C 00 C0 EB 00 00 00 00 00 00 00 00},
the frame's CRC-16 can be calculated:
{\relsize{-2}
\begin{align*}
\CRCSIXTEEN{0}{0xFF}{0x0000}{0xFF}{0x0000}{0x0202} \\
\CRCSIXTEEN{1}{0xF8}{0x0202}{0xFA}{0x0200}{0x001C} \\
\CRCSIXTEEN{2}{0xCC}{0x001C}{0xCC}{0x1C00}{0x1EA8} \\
\CRCSIXTEEN{3}{0x1C}{0x1EA8}{0x02}{0xA800}{0x280F} \\
\CRCSIXTEEN{4}{0x00}{0x280F}{0x28}{0x0F00}{0x0FF0} \\
\CRCSIXTEEN{5}{0xC0}{0x0FF0}{0xCF}{0xF000}{0xF2A2} \\
\CRCSIXTEEN{6}{0xEB}{0xF2A2}{0x19}{0xA200}{0x2255} \\
\CRCSIXTEEN{7}{0x00}{0x2255}{0x22}{0x5500}{0x55CC} \\
\CRCSIXTEEN{8}{0x00}{0x55CC}{0x55}{0xCC00}{0xCDFE} \\
\CRCSIXTEEN{9}{0x00}{0xCDFE}{0xCD}{0xFE00}{0x7CAD} \\
\CRCSIXTEEN{10}{0x00}{0x7CAD}{0x7C}{0xAD00}{0x2C0B} \\
\CRCSIXTEEN{11}{0x00}{0x2C0B}{0x2C}{0x0B00}{0x8BEB} \\
\CRCSIXTEEN{12}{0x00}{0x8BEB}{0x8B}{0xEB00}{0xE83A} \\
\CRCSIXTEEN{13}{0x00}{0xE83A}{0xE8}{0x3A00}{0x3870} \\
\CRCSIXTEEN{14}{0x00}{0x3870}{0x38}{0x7000}{0xF093} \\
\intertext{Thus, the next two bytes after the final subframe should be
\texttt{0xF0} and \texttt{0x93}.
Again, when the checksum bytes are run through the checksumming procedure:}
\CRCSIXTEEN{15}{0xF0}{0xF093}{0x00}{0x9300}{0x9300} \\
\CRCSIXTEEN{16}{0x93}{0x9300}{0x00}{0x0000}{0x0000}
\end{align*}
the result will also always be 0, just as in the CRC-8.
}

\clearpage

\subsection{Recombining Subframes}
\label{flac_recombining_subframes}
\ALGORITHM{the frame's block size and channel assignment, a set of decoded subframe samples\footnote{$subframe_{x~y}$ indicates the $y$th sample in subframe $x$}}{a single list of signed PCM frames}
\uIf(\tcc*[f]{independent}){$0 \leq encoded~channels \leq 7$}{
 channel count $\leftarrow encoded~channels + 1$\;
  \For{i = 0 \emph{\KwTo}block size}{
    \For{j = 0 \emph{\KwTo}channel count}{
      $sample_{i \times channel~count + j} \leftarrow subframe_{j~i}$\;
    }
  }
}
\uElseIf(\tcc*[f]{left-difference}){$encoded~channels = 8$}{
  \For{i = 0 \emph{\KwTo}block size}{
    \begin{tabular}{ll}
      $sample_{i \times 2}$ & $\leftarrow subframe_{0~i}$ \\
      $sample_{i \times 2 + 1}$ & $\leftarrow subframe_{0~i} - subframe_{1~i}$ \\
    \end{tabular}
  }
}
\uElseIf(\tcc*[f]{difference-right}){$encoded~channels = 9$}{
  \For{i = 0 \emph{\KwTo}block size}{
    \begin{tabular}{ll}
      $sample_{i \times 2}$ & $\leftarrow subframe_{0~i} + subframe_{1~i}$ \\
      $sample_{i \times 2 + 1}$ & $\leftarrow subframe_{1~i}$ \\
    \end{tabular}
  }
}
\ElseIf(\tcc*[f]{mid-side}){$encoded~channels = 10$}{
  \For{i = 0 \emph{\KwTo}block size}{
    \begin{tabular}{ll}
      $sample_{i \times 2}$ & $\leftarrow \lfloor(((subframe_{0~i} \times 2) + (subframe_{1~i} \bmod 2)) + subframe_{1~i}) \div 2\rfloor$ \\
      $sample_{i \times 2 + 1}$ & $\leftarrow \lfloor(((subframe_{0~i} \times 2) + (subframe_{1~i} \bmod 2)) - subframe_{1~i}) \div 2\rfloor$ \\
    \end{tabular}
  }
}
\Return samples\;
\EALGORITHM

\clearpage

\subsection{Updating Stream MD5 Sum}

\ALGORITHM{the frame's signed PCM samples\footnote{$sample_{x~y}$ indicates the $y$th sample in channel $x$}}{the stream's updated MD5 sum}
\For{i = 0 \emph{\KwTo}block size}{
  \For{j = 0 \emph{\KwTo}channel count}{
    bytes $\leftarrow sample_{j~i}$ as signed, little-endian bytes\;
    update stream's MD5 sum with bytes\;
  }
}
\EALGORITHM
\vskip .25in
\par
\noindent
For example, given a 16 bits per sample stream with the signed sample values:
\begin{table}[h]
\begin{tabular}{r|rr}
& $channel_0$ & $channel_1$ \\
\hline
$sample_0$ & 1 & -1 \\
$sample_1$ & 2 & -2 \\
$sample_2$ & 3 & -3 \\
\end{tabular}
\end{table}
\par
\noindent
are translated to the bytes:
\begin{table}[h]
\begin{tabular}{r|rr}
& $channel_0$ & $channel_1$ \\
\hline
$sample_0$ & \texttt{01 00} & \texttt{FF FF} \\
$sample_1$ & \texttt{02 00} & \texttt{FE FF} \\
$sample_2$ & \texttt{03 00} & \texttt{FD FF} \\
\end{tabular}
\end{table}
\par
\noindent
and combined as:
\vskip .15in
\par
\noindent
\texttt{01 00 FF FF 02 00 FE FF 03 00 FD FF}
\vskip .15in
\par
\noindent
whose MD5 sum is:
\vskip .15in
\par
\noindent
\texttt{E7482f6462B27EE04EADC079291C79E9}

\clearpage

\section{FLAC Encoding}

The basic process for encoding a FLAC file is as follows:
\par
\noindent
\ALGORITHM{PCM frames, a default block size and various encoding parameters:
\newline
\begin{tabular}{rll}
parameter & possible values & typical values \\
\hline
block size & a positive number of PCM frames & 1152 or 4096 \\
maximum LPC order & integer between 0 and 32, inclusive & 0, 6, 8 or 12 \\
minimum partition order & integer between 0 and 16, inclusive & 0 \\
maximum partition order & integer between 0 and 16, inclusive & 3, 4, 5 or 6 \\
try mid-side & true or false & \\
try adaptive mid-side & true or false & \\
exhaustive model search & true or false & \\
\end{tabular}
}{an encoded FLAC file}
\SetKwData{BLOCKSIZE}{block size}
\WRITE \texttt{"fLaC"} in 4 bytes\;
write placeholder STREAMINFO metadata block\;
write PADDING metadata block\;
initialize stream's MD5 sum\;
\While{PCM frames remain}{
  take \BLOCKSIZE PCM frames from the input\;
  update the stream's MD5 sum with that PCM data\;
  encode a FLAC frame from PCM frames using the given encoding parameters\;
  update STREAMINFO's values from the FLAC frame\;
}
return to the start of the file and rewrite the STREAMINFO metadata block\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{figures/flac/stream3.pdf}
\end{figure}
\par
\noindent
All of the fields in the FLAC stream are big-endian.

\clearpage

\subsection{Writing Placeholder Metadata Blocks}
\ALGORITHM{input stream's attributes, a default block size}{1 or more metadata blocks to the FLAC file stream}
\WRITE 0 as 1 unsigned bit\tcc*[r]{is last block}
\WRITE 0 as 7 unsigned bits\tcc*[r]{STREAMINFO type}
\WRITE 34 as 24 unsigned bits\tcc*[r]{STREAMINFO size}
\WRITE default block size as 16 unsigned bits\tcc*[r]{minimum block size}
\WRITE default block size as 16 unsigned bits\tcc*[r]{maximum block size}
\WRITE 0 as 24 unsigned bits\tcc*[r]{minimum frame size}
\WRITE 0 as 24 unsigned bits\tcc*[r]{maximum frame size}
\WRITE stream's sample rate as 20 unsigned bits\;
\WRITE (stream's channels - 1) as 3 unsigned bits\;
\WRITE (streams bits per sample - 1) as 5 unsigned bits\;
\WRITE 0 as 36 unsigned bits\tcc*[r]{total PCM frames}
\WRITE 0 as 16 bytes\tcc*[r]{stream's MD5 sum}
\BlankLine
\BlankLine
\WRITE 1 as 1 unsigned bit\tcc*[r]{is last block}
\WRITE 1 as 7 unsigned bits\tcc*[r]{PADDING type}
\WRITE 4096 as 24 unsigned bits\tcc*[r]{PADDING size}
\WRITE 0 as 4096 bytes\tcc*[r]{PADDING's data}
\EALGORITHM
\par
\noindent
PADDING can be some size other than 4096 bytes.
One simply wants to leave enough room for a VORBIS\_COMMENT block,
SEEKTABLE and so forth.
Other fields such as the minimum/maximum frame size
and the stream's final MD5 sum can't be known in advance;
we'll need to return to this block once encoding is finished
in order to populate them.
\begin{figure}[h]
\includegraphics{figures/flac/metadata.pdf}
\end{figure}


\clearpage

\subsection{Updating Stream MD5 Sum}
\ALGORITHM{the frame's signed PCM input samples\footnote{$sample_{x~y}$ indicates the $y$th sample in channel $x$}}{the stream's updated MD5 sum}
\For{i = 0 \emph{\KwTo}block size}{
  \For{j = 0 \emph{\KwTo}channel count}{
    bytes $\leftarrow sample_{j~i}$ as signed, little-endian bytes\;
    update stream's MD5 sum with bytes\;
  }
}
\EALGORITHM
\par
\noindent
For example, given a 16 bits per sample stream with the signed sample values:
\begin{table}[h]
\begin{tabular}{r|rr}
& $channel_0$ & $channel_1$ \\
\hline
$sample_0$ & 1 & -1 \\
$sample_1$ & 2 & -2 \\
$sample_2$ & 3 & -3 \\
\end{tabular}
\end{table}
\par
\noindent
are translated to the bytes:
\begin{table}[h]
\begin{tabular}{r|rr}
& $channel_0$ & $channel_1$ \\
\hline
$sample_0$ & \texttt{01 00} & \texttt{FF FF} \\
$sample_1$ & \texttt{02 00} & \texttt{FE FF} \\
$sample_2$ & \texttt{03 00} & \texttt{FD FF} \\
\end{tabular}
\end{table}
\par
\noindent
and combined as:
\vskip .15in
\par
\noindent
\texttt{01 00 FF FF 02 00 FE FF 03 00 FD FF}
\vskip .15in
\par
\noindent
whose MD5 sum is:
\vskip .15in
\par
\noindent
\texttt{E7482f6462B27EE04EADC079291C79E9}
\vskip .25in
\par
This process is identical to the MD5 sum calculation performed
during FLAC decoding, but performed in the opposite order.

\clearpage

\subsection{Encoding a FLAC Frame}
{\relsize{-1}
\ALGORITHM{up to ``block size'' number of PCM frames, encoding parameters}{a single FLAC frame}
\SetKw{AND}{and}
\SetKw{OR}{or}
\SetKwFunction{MIN}{min}
\SetKwFunction{BUILDSUBFRAME}{build subframe}
\SetKwFunction{CALCMIDSIDE}{calculate mid-side}
\eIf{channels = 2 \AND (try mid-side \OR try adaptive mid-side)}{
  $average$, $difference$ $\leftarrow$ \CALCMIDSIDE($channel_0$, $channel_1$)\;
  left subframe $\leftarrow$ \BUILDSUBFRAME($channel_0$, stream's bits per sample)\;
  right subframe $\leftarrow$ \BUILDSUBFRAME($channel_1$, stream's bits per sample)\;
  average subframe $\leftarrow$ \BUILDSUBFRAME($average$, stream's bits per sample)\;
  difference subframe $\leftarrow$ \BUILDSUBFRAME($difference$, stream's bits per sample + 1)\;
  left bits $\leftarrow$ left subframe length, in bits\;
  right bits $\leftarrow$ right subframe length, in bits\;
  avg bits $\leftarrow$ average subframe length, in bits\;
  diff bits $\leftarrow$ difference subframe length, in bits\;
  \BlankLine
  \uIf{try mid-side}{
    \uIf{left bits + right bits $<$ \MIN(left bits + diff bits, diff bits + right bits, avg bits + diff bits)}{
      write frame header with channel assignment \texttt{0x1}\;
      write left subframe\;
      write right subframe\;
    }
    \uElseIf{left bits $<$ \MIN(right bits, avg bits)}{
      write frame header with channel assignment \texttt{0x8}\;
      write left subframe\;
      write difference subframe\;
    }
    \uElseIf{right bits $<$ avg bits}{
      write frame header with channel assignment \texttt{0x9}\;
      write difference subframe\;
      write right subframe\;
    }
    \Else{
      write frame header with channel assignment \texttt{0xA}\;
      write average subframe\;
      write difference subframe\;
    }
  }\uElseIf{left bits + right bits $<$ avg bits + diff bits}{
    write frame header with channel assignment \texttt{0x1}\;
    write left subframe\;
    write right subframe\;
  }
  \Else{
    write frame header with channel assignment \texttt{0xA}\;
    write average subframe\;
    write difference subframe\;
  }
}(\tcc*[f]{store subframes independently}){
  write frame header with channel assigment $channels - 1$\;
  \ForEach{channel \IN channels}{
    subframe $\leftarrow$ \BUILDSUBFRAME($channel$, stream's bits per sample)\;
    write subframe\;
  }
}
byte align the stream\;
write frame's CRC-16 checksum\;
\EALGORITHM
}
\clearpage

\subsubsection{Calculating Mid-Side}
For each sample in $channel_0$ and $channel_1$:
\begin{align*}
average_i &\leftarrow \left\lfloor\frac{channel_{0~i} + channel_{1~i}}{2}\right\rfloor \\
difference_i &\leftarrow channel_{0~i} - channel_{1~i}
\intertext{For example, given the input samples:}
channel_{0~0} &\leftarrow 10 \\
channel_{1~0} &\leftarrow 15
\intertext{Our average and difference samples are:}
average_0 &\leftarrow \left\lfloor\frac{10 + 15}{2}\right\rfloor = 12 \\
difference_0 &\leftarrow 10 - 15 = -5
\intertext{Note that the $difference$ channel is identical for left-difference,
difference-right and mid-side channel assignments.
For example, when recombined from left-difference\footnotemark:}
sample_0 &\leftarrow 10 \\
sample_1 &\leftarrow 10 - (-5) = 15
\intertext{difference-right:}
sample_0 &\leftarrow -5 + 15 = 10 \\
sample_1 &\leftarrow 15
\intertext{and mid-side:}
sample_0 &\leftarrow \lfloor(((12 \times 2) + (-5 \bmod 2)) + -5) \div 2\rfloor  = \lfloor((24 + 1 - 5) \div 2\rfloor = 10 \\
sample_1 &\leftarrow \lfloor(((12 \times 2) + (-5 \bmod 2)) - -5) \div 2\rfloor =  \lfloor((24 + 1 + 5) \div 2\rfloor = 15
\end{align*}
\footnotetext{See the recombining subframes algorithms on page
\pageref{flac_recombining_subframes}.}

\clearpage

\subsubsection{Writing Frame Header}
\ALGORITHM{the frame's channel assignment, the input stream's parameters}{a FLAC frame header}
\SetKw{OR}{or}
\WRITE \texttt{0x3FFE} in 14 unsigned bits\tcc*[r]{sync code}
\WRITE 0 in 1 unsigned bit\;
\WRITE 0 in 1 unsigned bit\tcc*[r]{blocking strategy}
\WRITE $encoded~block~size$ in 4 unsigned bits\;
\WRITE $encoded~sample~rate$ in 4 unsigned bits\;
\WRITE frame's channel assignment in 4 unsigned bits\;
\WRITE $encoded~bps$ in 3 unsigned bits\;
\WRITE 0 in 1 unsigned bit\;
\WRITE frame number as a UTF-8 encoded value\;
\uIf{encoded block size = 6}{
  \WRITE (block size - 1) in 8 unsigned bits\;
}
\ElseIf{encoded block size = 7}{
  \WRITE (block size - 1) in 16 unsigned bits\;
}
\uIf{encoded sample rate = 12}{
  \WRITE ($\text{sample rate} \div 1000$) in 8 unsigned bits\;
}
\uElseIf{encoded sample rate = 13}{
  \WRITE sample rate in 16 unsigned bits\;
}
\ElseIf{encoded sample rate = 14}{
  \WRITE ($\text{sample rate} \div 10$) in 16 unsigned bits\;
}
\WRITE header CRC8 in 8 unsigned bits\;
\EALGORITHM

\subsubsection{Encoding Block Size}
{\relsize{-1}
\ALGORITHM{block size in samples}{encoded block size as 4 bit value}
\uIf{block size \IN}{
  \begin{tabular}{rr|rr|rr}
    block size & encoded & block size & encoded & block size & encoded \\
    \hline
    192 & 1 &
    1152 & 3 &
    4608 & 5 \\
    256 & 8 &
    2048 & 11 &
    8192 & 13 \\
    512 & 9 &
    2304 & 4 &
    16384 & 14 \\
    576 & 2 &
    4096 & 12 &
    32768 & 15 \\
    1024 & 10 \\
  \end{tabular}
}
\uElseIf{block size $\leq 256$}{
  $encoded~block~size \leftarrow 6$
}
\uElseIf{block size $\leq 65536$}{
  $encoded~block~size \leftarrow 7$
}
\Else{
  $encoded~block~size \leftarrow 0$
}
\EALGORITHM
}

\clearpage

\subsubsection{Encoding Sample Rate}
{\relsize{-1}
\ALGORITHM{sample rate in Hz}{encoded sample rate as 4 bit value}
\SetKw{AND}{and}
\uIf{sample rate \IN}{
  \begin{tabular}{rr|rr|rr}
    sample rate & encoded & sample rate & encoded & sample rate & encoded \\
    \hline
    8000 & 4 &
    32000 & 8 &
    96000 & 11 \\
    16000 & 5 &
    44100 & 9 &
    176400 & 2 \\
    22050 & 6 &
    48000 & 10 &
    192000 & 3 \\
    24000 & 7 &
    88200 & 1 \\
  \end{tabular}
}
\uElseIf{$sample~rate \bmod 1000 = 0$ \AND $sample~rate \leq 255000$}{
  $encoded~sample~rate \leftarrow 12$\;
}
\uElseIf{$sample~rate \bmod 10 = 0$ \AND $sample~rate \leq 655350$}{
  $encoded~sample~rate \leftarrow 14$\;
}
\uElseIf{$sample~rate \leq 65535$}{
  $encoded~sample~rate \leftarrow 13$\;
}
\Else{$encoded~sample~rate = 0$}
\EALGORITHM
}
\subsubsection{Encoding Bits Per Sample}
{\relsize{-1}
\ALGORITHM{bits per sample}{encoded bits per sample as 3 bit value}
\eIf{bits per sample \IN}{
  \begin{tabular}{rr|rr}
    bits per sample & encoded & bits per sample & encoded \\
    \hline
    8 & 1 &
    20 & 5 \\
    12 & 2 &
    24 & 6 \\
    16 & 4 \\
  \end{tabular}
}{
  $encoded~bps \leftarrow 0$\;
}
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{figures/flac/frames.pdf}
\end{figure}

\clearpage

\subsubsection{Encoding UTF-8 Frame Number}
{\relsize{-1}
\ALGORITHM{value as unsigned integer}{1 or more UTF-8 bytes}
\eIf{value $\leq 127$}{
  \WRITE value in 8 unsigned bits\;
}{
  \uIf{value $\leq 2047$}{
    total bytes $\leftarrow 2$\;
  }
  \uElseIf{value $\leq 65535$}{
    total bytes $\leftarrow 3$\;
  }
  \uElseIf{value $\leq 2097151$}{
    total bytes $\leftarrow 4$\;
  }
  \uElseIf{value $\leq 67108863$}{
    total bytes $\leftarrow 5$\;
  }
  \ElseIf{value $\leq 2147483647$}{
    total bytes $\leftarrow 6$\;
  }
  shift $\leftarrow (total~bytes - 1) \times 6$\;
  \WUNARY total bytes with stop bit 1\;
  \WRITE $\lfloor \text{value} \div 2 ^ \text{shift} \rfloor$ in (7 - total bytes) unsigned bits\tcc*[r]{initial value}
  shift $\leftarrow$ shift - 6\;
  \While{$shift \geq 0$}{
    \WRITE 2 in 2 unsigned bits\tcc*[r]{continuation header}
    \WRITE $(\lfloor \text{value} \div 2 ^ \text{shift} \rfloor \bmod 64)$ in 6 unsigned bits\tcc*[r]{continuation bits}
    shift $\leftarrow$ shift - 6\;
  }
}
\EALGORITHM
}
\par
\noindent
For example, encoding the frame number 4228 in UTF-8:
\par
\noindent
\begin{wrapfigure}[10]{r}{2.375in}
\includegraphics{figures/flac/utf8.pdf}
\end{wrapfigure}
\begin{align*}
\text{total bytes} &\leftarrow 3 \\
\text{shift} &\leftarrow 12 \\
& \textbf{write unary } 3 \text{ with stop bit 1} \\
& \textbf{write } 1 \text{ in 4 unsigned bits} \\
\text{shift} &\leftarrow 12 - 6 = 6 \\
& \textbf{write } 2 \text{ in 2 unsigned bits} \\
& \textbf{write } 2 \text{ in 6 unsigned bits} \\
\text{shift} &\leftarrow 6 - 6 = 0 \\
& \textbf{write } 2 \text{ in 2 unsigned bits} \\
& \textbf{write } 4 \text{ in 6 unsigned bits}
\end{align*}

\clearpage

\subsubsection{Calculating CRC-8}
Given a header byte and previous CRC-8 checksum,
or 0 as an initial value:
\begin{equation*}
\text{checksum}_i = \text{CRC8}(byte\xor\text{checksum}_{i - 1})
\end{equation*}
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0x00 & 0x07 & 0x0E & 0x09 & 0x1C & 0x1B & 0x12 & 0x15 & 0x38 & 0x3F & 0x36 & 0x31 & 0x24 & 0x23 & 0x2A & 0x2D \\
0x1? & 0x70 & 0x77 & 0x7E & 0x79 & 0x6C & 0x6B & 0x62 & 0x65 & 0x48 & 0x4F & 0x46 & 0x41 & 0x54 & 0x53 & 0x5A & 0x5D \\
0x2? & 0xE0 & 0xE7 & 0xEE & 0xE9 & 0xFC & 0xFB & 0xF2 & 0xF5 & 0xD8 & 0xDF & 0xD6 & 0xD1 & 0xC4 & 0xC3 & 0xCA & 0xCD \\
0x3? & 0x90 & 0x97 & 0x9E & 0x99 & 0x8C & 0x8B & 0x82 & 0x85 & 0xA8 & 0xAF & 0xA6 & 0xA1 & 0xB4 & 0xB3 & 0xBA & 0xBD \\
0x4? & 0xC7 & 0xC0 & 0xC9 & 0xCE & 0xDB & 0xDC & 0xD5 & 0xD2 & 0xFF & 0xF8 & 0xF1 & 0xF6 & 0xE3 & 0xE4 & 0xED & 0xEA \\
0x5? & 0xB7 & 0xB0 & 0xB9 & 0xBE & 0xAB & 0xAC & 0xA5 & 0xA2 & 0x8F & 0x88 & 0x81 & 0x86 & 0x93 & 0x94 & 0x9D & 0x9A \\
0x6? & 0x27 & 0x20 & 0x29 & 0x2E & 0x3B & 0x3C & 0x35 & 0x32 & 0x1F & 0x18 & 0x11 & 0x16 & 0x03 & 0x04 & 0x0D & 0x0A \\
0x7? & 0x57 & 0x50 & 0x59 & 0x5E & 0x4B & 0x4C & 0x45 & 0x42 & 0x6F & 0x68 & 0x61 & 0x66 & 0x73 & 0x74 & 0x7D & 0x7A \\
0x8? & 0x89 & 0x8E & 0x87 & 0x80 & 0x95 & 0x92 & 0x9B & 0x9C & 0xB1 & 0xB6 & 0xBF & 0xB8 & 0xAD & 0xAA & 0xA3 & 0xA4 \\
0x9? & 0xF9 & 0xFE & 0xF7 & 0xF0 & 0xE5 & 0xE2 & 0xEB & 0xEC & 0xC1 & 0xC6 & 0xCF & 0xC8 & 0xDD & 0xDA & 0xD3 & 0xD4 \\
0xA? & 0x69 & 0x6E & 0x67 & 0x60 & 0x75 & 0x72 & 0x7B & 0x7C & 0x51 & 0x56 & 0x5F & 0x58 & 0x4D & 0x4A & 0x43 & 0x44 \\
0xB? & 0x19 & 0x1E & 0x17 & 0x10 & 0x05 & 0x02 & 0x0B & 0x0C & 0x21 & 0x26 & 0x2F & 0x28 & 0x3D & 0x3A & 0x33 & 0x34 \\
0xC? & 0x4E & 0x49 & 0x40 & 0x47 & 0x52 & 0x55 & 0x5C & 0x5B & 0x76 & 0x71 & 0x78 & 0x7F & 0x6A & 0x6D & 0x64 & 0x63 \\
0xD? & 0x3E & 0x39 & 0x30 & 0x37 & 0x22 & 0x25 & 0x2C & 0x2B & 0x06 & 0x01 & 0x08 & 0x0F & 0x1A & 0x1D & 0x14 & 0x13 \\
0xE? & 0xAE & 0xA9 & 0xA0 & 0xA7 & 0xB2 & 0xB5 & 0xBC & 0xBB & 0x96 & 0x91 & 0x98 & 0x9F & 0x8A & 0x8D & 0x84 & 0x83 \\
0xF? & 0xDE & 0xD9 & 0xD0 & 0xD7 & 0xC2 & 0xC5 & 0xCC & 0xCB & 0xE6 & 0xE1 & 0xE8 & 0xEF & 0xFA & 0xFD & 0xF4 & 0xF3 \\
\hline
\end{tabular}
}
\end{table}

\subsubsection{Frame Header Encoding Example}
Given a frame header with the following attributes:
\begin{table}[h]
\begin{tabular}{rl}
block size : & 4096 PCM frames \\
sample rate : & 44100 Hz \\
channel assignment : & 1 (2 channels stored independently) \\
bits per sample : & 16 \\
frame number : & 0
\end{tabular}
\end{table}
\par
\noindent
we generate the following frame header bytes:
\begin{figure}[h]
\includegraphics{figures/flac/header-example.pdf}
\end{figure}
\par
\noindent
Note how the CRC-8 is calculated from the preceding 5 header bytes:
\begin{align*}
\text{checksum}_0 = \text{CRC8}(\texttt{FF}\xor\texttt{00}) = \texttt{F3} & &
\text{checksum}_3 = \text{CRC8}(\texttt{18}\xor\texttt{E6}) = \texttt{F4} \\
\text{checksum}_1 = \text{CRC8}(\texttt{F8}\xor\texttt{F3}) = \texttt{31} & &
\text{checksum}_4 = \text{CRC8}(\texttt{00}\xor\texttt{F4}) = \texttt{C2} \\
\text{checksum}_2 = \text{CRC8}(\texttt{C9}\xor\texttt{31}) = \texttt{E6} \\
\end{align*}

\clearpage

\subsection{Encoding a FLAC Subframe}
{\relsize{-1}
\ALGORITHM{signed subframe samples, subframe's bits per sample}{a FLAC subframe}
\SetKwFunction{LEN}{len}
\SetKwFunction{MIN}{min}
\eIf{all samples are the same}{
  \Return CONSTANT subframe using $sample_0$\;
}{
  wasted BPS $\leftarrow$ calculate wasted bits per sample\;
  \If{wasted BPS $> 0$}{
    \ForEach{sample \IN subframe samples}{
      sample $\leftarrow \lfloor \text{sample} \div 2 ^ \text{wasted BPS} \rfloor$
    }
    subframes's bits per sample $\leftarrow$ subframe's bits per sample - wasted BPS\;
  }
  \BlankLine
  best FIXED order $\leftarrow$ calculate FIXED subframe order for samples\;
  FIXED subframe data $\leftarrow$ build FIXED subframe with best FIXED order\;
  \BlankLine
  \eIf(\tcc*[f]{from encoding parameters}){maximum LPC order $ > 0$}{
    LPC subframe parameters $\leftarrow$ compute best LPC coefficients\;
    LPC subframe data $\leftarrow$ compute LPC subframe with LPC parameters\;
    \BlankLine
    \uIf{$(\text{bits per sample} \times \text{sample count}) < $ \newline$\MIN(\LEN(\text{LPC subframe data}) , \LEN(\text{FIXED subframe data}))$}{
      \Return VERBATIM subframe using subframe's samples and bits per sample\;
    }
    \uElseIf{$\LEN(\text{FIXED subframe data}) < \LEN(\text{LPC subframe data})$}{
      \Return FIXED subframe data\;
    }
    \Else{
      \Return LPC subframe data\;
    }
  }{
    \eIf{\LEN(FIXED subframe data) $< (\text{bits per sample} \times \text{sample count})$}{
      \Return FIXED subframe data\;
    }{
      \Return VERBATIM subframe using subframe's sample and bits per sample\;
    }
  }
}
\EALGORITHM
\par
\noindent
Note that FIXED and LPC subframes aren't typically written to the stream
outright.
Instead, they're written to temporary spaces.
The size of those spaces are compared to each other, and to a hypothetical
VERBATIM subframe.
The smallest subframe is the one written to disk.
}
\begin{figure}[h]
\includegraphics{figures/flac/subframes.pdf}
\end{figure}

\clearpage

\subsubsection{Calculating Wasted Bits Per Sample}
\ALGORITHM{signed subframe samples}{the amount of wasted bits per sample as an unsigned integer}
\SetKw{AND}{and}
\SetKwFunction{MIN}{min}
wasted BPS $\leftarrow$ maximum unsigned integer\;
\ForEach{sample \IN subframe samples}{
  \If{sample $\neq 0$}{
    wasted $\leftarrow$ 0\;
    \While{sample $\bmod~2 = 0$}{
      wasted $\leftarrow$ wasted + 1\;
      sample $\leftarrow \text{sample} \div 2$\;
    }
    \eIf{wasted $= 0$}{
      \Return 0\tcc*[r]{stop once a sample has no wasted bits}
    }{
      wasted BPS $\leftarrow$ \MIN(wasted BPS, wasted)\;
    }
  }
}
\tcc{if all samples are 0, we should return a CONSTANT subframe}
\Return wasted BPS\;
\EALGORITHM

\subsubsection{Encoding a CONSTANT Subframe}
\ALGORITHM{signed subframe sample, subframe's bits per sample}{a CONSTANT subframe}
\WRITE 0 in 1 unsigned bit\tcc*[r]{pad}
\WRITE 0 in 6 unsigned bits\tcc*[r]{subframe type}
\WRITE 0 in 1 unsigned bit\tcc*[r]{no wasted BPS}
\WRITE sample in (bits per sample) signed bits\;
\Return a CONSTANT subframe\;
\EALGORITHM

\subsubsection{Encoding a VERBATIM Subframe}
\ALGORITHM{signed subframe samples, subframe's bits per sample}{a VERBATIM subframe}
\WRITE 0 in 1 unsigned bit\tcc*[r]{pad}
\WRITE 1 in 6 unsigned bits\tcc*[r]{subframe type}
\WRITE 0 in 1 unsigned bit\tcc*[r]{no wasted BPS}
\ForEach{sample \IN subframe samples}{
  \WRITE sample in (bits per sample) signed bits\;
}
\Return a VERBATIM subframe\;
\EALGORITHM

\clearpage

\subsubsection{Calculating FIXED Subframe Order}
\ALGORITHM{signed subframe samples}{the FIXED subframe order, between 0 and 4}
\SetKwFunction{MIN}{min}
\eIf{sample count $\geq 4$}{
  $\text{last error}_1 \leftarrow \text{sample}_3 - \text{sample}_2$\;
  $\text{last error}_2 \leftarrow \text{last error}_1 - (\text{sample}_2 - \text{sample}_1)$\;
  $\text{last error}_3 \leftarrow \text{last error}_2 - (\text{sample}_2 - (\text{sample}_1 \times 2) + \text{sample}_0)$\;
  \BlankLine
  $\text{total error}_0 \leftarrow 0$\;
  $\text{total error}_1 \leftarrow 0$\;
  $\text{total error}_2 \leftarrow 0$\;
  $\text{total error}_3 \leftarrow 0$\;
  $\text{total error}_4 \leftarrow 0$\;
  \BlankLine
  \For{i = 4 \emph{\KwTo}sample count}{
    $\text{error}_0 \leftarrow \text{sample}_i - \text{sample}_{i - 1}$\;
    $\text{error}_1 \leftarrow \text{error}_0 - \text{last error}_1$\;
    $\text{error}_2 \leftarrow \text{error}_1 - \text{last error}_2$\;
    $\text{error}_3 \leftarrow \text{error}_2 - \text{last error}_3$\;
    \BlankLine
    $\text{total error}_0 \leftarrow \text{total error}_0 + |\text{sample}_i|$\;
    $\text{total error}_1 \leftarrow \text{total error}_1 + |\text{error}_0|$\;
    $\text{total error}_2 \leftarrow \text{total error}_2 + |\text{error}_1|$\;
    $\text{total error}_3 \leftarrow \text{total error}_3 + |\text{error}_2|$\;
    $\text{total error}_4 \leftarrow \text{total error}_4 + |\text{error}_3|$\;
    \BlankLine
    $\text{last error}_1 \leftarrow \text{error}_0$\;
    $\text{last error}_2 \leftarrow \text{error}_1$\;
    $\text{last error}_3 \leftarrow \text{error}_2$\;
  }
  \uIf{$\text{total error}_0 < \MIN(\text{total error}_1 , \text{total error}_2 , \text{total error}_3 , \text{total error}_4)$}{
    \Return 0\;
  }
  \uElseIf{$\text{total error}_1 < \MIN(\text{total error}_2 , \text{total error}_3 , \text{total error}_4)$}{
    \Return 1\;
  }
  \uElseIf{$\text{total error}_2 < \MIN(\text{total error}_3 , \text{total error}_4)$}{
    \Return 2\;
  }
  \uElseIf{$\text{total error}_3 < \text{total error}_4$}{
    \Return 3\;
  }
  \Else{
    \Return 4\;
  }
}{
  \Return 0\;
}
\EALGORITHM

\clearpage

\subsubsection{FIXED Subframe Order Calculation Example}
Given the subframe samples: \texttt{18, 20, 26, 24, 24, 23, 21, 24, 23, 20}:
\begin{align*}
\text{initial last error}_1 &\leftarrow 24 - 26 = -2 \\
\text{initial last error}_2 &\leftarrow -2 - (26 - 20) = -8 \\
\text{initial last error}_3 &\leftarrow -8 - (26 - (20 \times 2) + 18) = -12
\end{align*}

\begin{table}[h]
\begin{tabular}{r|r|r|r}
\hline
\hline
$i$ & 4 & 5 & 6 \\
$\text{sample}_i$ & $24$ & $23$ & $21$ \\
\hline
$\text{error}_0$ & $24 - 24 = 0$ & $23 - 24 = -1$ & $21 - 23 = -2$ \\
$\text{error}_1$ & $0 - -2 = 2$ & $-1 - 0 = -1$ & $-2 - -1 = -1$ \\
$\text{error}_2$ & $2 - -8 = 10$ & $-1 - 2 = -3$ & $-1 - -1 = 0$ \\
$\text{error}_3$ & $6 - -8 = 22$ & $-3 - 10 = -13$ & $0 - -3 = 3$ \\
\hline
$\text{total error}_0$ & $0 + |24| = 24$ & $24 + |23| = 47$ & $47 + |21| = 68$ \\
$\text{total error}_1$ & $0 + 0 = 0$ & $0 + |-1| = 1$ & $1 + |-2| = 3$ \\
$\text{total error}_2$ & $0 + 2 = 2$ & $2 + |-1| = 3$ & $3 + |-1| = 4$ \\
$\text{total error}_3$ & $0 + 10 = 10$ & $10 + |-3| = 13$ & $13 + |0| = 13$ \\
$\text{total error}_4$ & $0 + 22 = 22$ & $22 + |-13| = 35$ & $35 + |3| = 38$ \\
\hline
$\text{last error}_1$ & $0$ & $-1$ & $-2$ \\
$\text{last error}_2$ & $2$ & $-1$ & $-1$ \\
$\text{last error}_3$ & $10$ & $-3$ & $0$ \\
\hline
\hline
$i$ & 7 & 8 & 9 \\
$\text{sample}_i$ & $24$ & $23$ & $20$ \\
\hline
$\text{error}_0$ & $24 - 21 = 3$ & $23 - 24 = -1$ & $20 - 23 = -3$ \\
$\text{error}_1$ & $3 - -2 = 5$ & $-1 - 3 = -4$ & $-3 - -1 = -2$ \\
$\text{error}_2$ & $5 - -1 = 6$ & $-4 - 5 = -9$ & $-2 - -4 = 2$ \\
$\text{error}_3$ & $6 - 0 = 6$ & $-9 - 6 = -15$ & $2 - -9 = 11$ \\
\hline
$\text{total error}_0$ & $68 + |24| = 92$ & $92 + |23| = 115$ & $115 + |20| = 135$ \\
$\text{total error}_1$ & $3 + |3| = 6$ & $6 + |-1| = 7$ & $7 + |-3| = 10$ \\
$\text{total error}_2$ & $4 + |5| = 9$ & $9 + |-4| = 13$ & $13 + |-2| = 15$ \\
$\text{total error}_3$ & $13 + |6| = 19$ & $19 + |-9| = 28$ & $28 + |2| = 30$ \\
$\text{total error}_4$ & $38 + |6| = 44$ & $44 + |15| = 59$ & $59 + |11| = 70$ \\
\hline
$\text{last error}_1$ & $3$ & $-1$ & $-3$ \\
$\text{last error}_2$ & $5$ & $-4$ & $-2$ \\
$\text{last error}_3$ & $6$ & $-9$ & $2$ \\
\hline
\hline
\end{tabular}
\end{table}
\par
\noindent
Since $\text{total error}_1$'s value of 10 is the smallest of the five
total error values,
the best FIXED predictor order for these samples is 1.

\clearpage

\subsubsection{Encoding a FIXED Subframe}
\ALGORITHM{signed subframe samples, subframe order, subframe's bits per sample, wasted BPS}{a FIXED subframe}
\WRITE 0 in 1 unsigned bit\tcc*[r]{pad}
\WRITE 1 in 3 unsigned bits\tcc*[r]{subframe type}
\WRITE subframe order in 3 unsigned bits\;
\eIf{$wasted~BPS > 0$}{
  \WRITE 1 in 1 unsigned bit\;
  \WUNARY (wasted BPS - 1) with stop bit 1\;
}{
  \WRITE 0 in 1 unsigned bit\;
}
\For(\tcc*[f]{warm-up samples}){i = 0 \emph{\KwTo}subframe order}{
  \WRITE $sample_i$ in (bits per sample) signed bits\;
}
calculate FIXED subframe's residuals based on signed samples and subframe order\;
write encoded residual block based on signed residual values\;
\Return a FIXED subframe\;
\EALGORITHM

\begin{figure}[h]
\includegraphics{figures/flac/fixed2.pdf}
\end{figure}
\par
\noindent
Building a residual block from signed residual values is explained
on page \pageref{flac_residual_encoding}.

\clearpage

\subsubsection{Calculating FIXED Subframe Residuals}
\ALGORITHM{signed subframe samples, subframe order}{signed residual values}
\Switch{subframe order}{
  \uCase{0}{
    \For{i = 0 \emph{\KwTo}sample count}{
      $residual_i \leftarrow sample_i$\;
    }
  }
  \uCase{1}{
    \For{i = 0 \emph{\KwTo}sample count - 1}{
      $residual_i \leftarrow sample_{i + 1} - sample_i$
    }
  }
  \uCase{2}{
    \For{i = 0 \emph{\KwTo}sample count - 2}{
      $residual_i \leftarrow sample_{i + 2} - ((2 \times sample_{i + 1}) - sample_i)$
    }
  }
  \uCase{3}{
    \For{i = 3 \emph{\KwTo}sample count}{
      $residual_i \leftarrow sample_{i + 3} - ((3 \times sample_{i + 2}) - (3 \times sample_{i + 1}) + sample_i)$
    }
  }
  \Case{4}{
    \For{i = 4 \emph{\KwTo}sample count}{
      $residual_i \leftarrow sample_{i + 4} - ((4 \times sample_{i + 3}) - (6 \times sample_{i + 2}) + (4 \times sample_{i + 1}) - sample_i)$
    }
  }
}
\EALGORITHM

\subsubsection{FIXED Subframe Residual Calculation Example}

Given the subframe samples: \texttt{18, 20, 26, 24, 24, 23, 21, 24, 23, 20}:
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{r|r|r|r|r|r}
& order 0 & order 1 & order 2 & order 3 & order 4 \\
\hline
$residual_0$ & 18 & 2 & 4 & -12 & 22 \\
$residual_1$ & 20 & 6 & -8 & 10 & -13 \\
$residual_2$ & 26 & -2 & 2 & -3 & 3 \\
$residual_3$ & 24 & 0 & -1 & 0 & 6 \\
$residual_4$ & 24 & -1 & -1 & 6 & -15 \\
$residual_5$ & 23 & -2 & 5 & -9 & 11 \\
$residual_6$ & 21 & 3 & -4 & 2 \\
$residual_7$ & 24 & -1 & -2 \\
$residual_8$ & 23 & -3 \\
$residual_9$ & 20 \\
\hline
total error & 135 & 10 & 15 & 30 & 70 \\
\end{tabular}
}
\end{table}
\par
\noindent
Note how the total number of residuals equals the
total number of samples minus the subframe's order,
to account for the warm-up samples.
Also note that if you remove the first $4 - order$ residuals
and sum the absolute value of the remainding residuals,
the result is the \VAR{total error} value
used when calculating the best FIXED subframe order.

\subsection{Residual Encoding}
\label{flac_residual_encoding}
{\relsize{-1}
\ALGORITHM{a set of signed residual values, the subframe's block size and order, minimum and maximum partition order from encoding parameters}{an encoded block of residuals}
\SetKwData{PORDER}{porder}
\SetKwData{BPORDER}{best porder}
\SetKwData{BSIZE}{best size}
\SetKwData{PARTITION}{partition}
\SetKwFunction{LEN}{len}
\tcc{calculate best Rice parameters, partition order and coding method}
\BPORDER $\leftarrow 0$\;
\BSIZE $\leftarrow$ maximum integer\;
\For{\PORDER = minimum partition order \emph{\KwTo}(maximum partition order + 1)}{
  \If{block size equally divisible into $2^{\PORDER}$ partitions}{
    $\text{partition size}_{\PORDER} \leftarrow 0$\;
    \For{p = 0 \emph{\KwTo}$2 ^ {\PORDER}$} {
      $\text{partition size}_{\PORDER} \leftarrow \text{partition size}_{\PORDER} + 4$\tcc*[r]{partition header bits}
      \eIf{p = 0}{
        $partition_{\PORDER~0} \leftarrow block~size \div 2 ^ {\PORDER} - subframe~order$ residuals
      }{
        $partition_{\PORDER~p} \leftarrow block~size \div 2 ^ {\PORDER}$ residuals
      }
      \BlankLine
      $Rice_{\PORDER~p} \leftarrow$ compute best Rice parameter for $partition_{\PORDER~p}$\;
      \BlankLine
      $encoded~residuals_{\PORDER~p} \leftarrow$ encode residual partition with $Rice_{\PORDER~p}$\;
      \BlankLine
      $\text{partition size}_{\PORDER} \leftarrow \text{partition size}_{\PORDER} + \LEN(encoded~residuals_{\PORDER~p})$\;
    }
    \If{$\text{partition size}_{\PORDER} < \BSIZE$}{
      \BPORDER $\leftarrow$ \PORDER\;
      \BSIZE $\leftarrow \text{partition size}_{\PORDER}$\;
    }
  }
}
\BlankLine
\tcc{write best residual partition(s) to residual block}
\eIf{any $Rice_{\BPORDER} > 14$}{
  coding method $\leftarrow 1$\;
}{
  coding method $\leftarrow 0$\;
}
\WRITE coding method in 2 unsigned bits\;
\WRITE \BPORDER in 4 unsigned bits\;
\For{p = 0 \emph{\KwTo}$2 ^ {\BPORDER}$} {
  \eIf{coding method = 0}{
    \WRITE $Rice_{\BPORDER~p}$ in 4 unsigned bits\;
  }{
    \WRITE $Rice_{\BPORDER~p}$ in 5 unsigned bits\;
  }
  write $encoded~residuals_{\PORDER~p}$\;
}
\Return encoded residual block\;
\EALGORITHM
}

\clearpage

\subsubsection{Computing Best Rice Parameter}
\ALGORITHM{a set of signed residual values, the stream's bits per sample}{the Rice parameter as an unsigned integer}
\SetKwData{PARAMETER}{Rice parameter}
\SetKwData{PSUM}{partition sum}
\SetKwFunction{MIN}{min}
\PSUM $\leftarrow \overset{partition~size - 1}{\underset{i = 0}{\sum}} |residual_i|$\;
$\PARAMETER \leftarrow 0$\;
\While{$partition~size \times 2 ^ \text{\PARAMETER} < \PSUM$}{
  $\PARAMETER \leftarrow \PARAMETER + 1$\;
}
\eIf{bits per sample $\leq 16$}{
  \Return \MIN(\PARAMETER , 14)\tcc*[r]{coding method 0}
}{
  \Return \MIN(\PARAMETER , 30)\tcc*[r]{coding method 1}
}
\Return \PARAMETER\;
\EALGORITHM

\subsubsection{Encoding Residual Partition}
\ALGORITHM{a set of signed residual values, the partition's Rice parameter}{an encoded residual partition}
\ForEach{residual \emph{\KwTo}residuals}{
  \eIf{$residual \geq 0$}{
    $unsigned \leftarrow residual \times 2$\;
  }{
    $unsigned \leftarrow ((-residual - 1) \times 2) + 1$\;
  }
  MSB $\leftarrow \lfloor unsigned \div 2 ^ \text{Rice parameter} \rfloor$\;
  LSB $\leftarrow unsigned - (\text{MSB} \times 2 ^ \text{Rice parameter})$\;
  \WUNARY MSB with stop bit 1\;
  \WRITE LSB in (Rice parameter) unsigned bits\;
}
\Return encoded partition\;
\EALGORITHM

\begin{figure}[h]
\includegraphics{figures/flac/residual.pdf}
\end{figure}

\clearpage

\subsubsection{Residual Encoding Example}
Given a block size of 10 and the residuals \texttt{2, 6, -2, 0, -1, -2, 3, -1, -3}:
\begin{align*}
\intertext{for $\text{partition order (porder)} = 0$:}
partition_{0~0} &\leftarrow \texttt{[2, 6, -2, 0, -1, -2, 3, -1, -3]} \\
\text{partition sum}_{0~0} &\leftarrow 2 + 6 + 2 + 0 + 1 + 2 + 3 + 1 + 3 = 20 \\
Rice_{0~0} &\leftarrow 1~~(9 \times 2 ^ 0 < 20~,~9 \times 2 ^ 1 < 20~,~9 \times 2 ^ 2 > 20) \\
\intertext{which is encoded to $encoded~residuals_{0~0}$:
\newline
\includegraphics{figures/flac/residual-example1.pdf}}
\intertext{for partition order (porder) = 1:}
partition_{1~0} &\leftarrow \texttt{[2, 6, -2, 0]} \\
\text{partition sum}_{1~0} &\leftarrow 2 + 6 + 2 + 0 = 10 \\
Rice_{1~0} &\leftarrow 1~~(4 \times 2 ^ 0 < 10~,~4 \times 2 ^ 1 < 10~,~4 \times 2 ^ 2 > 10) \\
\intertext{which is encoded to $encoded~residuals_{1~0}$:
\newline
\includegraphics{figures/flac/residual-example2.pdf}}
partition_{1~1} &\leftarrow \texttt{[-1, -2, 3, -1, -3]} \\
\text{partition sum}_{1~1} &\leftarrow 1 + 2 + 3 + 1 + 3 = 10 \\
Rice_{1~1} &\leftarrow 1~~(4 \times 2 ^ 0 < 10~,~4 \times 2 ^ 1 < 10~,~4 \times 2 ^ 2 > 10) \\
\intertext{which is encoded to $encoded~residuals_{1~1}$:
\newline
\includegraphics{figures/flac/residual-example3.pdf}}
\end{align*}
\par
\noindent
Since partition order 0's 33 bits, + 4 bits for one partition header,
is smaller than partition order 1's 17 bits + 16 bits + 8 bits
for two partition headers, the ideal partition order for these residuals is 0.

\clearpage

The 33 bit partition is packaged into a complete residual block
in which:
\newline
\begin{tabular}{rl}
$partition_{0~0}$ & $\leftarrow$ \texttt{2, 6, -2, 0, -1, -2, 3, -1, -3} \\
$Rice_{0~0}$ & $\leftarrow 1$ \\
partition order & $\leftarrow 0$ \\
coding method & $\leftarrow 0$ \\
\end{tabular}
\begin{figure}[h]
\includegraphics{figures/flac/residual-example4.pdf}
\end{figure}
\par
Finally, we package these residuals into a FIXED subframe in which:
\newline
\begin{tabular}{rl}
predictor order & $\leftarrow 1$ \\
$\text{warm-up sample}_0$ & $\leftarrow $ 18 \\
\end{tabular}
\begin{figure}[h]
\includegraphics{figures/flac/residual-example5.pdf}
\end{figure}
\par
\noindent
Reducing our 10, 16-bit samples from a total of 160 bits
down to only 67 bits - or about 40\% of their original size.

%% \clearpage



%% \subsubsection{Encoding Residual Partition}


%% \section{FLAC Encoding}
%% For the purposes of discussing FLAC encoding,
%% we'll assume one has a stream of input PCM values along with the
%% stream's sample rate, number of channels and bits per sample.
%% Creating a valid FLAC file is then a matter of writing the proper
%% file header, metadata blocks and FLAC frames.
%% \begin{figure}[h]
%% \includegraphics{figures/flac/stream2.pdf}
%% \end{figure}

%% \begin{figure}[h]
%% \begin{tabular}{|r|l|}
%% \hline
%% bits & value \\
%% \hline
%% 1 & 0 if additional metadata blocks follow, 1 if not \\
%% 7 & 0 for STREAMINFO, 1 for PADDING, 4 for VORBIS\_COMMENT, etc. \\
%% 24 & the length of the block data in bytes, not including the header \\
%% \hline
%% \end{tabular}
%% \caption{Metadata Header}
%% \end{figure}

%% \subsection{the STREAMINFO Metadata Block}
%% \begin{figure}[h]
%% \begin{tabular}{|r|l|}
%% \hline
%% bits & value \\
%% \hline
%% 16 & the minimum FLAC frame size, in PCM frames \\
%% 16 & the maximum FLAC frame size, in PCM frames \\
%% 24 & the minimum FLAC frame size, in bytes \\
%% 24 & the maximum FLAC frame size, in bytes \\
%% 20 & the stream's sample rate, in Hz \\
%% 3 & the stream's channel count, minus one \\
%% 5 & the stream's bit-per-sample, minus one \\
%% 36 & the stream's total number of PCM frames \\
%% 128 & an MD5 sum of the PCM stream's bytes \\
%% \hline
%% \end{tabular}
%% \end{figure}
%% \par
%% \noindent
%% This metadata block must come first and is the only required block
%% in a FLAC file.

%% When encoding a FLAC file, many of these fields cannot be known in advance.
%% Instead, one must keep track of those values during encoding and then
%% rewrite the STREAMINFO block when finished.

%% \subsection{the Frame Header}
%% \begin{table}[h]
%% \begin{tabular}{|r|l|}
%% \hline
%% bits & value \\
%% \hline
%% 14 & \texttt{0x3FFE} sync code \\
%% 1 & \texttt{0} reserved \\
%% 1 & \texttt{0} if the header encodes the frame number, \texttt{1} if it encodes the sample number \\
%% 4 & this frame's block size, as encoded PCM frames \\
%% 4 & this frame's encoded sample rate \\
%% 4 & this frame's encoded channel assignment \\
%% 3 & this frame's encoded bits per sample \\
%% 1 & \texttt{0} padding \\
%% 8-56 & the frame number, or sample number, UTF-8 encoded and starting from 0 \\
%% 0/8/16 & the number of PCM frames (minus one) in this FLAC frame \\
%% & if block size is \texttt{0x6} (8 bits) or \texttt{0x7} (16 bits) \\
%% 0/8/16 & the sample rate of this FLAC frame \\
%% & if sample rate is \texttt{0xC} (8 bits), \texttt{0xD} (16 bits) or \texttt{0xE} (16 bits) \\
%% 8 & the CRC-8 of all data from the beginning of the frame header \\
%% \hline
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% The FLAC frame's block size in PCM frames
%% (called ``channel independent samples'' in FLAC's documentation)
%% is typically encoded in the 4 bit `block size' field.
%% But for odd-sized frames - which often occur at the end of the stream -
%% that value is stored as an 8 or 16 bit integer following the UTF-8 encoded
%% frame number.

%% In addition, odd sample rate values are stored as 8 bit (in kHz),
%% 16 bit (in Hz) or 16 bit (in 10s of Hz) prior to the CRC-8,
%% should a predefined value not be available.

%% Up until this point, nearly all of these fields can be filled from
%% the PCM stream data.
%% Unless you're writing a variable block size encoder,
%% one should encode the frame number starting from 0 in the frame header
%% and choose a predefined block size for as many FLAC frames as possible.

%% \clearpage

%% \subsection{UTF-8 Frame Number}
%% \begin{wrapfigure}[10]{r}{3in}
%% \includegraphics{figures/flac/write_utf8.pdf}
%% \end{wrapfigure}

%% A FLAC file's frame number starts at 0 and increments by one
%% for each encoded frame.
%% It is stored in the frame header as a UTF-8 encoded value,
%% which uses a variable number of bytes as the number increases.
%% \vskip .25in
%% \par
%% \noindent
%% {\relsize{-1}
%% \begin{tabular}{|c|r|}
%% \hline
%% Frame Number & Total Bytes \\
%% \hline
%% $0 \leq f \leq 127$ & 1 \\
%% $127 < f \leq 2047$ & 2 \\
%% $2047 < f \leq 65535$ & 3 \\
%% $65535 < f \leq 2097151$ & 4 \\
%% $2097151 < f \leq 67108863$ & 5 \\
%% $67108863 < f \leq 2147483647$ & 6 \\
%% \hline
%% \end{tabular}
%% }
%% \vskip .25in
%% \par
%% As the inverse of decoding, this splits the value into
%% multiple 6 bit fields (each prefixed by a unary 1 value)
%% and indicates the total number of bytes as a unary value.

%% \clearpage

%% \subsection{Channel Assignment}

%% If the input stream has a number of channels other than 2,
%% one has no choice but to store them independently.
%% If the number of channels equals 2, one can try all four possible
%% assignments and use the one which takes the least amount of space.

%% \begin{align*}
%% \intertext{Left-Difference (assignment \texttt{0x8}):}
%% \text{Subframe}_{0~i} &= \text{Left}_i \\
%% \text{Subframe}_{1~i} &= \text{Left}_i - \text{Right}_i \\
%% \intertext{Difference-Right (assignment \texttt{0x9}):}
%% \text{Subframe}_{0~i} &= \text{Left}_i - \text{Right}_i \\
%% \text{Subframe}_{1~i} &= \text{Right}_i \\
%% \intertext{Mid-Side (assignment \texttt{0xA}):}
%% \text{Subframe}_{0~i} &= \lfloor (\text{Left}_i + \text{Right}_i) \div 2 \rfloor \\
%% \text{Subframe}_{1~i} &= \text{Left}_i - \text{Right}_i \\
%% \end{align*}
%% \par
%% \noindent
%% Remember that the difference and side channels are treated as having
%% 1 additional bit during encoding.
%% Thus, a 16 bit frame would have a 17 bit difference subframe
%% when calculating warm-up samples.

%% \subsection{the Subframe Header}
%% \begin{tabular}{|r|l|}
%% \hline
%% bits & value \\
%% \hline
%% 1 & \texttt{0} padding \\
%% \texttt{000000} & \texttt{SUBFRAME\_CONSTANT} \\
%% \texttt{000001} & \texttt{SUBFRAME\_VERBATIM} \\
%% \texttt{001xxx} & \texttt{SUBFRAME\_FIXED} (\texttt{xxx} = Predictor Order) \\
%% \texttt{1xxxxx} & \texttt{SUBFRAME\_LPC} (\texttt{xxxxx} = Predictor Order - 1) \\
%% 1 & \texttt{0} if no wasted bits per sample, \texttt{1} if a unary-encoded number follows \\
%% 0+ & the number of wasted bits per sample (minus one) encoded as unary \\
%% \hline
%% \end{tabular}

%% \subsection{the CONSTANT Subframe}

%% If all the samples in a subframe are identical, one can encode them
%% using a \texttt{CONSTANT} subframe.

%% \subsection{the VERBATIM Subframe}

%% This subframe simply stores all the samples as-is,
%% with no compression whatsoever.

%% \subsection{the FIXED Subframe}

%% This subframe consists of \VAR{predictor order} number of unencoded
%% warm-up samples followed by a residual.
%% Determining which predictor order to use on a given set of input samples
%% depends on their minimum delta sum.
%% This process is best explained by example:


%% \par
%% \noindent
%% Note that the numbers in italics play a part in the delta
%% calculation to their right, but do \textbf{not} figure into the
%% delta's absolute value sum, below.

%% In this example, $\Delta ^ 1$'s value of 26 is the smallest.
%% Therefore, when compressing this set of samples in a FIXED subframe,
%% it's best to use a predictor order of 1.

%% The predictor order indicates how many warm-up samples to take from
%% the PCM stream.
%% Determining the residual values can then be done automatically
%% based on the current $\text{Sample}_i$ and previously encoded samples, or
%% warm-up samples.

%% \clearpage

%% The residual encoding process is then the simple inverse of the
%% decoding process, as follows:

%% \begin{align*}
%% \intertext{For Order 0:}
%% \RESIDUAL_i &= \SAMPLE_i \\
%% & \text{ for } i = 0 \text{ to Block Size} - 1 \\
%% \intertext{For Order 1:}
%% \WARMUP_0 &= \SAMPLE_0 \\
%% \RESIDUAL_i &= \SAMPLE_{i + 1} - \SAMPLE_i \\
%% & \text{ for } i = 0 \text{ to Block Size} - 2 \\
%% \intertext{For Order 2:}
%% \WARMUP_j &= \SAMPLE_j \\
%% & \text{ for } j = 0 \text{ to } 1 \\
%% \RESIDUAL_i &= \SAMPLE_{i + 2} - ((2 \times \SAMPLE_{i + 1}) - \SAMPLE_i) \\
%% & \text{ for } i = 0 \text{ to Block Size} - 3 \\
%% \intertext{For Order 3:}
%% \WARMUP_j &= \SAMPLE_j \\
%% & \text{ for } j = 0 \text{ to } 2 \\
%% \RESIDUAL_i &= \SAMPLE_{i + 3} - ((3 \times \SAMPLE_{i + 2}) - (3 \times \SAMPLE_{i + 1}) + \SAMPLE_i) \\
%% & \text{ for } i = 0 \text{ to Block Size} - 4 \\
%% \intertext{For Order 4:}
%% \WARMUP_j &= \SAMPLE_j \\
%% & \text{ for } j = 0 \text{ to } 3 \\
%% \RESIDUAL_i &= \SAMPLE_{i + 4} - ((4 \times \SAMPLE_{i + 3}) - (6 \times \SAMPLE_{i + 2}) + (4 \times \SAMPLE_{i + 1}) - \SAMPLE_i) \\
%% & \text{ for } i = 0 \text{ to Block Size} - 5 \\
%% \end{align*}

%% \clearpage

%% So to complete our FIXED subframe encoding example in which the
%% predictor order is 1:

%% \begin{align*}
%% \WARMUP_0 &= \SAMPLE_0 = \textbf{-40} \\
%% \RESIDUAL_0 &= \SAMPLE_1 - \SAMPLE_0 = -41 - -40 = \textbf{-1} \\
%% \RESIDUAL_1 &= \SAMPLE_2 - \SAMPLE_1 = -40 - -41 = \textbf{1} \\
%% \RESIDUAL_2 &= \SAMPLE_3 - \SAMPLE_2 = -39 - -40 = \textbf{1} \\
%% \RESIDUAL_3 &= \SAMPLE_4 - \SAMPLE_3 = -38 - -39 = \textbf{1} \\
%% \RESIDUAL_4 &= \SAMPLE_5 - \SAMPLE_4 = -38 - -38 = \textbf{0} \\
%% \RESIDUAL_5 &= \SAMPLE_6 - \SAMPLE_5 = -35 - -38 = \textbf{3} \\
%% \RESIDUAL_6 &= \SAMPLE_7 - \SAMPLE_6 = -35 - -35 = \textbf{0} \\
%% \RESIDUAL_7 &= \SAMPLE_8 - \SAMPLE_7 = -39 - -35 = \textbf{-4} \\
%% \RESIDUAL_8 &= \SAMPLE_9 - \SAMPLE_8 = -40 - -39 = \textbf{-1} \\
%% \RESIDUAL_9 &= \SAMPLE_{10} - \SAMPLE_9 = -40 - -40 = \textbf{0} \\
%% \RESIDUAL_{10} &= \SAMPLE_{11} - \SAMPLE_{10} = -39 - -40 = \textbf{1} \\
%% \RESIDUAL_{11} &= \SAMPLE_{12} - \SAMPLE_{11} = -38 - -39 = \textbf{1} \\
%% \RESIDUAL_{12} &= \SAMPLE_{13} - \SAMPLE_{12} = -37 - -38 = \textbf{1} \\
%% \RESIDUAL_{13} &= \SAMPLE_{14} - \SAMPLE_{13} = -33 - -37 = \textbf{4} \\
%% \RESIDUAL_{14} &= \SAMPLE_{15} - \SAMPLE_{14} = -36 - -33 = \textbf{-3} \\
%% \RESIDUAL_{15} &= \SAMPLE_{16} - \SAMPLE_{15} = -35 - -36 = \textbf{1} \\
%% \RESIDUAL_{16} &= \SAMPLE_{17} - \SAMPLE_{16} = -31 - -35 = \textbf{4} \\
%% \RESIDUAL_{17} &= \SAMPLE_{18} - \SAMPLE_{17} = -32 - -31 = \textbf{-1} \\
%% \RESIDUAL_{18} &= \SAMPLE_{19} - \SAMPLE_{18} = -33 - -32 = \textbf{-1} \\
%% \end{align*}

%% \clearpage

%% \subsection{the LPC Subframe}
%% \label{_encoding}
%% Unlike the FIXED subframe which required only input samples and a
%% predictor order, LPC subframes also require a list of QLP coefficients,
%% a QLP precision value of those coefficients, and a QLP shift needed
%% value.

%% \begin{figure}[h]
%% \includegraphics{figures/flac/lpc.pdf}
%% \end{figure}
%% \par
%% \noindent
%% Determining these values for a given input PCM signal is a somewhat
%% complicated process which depends on whether one is performing an
%% exhaustive LP coefficient order search or not:

%% \begin{figure}[h]
%% \subfloat[non-exhaustive search]{
%% \includegraphics{figures/flac/nonexhaustive.pdf}
%% }
%% \qquad
%% \subfloat[exhaustive search]{
%% \includegraphics{figures/flac/exhaustive.pdf}
%% }
%% \end{figure}

%% \pagebreak

%% \subsubsection{Windowing}

%% The first step in LPC subframe encoding is `windowing' the input signal.
%% Put simply, this is a process of multiplying each input sample by
%% an equivalent value from the window, which are floats from 0.0 to 1.0.
%% In this case, the default is a Tukey window with a ratio of 0.5.
%% A Tukey window is a combination of the Hann and Rectangular windows.
%% The ratio of 0.5 means there's 0.5 samples in the Hann window per
%% sample in the Rectangular window.

%% \begin{align}
%% \text{hann}(n) &= \frac{1}{2} \left ( 1 - \cos \left ( \frac{2 \pi n}{\text{sample count} - 1} \right ) \right ) \\
%% \text{rectangle}(n) &= 1.0
%% \end{align}

%% The Tukey window is defined by taking a Hann window, splitting it at
%% the halfway point, and inserting a Rectangular window between the
%% two.

%% \begin{figure}[h]
%% \subfloat{
%% \includegraphics{figures/flac/hann.pdf}
%% }
%% \subfloat{
%% \includegraphics{figures/flac/rectangular.pdf}
%% }
%% \subfloat{
%% \includegraphics{figures/flac/tukey.pdf}
%% }
%% \end{figure}

%% Let's run through a short example with 20 samples:

%% {\relsize{-1}
%% \begin{tabular}{|r|r >{$}c<{$} r >{$}c<{$} r|}
%% \hline
%% & input & & Tukey & & windowed \\
%% index & sample & & window & & signal \\
%% \hline
%% 0 & -40 & \times & 0.0000 & = & 0.00 \\
%% 1 & -41 & \times & 0.1464 & = & -6.00 \\
%% 2 & -40 & \times & 0.5000 & = & -20.00 \\
%% 3 & -39 & \times & 0.8536 & = & -33.29 \\
%% 4 & -38 & \times & 1.0000 & = & -38.00 \\
%% 5 & -38 & \times & 1.0000 & = & -38.00 \\
%% 6 & -35 & \times & 1.0000 & = & -35.00 \\
%% 7 & -35 & \times & 1.0000 & = & -35.00 \\
%% 8 & -39 & \times & 1.0000 & = & -39.00 \\
%% 9 & -40 & \times & 1.0000 & = & -40.00 \\
%% 10 & -40 & \times & 1.0000 & = & -40.00 \\
%% 11 & -39 & \times & 1.0000 & = & -39.00 \\
%% 12 & -38 & \times & 1.0000 & = & -38.00 \\
%% 13 & -37 & \times & 1.0000 & = & -37.00 \\
%% 14 & -33 & \times & 1.0000 & = & -33.00 \\
%% 15 & -36 & \times & 1.0000 & = & -36.00 \\
%% 16 & -35 & \times & 0.8536 & = & -29.88 \\
%% 17 & -31 & \times & 0.5000 & = & -15.50 \\
%% 18 & -32 & \times & 0.1464 & = & -4.68 \\
%% 19 & -33 & \times & 0.0000 & = & 0.00 \\
%% \hline
%% \end{tabular}
%% }

%% \pagebreak

%% \subsubsection{Computing Autocorrelation}

%% Once our input samples have been converted to a windowed signal,
%% we then compute the autocorrelation values from that signal.
%% Each autocorrelation value is determined by multiplying the signal's
%% samples by the samples of a lagged version of that same signal,
%% and then taking the sum.
%% The lagged signal is simply the original signal with \VAR{lag} number of
%% samples removed from the beginning.

%% \begin{figure}[h]
%% \includegraphics{figures/flac/lag.pdf}
%% \end{figure}

%% The lagged sums from 0 to the maximum LPC order are our autocorrelation
%% values.  In this example, they are 14979.0, 13651.0 and 12405.0.

%% \subsubsection{LP Coefficient Calculation}

%% Calculating the LP coefficients uses the Levinson-Durbin recursive method.\footnote{This algorithm is taken from \LINK{http://www.engineer.tamuk.edu/SPark/chap7.pdf} }
%% Our inputs are $M$, the maximum LPC order minus 1, and $r$ autocorrelation
%% values, from $r(0)$ to $r(M - 1)$.
%% Our outputs are $a$, a list of LP coefficient lists from
%% $a_{11}$ to $a_{(M - 1)(M - 1)}$, and $E$, a list
%% of error values from $E_0$ to $E_{(M - 1)}$.
%% $q_m$ and $\kappa_m$ are temporary values.
%% \par
%% \noindent
%% Initial values:
%% \begin{align}
%% E_0 &= r(0) \\
%% a_{11} &= \kappa_1 = \frac{r(1)}{E_0} \\
%% E_1 &= E_0 {(1 - {{\kappa_1} ^ 2})}
%% \end{align}
%% \noindent
%% With $m \geq 2$, the following recursive algorithm is performed:
%% \begin{align}
%% \text{Step 1. } && q_m &= r(m) - \overset{m - 1}{\underset{i = 1}{\sum}} a_{i(m - 1)}r(m - i) \\
%% \text{Step 2. } && \kappa_m &= \frac{q_m}{E_{(m - 1)}} \\
%% \text{Step 3. } && a_{mm} &= \kappa_m \\
%% \text{Step 4. } && a_{im} &= a_{i(m - 1)} - \kappa_m a_{(m - i)(m - 1)} \text{ for $i = 1$, $i = 2$,...,$i = m - 1$} \\
%% \text{Step 5. } && E_m &= E_{m - 1}(1 - {\kappa_m} ^ 2) \\
%% \text{Step 6. } &&& \text{If $m < M$ then $m \leftarrow m + 1$ and goto step 1.  If $m = M$ then stop.}
%% \end{align}

%% Let's run through an example in which $M = 4$, $r(0) = 11018$, $r(1) = 9690$,
%% $r(2) = 8443$ and $r(3) = 7280$:
%% {\relsize{-2}
%% \begin{align*}
%% E_0 &= r(0) = 11018 \\
%% a_{11} &= \kappa_1 = \frac{r(1)}{E_0} = \frac{9690}{11018} = 0.8795 \\
%% E_1 &= E_o(1 - {\kappa_1} ^ 2) = 11018(1 - 0.8795 ^ 2) = 2495 \\
%% q_2 &= r(2) - \overset{1}{\underset{i = 1}{\sum}} a_{i1}r(2 - i) = 8443 - (0.8795)(9690) = -79.35 \\
%% \kappa_2 &= \frac{q_2}{E_1} = \frac{-79.35}{2495} = -0.0318 \\
%% a_{22} &= \kappa_2 = -0.0318 \\
%% a_{12} &= a_{11} - \kappa_2 a_{11} = 0.8795 - (-0.0318)(0.8795) = 0.9074 \\
%% E_2 &= E_1 (1 - {\kappa_2} ^ 2 ) = 2495(1 - {-0.0318 ^ 2}) = 2492 \\
%% q_3 &= r(3) - \overset{2}{\underset{i = 1}{\sum}} a_{i2} r(3 - i) = 7280 - ((0.9074)(8443) + (-0.0318)(9690)) = -73.04 \\
%% \kappa_3 &= \frac{q_3}{E_2} = \frac{-73.04}{2492} = -0.0293 \\
%% a_{33} &= \kappa_3 = -0.0293 \\
%% a_{13} &= a_{12} - \kappa_3 a_{22} = 0.9074 - (-0.0293)(-0.0318) = 0.9065 \\
%% a_{23} &= a_{22} - \kappa_3 a_{12} = -0.0318 - (-0.0293)(0.9074) = -0.0052 \\
%% E_3 &= E_2 (1 - {\kappa_3} ^ 2 ) = 2492(1 - {-0.0293 ^ 2}) = 2490
%% \end{align*}
%% }
%% Our final values are:
%% {\relsize{-2}
%% \begin{align*}
%% a_{11} &= 0.8795 & & & & \\
%% a_{12} &= 0.9074 & a_{22} &= -0.0318 & & \\
%% a_{13} &= 0.9065 & a_{23} &= -0.0052 & a_{33} &= -0.0293 \\
%% E_1 &= 2495 & E_2 &= 2492 & E_3 &= 2490
%% \end{align*}
%% }
%% \noindent
%% These values have been rounded to the nearest significant digit
%% and will not be an exact match to those generated by a computer.

%% \pagebreak

%% \subsubsection{Best Order Estimation}

%% At this point, we have an array of prospective LP coefficient lists,
%% a list of error values and must decide which LPC order to use.
%% There are two ways to accomplish this:  we can either estimate
%% the total bits from the error values or perform an exhaustive search.
%% Making the estimation requires the total number of samples
%% in the subframe, the number of overhead bits per order (by default,
%% this is the number of bits per sample in the subframe, plus 5),
%% and an error scale constant in addition to the LPC error values:
%% \begin{equation}
%% \text{Error Scale} = \frac{\ln(2) ^ 2}{2 \times \text{Total Samples}}
%% \end{equation}
%% \noindent
%% Once the error scale has been calculated, one can generate a
%% \VAR{Bits per Residual} estimation function which, given an \VAR{LPC Error}
%% value, returns what its name implies:
%% \begin{equation}
%% \text{Bits per Residual}(\text{LPC Error}) = \frac{\ln(\text{Error Scale} \times \text{LPC Error})}{2 \times \ln(2)}
%% \end{equation}
%% With this function, we can estimate how many bits the entire LPC subframe
%% will take for each \VAR{LPC Error} value and its associated \VAR{Order}:
%% {\relsize{-2}
%% \begin{equation*}
%% \text{Total Bits}(\text{LPC Error},\text{Order}) = \text{Bits per Residual}(\text{LPC Error}) \times (\text{Total Samples} - \text{Order}) + (\text{Order} \times \text{Overhead bits})
%% \end{equation*}
%% }
%% Continuing with our example, we have 20 samples and
%% now have the error values of 2495, 2492 and 2490.
%% This gives us an error scale of:
%% $\frac{{\ln(2) ^ 2}}{2 \times 20} = \frac{.6931 ^ 2}{40} = .01201$
%% \begin{align*}
%% \intertext{At LPC order 1, our bits per residual are:}
%% \frac{\ln(.01201 \times 2495)}{2 \times \ln (2)} = \frac{\ln(29.96)}{1.386} &= 2.453 \\
%% \intertext{And our total bits are:}
%% (2.453 \times (20 - 1)) + (1 \times (16 + 5)) = 46.61 + 21 &= 67.61 \\
%% \intertext{At LPC order 2, our bits per residual are:}
%% \frac{\ln(.01201 \times 2492)}{2 \times \ln(2)} = \frac{\ln(29.92)}{1.386} &= 2.452 \\
%% \intertext{And our total bits are:}
%% (2.452 \times (20 - 2)) + (2 \times (16 + 5)) = 44.14 + 42 &= 86.14 \\
%% \intertext{At LPC order 3, our bits per residual are:}
%% \frac{\ln(.01201 \times 2490)}{2 \times \ln(2)} = \frac{\ln(29.90)}{1.386} &= 2.451
%% \intertext{And our total bits are:}
%% (2.451 \times (20 - 3)) + (3 \times (16 + 5)) = 41.67 + 63 &= 104.7
%% \end{align*}
%% \par
%% \noindent
%% Therefore, since the total bits for order 1 are the smallest,
%% the best order for this group of samples is 1.

%% Though as you'll notice, the bits per residual for order 3 were the smallest.
%% So if this group of samples was very large, it's likely that order 3
%% would prevail since the residuals multiplied by a smaller bits per residual
%% would counteract the relatively fixed overhead bits per order value.

%% \subsubsection{Best Order Exhaustive Search}

%% In a curious bit of recursion, finding the best order for an LPC subframe
%% via an exhaustive search requires taking each list of LP Coefficients
%% calculated previously, quantizing them into a list of QLP Coefficients
%% and a QLP Shift Needed value,\footnote{Quantizing coefficients will be covered in the next section.}
%% determining the total amount of bits each hypothetical LPC subframe
%% uses and using the LPC order which uses the fewest.

%% Remember that building an LPC subframe requires the following values:
%% LPC Order, QLP Precision, QLP Shift Needed and QLP Coefficients along
%% with the subframe's samples and bits-per-sample.
%% For each possible LPC Order, the QLP Shift Needed and the QLP Coefficient
%% list values can be calculated by quantizing the LP Coefficients.
%% QLP Precision is the size of each QLP Coefficient list value in the
%% subframe header.
%% Simply choose the field with the largest number of bits in the
%% QLP Coefficient list for the QLP Precision value.

%% Finally, instead of writing these hypothetical LPC subframes directly to disk,
%% one only has to capture how many bits they \textit{would} use.
%% The hypothetical LPC subframe that uses the fewest number of bits
%% is the one we should actually write to disk.

%% \pagebreak

%% \subsubsection{Quantizing Coefficients}

%% Quantizing coefficients is a process of taking a list of LP Coefficients
%% along with a QLP Coefficients Precision value and
%% returning a list of QLP Coefficients and a QLP Shift Needed value.
%% The first step is determining the upper and lower limits of the
%% QLP Coefficients:
%% \begin{align}
%% \text{QLP coefficient maximum} &= 2 ^ {precision - 1} - 1 \\
%% \text{QLP coefficient minimum} &= - 2 ^ {precision - 1}
%% \end{align}
%% The QLP Coefficients Precision value is typically based on the encoder's
%% block size:
%% \begin{table}[h]
%% \begin{tabular}{|>{$}r<{$}|r||>{$}r<{$}|r|}
%% \hline
%% \text{Block Size} & Precision & \text{Block Size} & Precision \\
%% \hline
%% \text{Size} \leq 192 & 7 & \text{Size} \leq 384 & 8 \\
%% \text{Size} \leq 576 & 9 & \text{Size} \leq 1152 & 10 \\
%% \text{Size} \leq 2304 & 11 & \text{Size} \leq 4608 & 12 \\
%% \text{Size} > 4608 & 13 & & \\
%% \hline
%% \end{tabular}
%% \end{table}
%% \par
%% \noindent
%% So in our example of a block of 20 samples,
%% \begin{align*}
%% \text{QLP Coefficient maximum} = 2 ^ {7 - 1} -1 = 64 - 1 &= 63 \\
%% \text{QLP Coefficient minimum} = - 2 ^ {7 - 1} &= -64
%% \end{align*}
%% \par
%% \noindent
%% Now we determine the initial QLP Shift Needed value:
%% \begin{equation}
%% \text{shift} = \text{precision} - \left \lceil \frac{\log(\max(|\text{LP Coefficients}|))}{\log(2) } \right \rceil - 1
%% \end{equation}
%% \par
%% \noindent
%% where `shift' is adjusted if necessary such that:
%% $0 \leq \text{shift} \leq \texttt{0xF }$
%% , since it must fit into a 5-bit signed field and negative shifts
%% are no-ops in the FLAC decoder.

%% Continuing our ongoing example, let's assume we're quantizing the LP
%% coefficients 0.9065, -0.0052 and -0.0293.  So our shift should be:
%% \begin{equation*}
%% \text{shift} = 7 - \left \lceil \frac{\log(0.9065)}{\log(2)} \right \rceil - 1
%% = 7 - \left \lceil \frac{-0.0981}{0.6931} \right \rceil - 1 = 7 - 0 - 1 = 6
%% \end{equation*}
%% \par
%% \noindent
%% Finally, we determine the QLP Coefficient values themselves via a small
%% recursive routine:
%% \begin{align}
%% X(i) &= E(i - 1) + (\text{LP Coefficient}_i \times 2 ^ {shift}) \\
%% \text{QLP Coefficient}_i &= \text{round}(X(i)) \\
%% E(i) &= X(i) - \text{QLP Coefficient}_i
%% \end{align}
%% \par
%% \noindent
%% where $E(0) = 0$ and each QLP Coefficient is adjusted
%% prior to calculating the next $E(i)$ value such that:
%% $\text{QLP coefficient minimum} \leq \text{QLP Coefficient}_i \leq \text{QLP coefficient maximum}$

%% \pagebreak

%% So to finish our LPC example:
%% \begin{align*}
%% X(1) &= E(0) + (0.9065 \times 2 ^ 6 ) = 0 + 58.016 = \textbf{58.016} \\
%% \text{QLP Coefficient}_1 &= \text{round}(58.016) = \textbf{58} \\
%% E(1) &= X(1) - \text{QLP Coefficient}_1 = 58.016 - 58 = \textbf{0.016} \\
%% X(2) &= E(1) + (-0.0052 \times 2 ^ 6 ) = 0.016 + -0.3328 = \textbf{0.3168} \\
%% \text{QLP Coefficient}_2 &= \text{round}(0.3168) = \textbf{0} \\
%% E(2) &= X(2) - \text{QLP Coefficient}_2 = 0.3168 - 0 = \textbf{0.3168} \\
%% X(3) &= E(2) + (-0.0293 \times 2 ^ 6 ) = 0.3168 + -1.875 = \textbf{-1.558} \\
%% \text{QLP Coefficient}_3 &= \text{round}(-1.558) = \textbf{-2} \\
%% E(3) &= X(3) - \text{QLP Coefficient}_3 = -1.558 - -2 = \textbf{0.4420}
%% \end{align*}
%% \par
%% \noindent
%% Therefore, the LPC order is 3.
%% The QLP Coefficients are 58, 0 and -2.
%% The QLP Shift Needed value is 6.
%% And, the QLP precision value can be calculated from the bits required
%% for the largest absolute QLP Coefficient value.
%% In this case, 6 bits are required to hold the value 58 so
%% QLP precision can be 6.

%% %% The LPC Order, QLP Precision, QLP Shift Needed, and QLP Coefficients
%% %% make up the LPC subframe.

%% \clearpage

%% \subsubsection{Calculating LPC Residual}

%% Warm-up samples and residuals are calculated as follows:
%% \begin{align*}
%% \intertext{For $i = 0$ to $Order - 1$:}
%% \WARMUP_i &= \SAMPLE_i \\
%% \intertext{For $i = Order$ to Block Size - 1:}
%% \text{Residual}_{i - Order} &= \text{Sample}_i -
%% \left \lfloor \frac{\overset{Order - 1}{\underset{j = 0}{\sum}}
%%   \text{QLP Coefficient}_j \times \text{Sample}_{i - j - 1} }{
%% 2 ^ \text{QLP Shift Needed}} \right \rfloor
%% \end{align*}
%% \par
%% \noindent
%% Therefore, if \VAR{LPC Order} is 3, \VAR{QLP Shift Needed} is 6,
%% and we have the following values:
%% \begin{tabular}{r r | r r}
%% $\SAMPLE_0$ & -37 & $\COEFF_0$ & 58 \\
%% $\SAMPLE_1$ & -33 & $\COEFF_1$ & 0 \\
%% $\SAMPLE_2$ & -36 & $\COEFF_2$ & -2 \\
%% $\SAMPLE_3$ & -35 & & \\
%% $\SAMPLE_4$ & -31 & & \\
%% $\SAMPLE_5$ & -32 & & \\
%% $\SAMPLE_6$ & -33 & & \\
%% \end{tabular}

%% \clearpage

%% \begin{align*}
%% \WARMUP_0 &= \SAMPLE_0 = \textbf{-37} \\
%% \WARMUP_1 &= \SAMPLE_1 = \textbf{-33} \\
%% \WARMUP_2 &= \SAMPLE_2 = \textbf{-36} \\
%% \RESIDUAL_0 &= \SAMPLE_3 - \left\lfloor\frac{(C_0 \times S_2) + (C_1 \times S_1) + (C_2 \times S_2)}{2 ^ 6}\right\rfloor \\
%% &= -35 - \left\lfloor\frac{(58 \times -36) + (0 \times -33) + (-2 \times -37)}{64}\right\rfloor \\
%% &= -35 - \left\lfloor\frac{-2014}{64}\right\rfloor = -35 - -32 = \textbf{-3} \\
%% \RESIDUAL_1 &= \SAMPLE_4 - \left\lfloor\frac{(C_0 \times S_3) + (C_1 \times S_2) + (C_2 \times S_1)}{2 ^ 6}\right\rfloor \\
%% &= -31 - \left\lfloor\frac{(58 \times -35) + (0 \times -36) + (-2 \times -33)}{64}\right\rfloor \\
%% &= -31 - \left\lfloor\frac{-1964}{64}\right\rfloor = -31 - -31 = \textbf{0} \\
%% \RESIDUAL_2 &= \SAMPLE_5 - \left\lfloor\frac{(C_0 \times S_4) + (C_1 \times S_3) + (C_2 \times S_2)}{2 ^ 6}\right\rfloor \\
%% &= -32 - \left\lfloor\frac{(58 \times -31) + (0 \times -35) + (-2 \times -36)}{64}\right\rfloor \\
%% &= -32 - \left\lfloor\frac{-1726}{64}\right\rfloor = -32 - -27 = \textbf{-5} \\
%% \RESIDUAL_3 &= \SAMPLE_6 - \left\lfloor\frac{(C_0 \times S_5) + (C_1 \times S_4) + (C_2 \times S_3)}{2 ^ 6}\right\rfloor \\
%% &= -33 - \left\lfloor\frac{(58 \times -32) + (0 \times -31) + (-2 \times -35)}{64}\right\rfloor \\
%% &= -33 - \left\lfloor\frac{-1786}{64}\right\rfloor = -33 - -28 = \textbf{-5} \\
%% \end{align*}
%% Therefore, our warm-up samples are -37, -33 and -36; and our
%% residual values are -3, 0, -5 and -5.

%% \clearpage

%% \subsection{the Residual}

%% Given a stream of residual values, one must place them in one or more
%% partitions, each with its own Rice parameter, and prepended with a
%% small header:
%% \begin{figure}[h]
%% \includegraphics{figures/flac/residual.pdf}
%% \end{figure}


%% The residual's coding method is typically 0, unless one is encoding
%% audio with more than 16 bits-per-sample and one of the partitions
%% requests a Rice parameter higher than $2 ^ 4$.
%% The residual's partition order is chosen exhaustively, which means
%% trying all of them within a certain range (e.g. 0 to 5) such that
%% the residuals can be divided evenly between them and then the partition
%% order which uses the smallest estimated amount of space is chosen.

%% Choosing the best Rice parameter is a matter of selecting the smallest
%% value of `x' such that:
%% \begin{equation}
%% \text{sample count} \times 2 ^ x > \overset{\text{residual count} - 1}{\underset{i = 0}{\sum}} |\text{residual}_i|
%% \end{equation}
%% \begin{wrapfigure}[10]{r}{2in}
%% \begin{tabular}{|c|r|r|}
%% \hline
%% index & $\text{residual}_i$ & $|\text{residual}_i|$ \\
%% \hline
%% 0 & -1 & 1 \\
%% 1 & 1 & 1 \\
%% 2 & 1 & 1 \\
%% 3 & 1 & 1 \\
%% 4 & 0 & 0 \\
%% 5 & 3 & 3 \\
%% 6 & 0 & 0 \\
%% 7 & -4 & 4 \\
%% 8 & -1 & 1 \\
%% 9 & 0 & 0 \\
%% 10 & 1 & 1 \\
%% 11 & 1 & 1 \\
%% 12 & 1 & 1 \\
%% 13 & 4 & 4 \\
%% 14 & -3 & 3 \\
%% 15 & 1 & 1 \\
%% 16 & 4 & 4 \\
%% 17 & -1 & 1 \\
%% 18 & -1 & 1 \\
%% \hline
%% $|\text{sum}|$ & & \textbf{29} \\
%% \hline
%% \end{tabular}
%% \end{wrapfigure}
%% \par
%% Again, this is easier to understand with a block of example residuals,
%% 19 in total:
%% \par
%% \noindent
%% $19 \times {2 ^ 0}$ is not larger than 29.
%% \par
%% \noindent
%% $19 \times {2 ^ 1}$ is larger than 29, so the best Rice parameter
%% for this block of residuals is 1.
%% \par
%% Remember that the Rice parameter's maximum value is limited to
%% $2 ^ 4$ using coding method 0, or $2 ^ 5$ using coding method 1.

%% \clearpage

%% \subsubsection{Residual Values}

%% \begin{wrapfigure}[5]{r}{4in}
%% \includegraphics{figures/flac/write_residual.pdf}
%% \end{wrapfigure}
%% Encoding individual residual values to Rice coding requires only
%% the Rice parameter and the residuals themselves.
%% \vskip 26em
%% \par
%% \noindent
%% As an example, we'll encode the residual values 18, -25 and 12
%% with a Rice parameter of 3:
%% \begin{figure}[h]
%% \includegraphics{figures/flac/rice3.pdf}
%% \end{figure}

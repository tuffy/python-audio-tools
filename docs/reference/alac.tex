%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{Apple Lossless}

Apple's lossless audio codec, informally referred to as ``ALAC'',
is lossless audio inside a QuickTime container - similar to M4A.
Its stream is the same collection of atoms as covered on page
\pageref{m4a}.
The key difference is the contents of its \texttt{mdat} atom.

\section{the ALAC file stream}
\begin{wrapfigure}[6]{r}{1.5in}
\includegraphics{figures/alac_atoms.pdf}
\end{wrapfigure}

This is the typical arrangements of ALAC atoms as encoded by iTunes.
As you can see, it is almost identical to the layout of AAC audio.
One of the key differences is that ALAC's \texttt{stsd} atom
contains an \texttt{alac} description sub-atom rather than an
\texttt{mp4a} description atom.

Its layout is as follows:

\begin{figure}[h]
\includegraphics{figures/alac_alac_atom.pdf}
\end{figure}

\pagebreak

\section{ALAC decoding}

An ALAC stream is made up of individual frames within the \texttt{mdat}
atom, as follows:

\begin{figure}[h]
\includegraphics{figures/alac_stream.pdf}
\end{figure}
\par
\noindent
ALAC frames come in two varieties: compressed and uncompressed,
depending on the \VAR{Is Not Compressed} bit in the frame header.
An uncompressed frame is laid out as follows:

\begin{figure}[h]
\includegraphics{figures/alac_uncompressed_frame.pdf}
\end{figure}
\par
\noindent
The number of PCM frames in an ALAC frame depends on the \VAR{Has Sample Size}
bit.
If set, the number of PCM frames equals the 32-bit \VAR{Sample Size}
value.
If not set, the total number of PCM frames equals the \VAR{Max Coded Frame Size}
value in the \texttt{alac} atom and the \VAR{Sample Size} value is omitted.
ALAC streams typically use the same number of samples per frame
until the end of the stream, at which point the leftover samples
are placed in a different-sized frame.

Uncompressed frames interleave samples between channels during decoding.
For example, a 2 channel frame places $\text{Sample}_1$ on $\text{Channel}_1$,
$\text{Sample}_2$ on $\text{Channel}_2$,
$\text{Sample}_3$ on $\text{Channel}_1$,
$\text{Sample}_4$ on $\text{Channel}_2$ and so on.

Finally, note that all ALAC frames have a footer of the bits `\texttt{111}'
and padding as needed such that each frame begins on an aligned byte boundary.

\pagebreak

A compressed frame is laid out as follows:

\begin{figure}[h]
\includegraphics{figures/alac_compressed_frame.pdf}
\end{figure}
\par
\noindent
\VAR{Interlacing Shift} and \VAR{Interlacing Leftweight} are used
for channel decorrelation after the subframes have been decoded.

There is one subframe header and one residual block per
channel.
If \VAR{Wasted Bits} is greater than 0, there is also
a block of wasted bits samples after the subframe headers but before
the residuals.

\VAR{Wasted Bits} is an attempt to store the least significant bits
of each sample more efficiently at high bits-per-sample, where
that data will often be indistinguishable from random noise.
In effect, it's a block of interlaced uncompressed samples
(similar to an uncompressed ALAC frame) each $8 \times \text{\VAR{Wasted Bits}}$
bits large.
Those wasted bits are then prepended to each sample prior to channel
decorrelation.
I'll explain this process in more detail later.

Each subframe header is laid out as follows:

\begin{figure}[h]
\includegraphics{figures/alac_subframe_header.pdf}
\end{figure}
\par
\noindent
There are \VAR{Coefficient Count} number of coefficients in each
subframe header, each a 16-bit signed value.

\pagebreak

\subsection{Residual decoding}

There are \VAR{Sample Size} number of residuals per residual block.
Decoding a residual block requires knowing the \VAR{Initial History},
\VAR{History Multiplier}, \VAR{Maximum K}, \VAR{Channels}, \VAR{Wasted Bits} and
\VAR{Bits per Sample} values, from the \texttt{alac} atom and frame header.
Fortunately, most of these values are rarely used;
we'll mostly be concerned with the \VAR{History} and \VAR{History Multiplier}.

For each residual block, \VAR{History} starts with the value of
\VAR{Initial History} and will change during residual decoding.
We use it to calculate $\kappa$ using the following formula:
\begin{equation}
\kappa = \left\lfloor\log_2 \left( \frac{\text{history}}{2 ^ 9} + 3 \right) \right\rfloor
\end{equation}
Note that if $\kappa$ exceeds the \VAR{Maximum K} value from the
\texttt{alac} atom, \VAR{Maximum K} is used instead.

We then need to know the \VAR{Bits per Sample} value of the residual
block, which is equal to:
\begin{equation}
\text{Bits per Sample}_{Residual} = \text{Bits per Sample}_{ALAC} - (\text{Wasted Bits} \times 8) + \text{Channels} - 1
\end{equation}
For mono streams, this is typically equal to the stream's
\VAR{Bits per Sample},
while for stereo streams it's often the \VAR{Bits per Sample} plus 1.

\begin{wrapfigure}[14]{r}{2.5in}
\includegraphics{figures/alac_read_residual.pdf}
\end{wrapfigure}
The $\kappa$ and \VAR{Bits per Sample} values are used to read a
single unsigned residual value in the following way:

The initial bit reading portion of the process
involves reading a unary value with a stop bit of `0'
and a maximum value of 8.
If the maximum value is exceeded, we read \VAR{Bits per Sample}
number of bits as our final value
(the only place \VAR{Bits per Sample} is used throughout the
residual decoding process).

Otherwise, we read $\kappa$ number of \VAR{extra} bits if $\kappa > 1$.
If \VAR{extra} is greater than 1, we return
$(\text{\VAR{unary}} \times (2^k - 1)) + (\text{\VAR{extra}} - 1)$.
If not, we push a single \VAR{extra} bit back on the stream and return our
$\text{\VAR{unary}} \times (2^k - 1)$ value.

\clearpage

We perform the following to convert unsigned residuals to signed residuals
which are returned to the subframe decoder:
\begin{equation}
\text{signed} =
\begin{cases}
(\text{unsigned} + 1) \gg 1 & \text{if unsigned is even} \\
-((\text{unsigned} + 1) \gg 1) & \text{if unsigned is odd}
\end{cases}
\end{equation}

Finally, we use our unsigned value to update \VAR{history}
before reading the next residual:
{\relsize{-1}
\begin{equation*}
\text{history} =
\begin{cases}
\text{history} + (\text{unsigned} \times \text{history multiplier}) - \left\lfloor\frac{\text{history} \times \text{history multiplier}}{2^9}\right\rfloor & \text{if unsigned} \leq 65535 \\
65535 & \text{if unsigned} > 65535
\end{cases}
\end{equation*}
}

Thus far, residual decoding isn't overly complex.
We simply calculate $\kappa$ from \VAR{history}, read a residual,
update \VAR{history} from its unsigned value and repeat the process
until we've read an entire subframe's worth of residuals.
The bulk of an ALAC file's residuals will be read in this way.
However, ALAC also features an ``escape code'' for large chunks
of 0 residuals (which may happen during a long stretch of
digital silence, for example).

If \VAR{history} ever falls below 128, this special case is triggered.
First, we read a special \VAR{block size} residual value
with a \VAR{Bits per Sample} value of 16 and a $\kappa$\footnote{Again, $\kappa$ cannot exceed \VAR{Maximum K} as encoded in the \texttt{alac} atom.} value of:
\begin{equation}
\kappa_{\text{blocksize}} = 7 - \log_2(\text{history}) + \frac{\text{history} + 16}{64}
\end{equation}
This \VAR{block size} is how many 0 residuals to send outright -
which may be 0, indicating no 0 residuals to send.
Either way, if $\text{\VAR{block size}} \leq 65535$,
we add 1 to the unsigned value of the next residual in the block (if any).
Finally, \VAR{history} is automatically set to 0.

\clearpage

\subsubsection{Residual decoding example}

In this example, we'll decode a group of residuals in which our
\VAR{Initial History} is 1130 and our \VAR{History Multiplier} is 40.
As a spoiler, $\kappa$ (the amount of non-unary bits to read
after each unary value) will remain 2 for this batch of residuals,
but why that is so will be explained below.

\begin{figure}[h]
\includegraphics{figures/alac_residual.pdf}
\end{figure}
\begin{itemize}
\setlength{\itemsep}{0in}
\setlength{\parskip}{0in}
\item Residual 1
\begin{itemize}
\item $\kappa = \lfloor\log_2((1130 \div 2^9) + 3)\rfloor = \lfloor\log_2(5)\rfloor = 2$
\item $\text{unsigned}_1 = (\textbf{0} \times (2^2 - 1)) + (\textbf{3} - 1) = \textbf{2}$
\item $\text{residual}_1 = (2 + 1) \gg 1 = 1$
\item $\text{history} = 1130 + (\textbf{2} \times 40) - \lfloor(1130 \times 40) \div 2^9\rfloor = 1130 + 80 - 88 = 1122$
\end{itemize}
\item Residual 2
\begin{itemize}
\item $\kappa = \lfloor\log_2((1122 \div 2^9) + 3)\rfloor = \lfloor\log_2(5)\rfloor = 2$
\item $\text{unsigned}_2 = (\textbf{2} \times (2^2 - 1)) + (\textbf{3} - 1) = \textbf{8}$
\item $\text{residual}_2 = (8 + 1) \gg 1 = 4$
\item $\text{history} = 1122 + (\textbf{8} \times 40) - \lfloor(1122 \times 40) \div 2^9\rfloor = 1122 + 320 - 87 = 1355$
\end{itemize}
\item Residual 3
\begin{itemize}
\item $\kappa = \lfloor\log_2((1355 \div 2^9) + 3)\rfloor = \lfloor\log_2(5)\rfloor = 2$
\item $\text{unsigned}_3 = (\textbf{1} \times (2^2 - 1)) = \textbf{3}$\hfill (note that we ``unread'' one 0 bit here)
\item $\text{residual}_3 = -((3 + 1) \gg 1) = -2$
\item $\text{history} = 1355 + (\textbf{3} \times 40) - \lfloor(1355 \times 40) \div 2^9\rfloor = 1355 + 120 - 105 = 1370$
\end{itemize}
\item Residual 4
\begin{itemize}
\item $\kappa = \lfloor\log_2((1370 \div 2^9) + 3)\rfloor = \lfloor\log_2(5)\rfloor = 2$
\item $\text{unsigned}_4 = (\textbf{0} \times (2^2 - 1)) + (\textbf{3} - 1) = \textbf{2}$
\item $\text{residual}_4 = (2 + 1) \gg 1 = 1$
\item $\text{history} = 1370 + (\textbf{2} \times 40) - \lfloor(1370 \times 40) \div 2^9\rfloor = 1370 + 80 - 107 = 1343$
\end{itemize}
\end{itemize}
Thus, our batch of signed residual values are 1, 4, -2 and 1.

\clearpage

\subsection{Subframe calculation}

% example:
% decode residuals [16, 1, 9, -1, -1, 1, -4, 7, -7, -1]
% with starting coeffs [1122, -766, 107, 122]
% and prediction_quantitization 9
% to samples [16, 17, 26, 25, 24, 23, 20, 24, 23, 20]

Given our list of decoded residual values;
along with a list of coefficients,
a \VAR{Coefficient Count} and a \VAR{Prediction Quantitization} value
(all from the subframe header),
we can now generate a list of signed subframe samples for a
given channel.

The first residual is always the first output sample:
\begin{align*}
\text{Sample}_0 &= \text{Residual}_0 \\
\intertext{Then, for the next \VAR{Coefficient Count} number of residuals:}
\text{Sample}_i &= \text{Residual}_i + \text{Sample}_{i - 1}
\end{align*}

For example, given that we have a \VAR{Coefficient Count} of 4
and our first five residuals are 16, 1, 9, -1 and -1;
our first five sample values are:
\begin{align*}
\text{Sample}_0 &= \textbf{16} \\
\text{Sample}_1 = 16 + 1 &= \textbf{17} \\
\text{Sample}_2 = 17 + 9 &= \textbf{26} \\
\text{Sample}_3 = 26 - 1 &= \textbf{25} \\
\text{Sample}_4 = 25 - 1 &= \textbf{24}
\end{align*}
These are our ``starting point'' samples upon which the remainder
of the subframe will be built.

Subsequent samples are calculated in the following way:

\begin{align*}
\text{LPC Sum}_i &= \overset{coeffs - 1}{\underset{j = 0}{\sum}}
\text{Coefficient}_j \times (\text{Sample}_{i - j - 1} - \text{Sample}_{i - coeffs - 1}) \\
\text{Sample}_i &= \left\lfloor \frac{\text{LPC Sum}_i + 2^{\text{Predictor Quantitization - 1}}} {2 ^ \text{Predictor Quantitization}}\right\rfloor + Residual_i + \text{Sample}_{i - coeffs - 1} \\
\intertext{For example, given $\text{Residual}_5$ = 1,
\VAR{Predictor Quantitization} = 9
and the coefficients 1122, -766, 107 and 122:}
\text{LPC Sum}_5 &=
(1122 \times (24 - 16)) + (-766 \times (25 - 16)) +
 (107 \times (26 - 16)) + (122 \times (17 - 16)) \\
&= (1122 \times 8) + (-766 \times 9) + (107 \times 10) + (122 \times 1) \\
&= 8976 + -6894 + 1070 + 122 = \textbf{3274} \\
\text{Sample}_5 &= \left\lfloor\frac{\textbf{3274} + 2^8}{2^9}\right\rfloor + 1 + 16
= \left\lfloor\frac{3530}{512}\right\rfloor + 1 + 16 = \textbf{23}
\end{align*}
But before calculating $\text{Sample}_6$,
we need to adjust our coefficient list.

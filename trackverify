#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2013  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

import sys
import os.path
import audiotools
import audiotools.text as _
from operator import or_

MAX_CPUS = audiotools.MAX_JOBS


class Counter:
    def __init__(self):
        self.value = 0

    def __int__(self):
        return self.value

    def increment(self):
        self.value += 1


class FailedAudioFile:
    def __init__(self, class_name, filename, err):
        self.NAME = class_name
        self.filename = filename
        self.err = err

    def verify(self):
        raise self.err


def open_file(filename):
    #this is much like audiotools.open
    #except that file init errors fail differently

    f = open(filename, "rb")
    try:
        audio_class = audiotools.file_type(f)
        if (((audio_class is not None) and
             (audio_class.has_binaries(audiotools.BIN)))):
            class_name = audio_class.NAME
            try:
                return audio_class(filename)
            except audiotools.InvalidFile, err:
                return FailedAudioFile(class_name, filename, err)
        else:
            raise audiotools.UnsupportedFile(filename)
    finally:
        f.close()


def get_tracks(args, queued_files, accept_list=None):
    if (accept_list is not None):
        accept_list = set(accept_list)

    for path in args:
        if (os.path.isfile(path)):
            try:
                filename = audiotools.Filename(path)
                if (filename not in queued_files):
                    queued_files.add(filename)
                    track = open_file(str(filename))
                    if ((accept_list is None) or (track.NAME in accept_list)):
                        yield track
            except (audiotools.UnsupportedFile, IOError, OSError):
                continue
        elif (os.path.isdir(path)):
            for (d, ds, fs) in os.walk(path):
                for track in get_tracks([os.path.join(d, f) for f in fs],
                                        queued_files,
                                        accept_list=accept_list):
                    yield track


def track_number(track, default):
    metadata = track.get_metadata()
    if (metadata is not None):
        if (metadata.track_number is not None):
            return metadata.track_number
        else:
            return default
    else:
        return default


def verify(progress, track):
    try:
        track.verify(progress)
        return (unicode(audiotools.Filename(track.filename)),
                track.NAME,
                None)
    except audiotools.InvalidFile, err:
        return (unicode(audiotools.Filename(track.filename)),
                track.NAME,
                unicode(err))


def display_results(result):
    msg = audiotools.Messenger("trackverify", None)
    ansi = msg.ansi
    FG_GREEN = msg.FG_GREEN
    FG_RED = msg.FG_RED

    (filename, track_type, error) = result
    if (error is None):
        return _.LAB_TRACKVERIFY_RESULT % {
            "path": filename,
            "result": ansi(_.LAB_TRACKVERIFY_OK, [FG_GREEN])}
    else:
        return _.LAB_TRACKVERIFY_RESULT % {
            "path": filename,
            "result": ansi(error, [FG_RED])}

#returned if the track isn't found in the AccurateRip database
AR_NOT_FOUND = -1

#returned if the track has one or more matches in the AccurateRip database
#but our track doesn't match any of the checksums
AR_MISMATCH = -2

def accuraterip_checksum(progress, track, ar_matches):
    from audiotools.cdio import ARChecksum

    if (len(ar_matches) == 0):
        return (unicode(audiotools.Filename(track.filename)),
                track.NAME,
                AR_NOT_FOUND,
                None)
    else:
        reader = audiotools.PCMReaderProgress(track.to_pcm(),
                                              track.total_frames(),
                                              progress)
        checksum = ARChecksum()

        try:
            audiotools.transfer_data(reader.read, checksum.update)
        except (IOError, ValueError), err:
            return (unicode(audiotools.Filename(track.filename)),
                    track.NAME,
                    None,
                    str(err))

        checksum = checksum.checksum()

        for (confidence, ar_checksum, ar_crc2) in ar_matches:
            if (checksum == ar_checksum):
                return (unicode(audiotools.Filename(track.filename)),
                        track.NAME,
                        confidence,
                        None)
        else:
            return (unicode(audiotools.Filename(track.filename)),
                    track.NAME,
                    AR_MISMATCH,
                    None)


def accuraterip_display_result(result):
    (filename, track_type, confidence, error) = result

    if (error is None):
        if (confidence == AR_NOT_FOUND):
            return _.LAB_TRACKVERIFY_RESULT % \
                {"path":filename,
                 "result":_.LAB_ACCURATERIP_NOT_FOUND}
        elif (confidence == AR_MISMATCH):
            return _.LAB_TRACKVERIFY_RESULT % \
                {"path":filename,
                 "result":_.LAB_ACCURATERIP_MISMATCH}
        else:
            return _.LAB_TRACKVERIFY_RESULT % \
                {"path":filename,
                 "result":u"%s (%s)" %
                 (_.LAB_ACCURATERIP_FOUND,
                  _.LAB_ACCURATERIP_CONFIDENCE %
                  (confidence))}

    else:
        #FIXME - display actual error
        return u"read error"


def accuraterip_image_checksum(progress, track, ar_matches,
                               displayed_filename,
                               pcm_frames_offset, total_pcm_frames):
    from audiotools.cdio import ARChecksum

    if (len(ar_matches) == 0):
        return (unicode(audiotools.Filename(track.filename)),
                track.NAME,
                AR_NOT_FOUND,
                None)
    else:
        reader = track.to_pcm()

        #if PCMReader has seek(), use it to reduce the amount of frames to skip
        if (hasattr(reader, "seek") and callable(reader.seek)):
            pcm_frames_offset -= reader.seek(pcm_frames_offset)

        reader = audiotools.PCMReaderProgress(
            audiotools.PCMReaderWindow(reader,
                                       pcm_frames_offset,
                                       total_pcm_frames),
            total_pcm_frames,
            progress)

        checksum = ARChecksum()

        try:
            audiotools.transfer_data(reader.read, checksum.update)
        except (IOError, ValueError), err:
            return (displayed_filename,
                    track.NAME,
                    None,
                    str(err))

        checksum = checksum.checksum()

        for (confidence, ar_checksum, ar_crc2) in ar_matches:
            if (checksum == ar_checksum):
                return (displayed_filename,
                        track.NAME,
                        confidence,
                        None)
        else:
            return (displayed_filename,
                    track.NAME,
                    AR_MISMATCH,
                    None)


if (__name__ == '__main__'):
    parser = audiotools.OptionParser(
        usage=_.USAGE_TRACKVERIFY,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option('-t', '--type',
                      action='append',
                      dest='accept_list',
                      metavar='type',
                      choices=audiotools.TYPE_MAP.keys(),
                      help=_.OPT_TYPE_TRACKVERIFY)

    parser.add_option('-S', '--no-summary',
                      action='store_true',
                      dest='no_summary',
                      help=_.OPT_NO_SUMMARY)

    parser.add_option('-R', '--accuraterip',
                      action='store_true',
                      dest='accuraterip',
                      default=False,
                      help=_.OPT_ACCURATERIP)

    parser.add_option('-j', '--joint',
                      action='store',
                      type='int',
                      default=MAX_CPUS,
                      dest='max_processes',
                      help=_.OPT_JOINT)

    parser.add_option('-V', '--verbose',
                      action='store',
                      dest='verbosity',
                      choices=audiotools.VERBOSITY_LEVELS,
                      default=audiotools.DEFAULT_VERBOSITY,
                      help=_.OPT_VERBOSE)

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("trackverify", options)

    if (not options.accuraterip):
        queued_files = set([])  # a set of Filename objects already encountered
        queue = audiotools.ExecProgressQueue(audiotools.ProgressDisplay(msg))
        for track in get_tracks(args, queued_files, options.accept_list):
            queue.execute(
                function=verify,
                progress_text=unicode(audiotools.Filename(track.filename)),
                completion_output=display_results,
                track=track)

        msg.ansi_clearline()
        results = queue.run(options.max_processes)

        formats = sorted(list(set([r[1] for r in results])))
        success_total = len([r for r in results if r[2] is None])
        failure_total = len(results) - success_total

        if ((len(formats) > 0) and (not options.no_summary)):
            msg.output(_.LAB_TRACKVERIFY_RESULTS)
            msg.output(u"")
            msg.new_row()
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_FORMAT, True)
            msg.output_column(u" ")
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_SUCCESS, True)
            msg.output_column(u" ")
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_FAILURE, True)
            msg.output_column(u" ")
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_TOTAL, True)
            msg.divider_row([u"-", u" ", u"-", u" ", u"-", u" ", u"-"])

            for format in formats:
                success = len([r for r in results if ((r[1] == format) and
                                                      (r[2] is None))])
                failure = len([r for r in results if ((r[1] == format) and
                                                      (r[2] is not None))])
                msg.new_row()
                msg.output_column(format.decode('ascii'), True)
                msg.output_column(u" ")
                msg.output_column(unicode(success), True)
                msg.output_column(u" ")
                msg.output_column(unicode(failure), True)
                msg.output_column(u" ")
                msg.output_column(unicode(success + failure), True)

            msg.divider_row([u"-", u" ", u"-", u" ", u"-", u" ", u"-"])
            msg.new_row()
            msg.output_column(_.LAB_TRACKVERIFY_SUMMARY, True)
            msg.output_column(u" ")
            msg.output_column(unicode(success_total), True)
            msg.output_column(u" ")
            msg.output_column(unicode(failure_total), True)
            msg.output_column(u" ")
            msg.output_column(unicode(success_total + failure_total), True)

            msg.output_rows()

        if (failure_total > 0):
            sys.exit(1)
    else:
        queued_files = set([])  # a set of Filename objects already encountered
        queue = audiotools.ExecProgressQueue(audiotools.ProgressDisplay(msg))

        for tracks in audiotools.group_tracks(
                get_tracks(args, queued_files, options.accept_list)):
            #perform AccurateRip lookup on album's worth of tracks
            #if tracks are CD formatted
            if ((set([t.channels() for t in tracks]) == set([2])) and
                (set([t.sample_rate() for t in tracks]) == set([44100])) and
                (set([t.bits_per_sample() for t in tracks]) == set([16]))):

                if ((len(tracks) == 1) and
                    (tracks[0].get_cuesheet() is not None)):
                    filename = audiotools.Filename(tracks[0].filename)
                    sheet = tracks[0].get_cuesheet()
                    total_frames = tracks[0].total_frames()
                    sample_rate = tracks[0].sample_rate()

                    #process tracks in CD image individually
                    ar_results = audiotools.accuraterip_sheet_lookup(
                        sheet, total_frames, sample_rate)

                    pcm_frames_offset = 0

                    for (i, pcm_frames) in enumerate(sheet.pcm_lengths(
                            total_frames, sample_rate), 1):
                        filename = u"%s - track %2.2d" % \
                                   (audiotools.Filename(tracks[0].filename), i)
                        queue.execute(
                            function=accuraterip_image_checksum,
                            progress_text=filename,
                            completion_output=accuraterip_display_result,
                            track=tracks[0],
                            ar_matches=ar_results.get(i, []),
                            displayed_filename=filename,
                            pcm_frames_offset=pcm_frames_offset,
                            total_pcm_frames=pcm_frames)

                        pcm_frames_offset += pcm_frames
                else:
                    #process each track as if it were a CD
                    tracks = audiotools.sorted_tracks(tracks)
                    ar_results = audiotools.accuraterip_lookup(tracks)

                    for (i, track) in enumerate(tracks, 1):
                        filename = audiotools.Filename(track.filename)

                        queue.execute(
                            function=accuraterip_checksum,
                            progress_text=unicode(filename),
                            completion_output=accuraterip_display_result,
                            track=track,
                            ar_matches=ar_results.get(
                                track_number(track, i), []))
            else:
                for track in tracks:
                    msg.error(u"\"%(path)s\" %(result)s" %
                              {"path":audiotools.Filename(track.filename),
                               "result":_.ERR_TRACKVERIFY})

        msg.ansi_clearline()
        results = queue.run(options.max_processes)

        formats = sorted(list(set([r[1] for r in results])))
        is_match = lambda r: (r[2] is not None) and (r[2] >= 0)
        is_mismatch = lambda r: r[2] == AR_MISMATCH
        is_notfound = lambda r: r[2] == AR_NOT_FOUND
        is_error = lambda r: r[3] is not None

        output_filters = []
        divider_row = []

        if ((len(formats) > 0) and (not options.no_summary)):
            msg.output(_.LAB_TRACKVERIFY_RESULTS)
            msg.output(u"")

            msg.new_row()
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_FORMAT, True)
            divider_row.append(u"-")
            for (output_filter,
                 title) in [(is_match,
                             _.LAB_TRACKVERIFY_ACCURATERIP_MATCH),
                            (is_mismatch,
                             _.LAB_TRACKVERIFY_ACCURATERIP_MISMATCH),
                            (is_notfound,
                             _.LAB_TRACKVERIFY_ACCURATERIP_NOTFOUND),
                            (is_error,
                             _.LAB_TRACKVERIFY_ACCURATERIP_ERROR)]:
                if (len(filter(output_filter, results)) > 0):
                    msg.output_column(u" ")
                    msg.output_column(title)
                    output_filters.append(output_filter)
                    divider_row.extend([u" ", u"-"])

            msg.output_column(u" ")
            msg.output_column(_.LAB_TRACKVERIFY_RESULT_TOTAL, True)
            divider_row.extend([u" ", u"-"])
            msg.divider_row(divider_row)

            for format in formats:
                format_results = [r for r in results if r[1] == format]
                msg.new_row()
                msg.output_column(format.decode('ascii'), True)
                for output_filter in output_filters:
                    msg.output_column(u" ")
                    msg.output_column(
                        unicode(len(filter(output_filter, format_results))),
                        True)

                msg.output_column(u" ")
                msg.output_column(unicode(len(format_results)), True)

            msg.divider_row(divider_row)
            msg.new_row()
            msg.output_column(_.LAB_TRACKVERIFY_SUMMARY, True)
            for output_filter in output_filters:
                msg.output_column(u" ")
                msg.output_column(
                    unicode(len(filter(output_filter, results))), True)
            msg.output_column(u" ")
            msg.output_column(unicode(len(results)), True)

            msg.output_rows()

        if (len(filter(is_error, results)) > 0):
            sys.exit(1)

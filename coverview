#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os
import os.path
import optparse
import cStringIO
try:
    import gtk
    import gtk.gdk
    import gtk.glade
except ImportError:
    print >>sys.stderr,"*** PyGTK2 is required"
    sys.exit(1)
import audiotools

#returns the dimensions of image_surface scaled to match the
#display surface size, but without changing its aspect ratio
def image_size(display_surface, image_surface):
    display_ratio = float(display_surface[0]) / \
                    float(display_surface[1])

    image_ratio = float(image_surface.get_width()) / \
                    float(image_surface.get_height())

    if (image_ratio > display_ratio): #image wider than display, when scaled
        new_width = display_surface[0]
        new_height = image_surface.get_height() / \
                     (float(image_surface.get_width()) / \
                      float(display_surface[0]))
    else:                             #image taller than display, when scaled
        new_width = image_surface.get_width() / \
                    (float(image_surface.get_height()) / \
                     float(display_surface[1]))
        new_height = display_surface[1]

    (new_width,new_height) = map(int,(new_width,new_height))

    return (new_width,new_height)

def get_pixbuf(imagedata,width,height):
    imagedata = cStringIO.StringIO(imagedata)
    l = gtk.gdk.PixbufLoader()

    s = imagedata.read(0x1000)
    while (len(s) > 0):
        l.write(s)
        s = imagedata.read(0x1000)
    l.close()

    pb = l.get_pixbuf()
    (width,height) = image_size((width,height),pb)
    pb = pb.scale_simple(width,height,gtk.gdk.INTERP_BILINEAR)
    return pb

def get_raw_pixbuf(imagedata):
    l = gtk.gdk.PixbufLoader()
    l.write(imagedata)
    l.close()

    return l.get_pixbuf()

class ImageList:
    #picture_list is a list of (filepath,Image) tuples
    def __init__(self, picture_list, xml):
        self.xml = xml
        self.image_width = 500
        self.image_height = 500

        image_list = xml.get_widget("image_list")
        image = xml.get_widget("picture_image")

        self.image_liststore = gtk.ListStore(gtk.gdk.Pixbuf,
                                             gtk.gdk.Pixbuf,
                                             str,str)
        image_list.set_model(self.image_liststore)
        image_list.append_column(gtk.TreeViewColumn(
                "Image",gtk.CellRendererPixbuf(),pixbuf=0))

        self.set_images(picture_list)



    #picture_list is a list of (filepath,Image) tuples
    def set_images(self, picture_list):
        first_image = None
        xml.get_widget("picture_image").clear()
        window = xml.get_widget("main_window").window
        window.set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
        window.show()

        for (path,image) in picture_list:
            treeiter = self.image_liststore.append()
            pb = get_pixbuf(image.data,120,120)
            large_pb = get_raw_pixbuf(image.data)
            self.image_liststore.set(treeiter,0,pb)
            self.image_liststore.set(treeiter,1,large_pb)
            self.image_liststore.set(treeiter,2,image.type_string())
            self.image_liststore.set(treeiter,3,path)

            if (first_image is None):
                first_image = treeiter

        if (len(picture_list) > 0):
            self.xml.get_widget("image_list").get_selection().select_iter(
                first_image)
            self.image_selected()

        window.set_cursor(None)

    def image_selected(self, *args):
        (liststore,treeiter) = \
            self.xml.get_widget("image_list").get_selection().get_selected()

        selected = liststore.get_value(treeiter,1)

        (width,height) = image_size((self.image_width,
                                     self.image_height),
                                    selected)

        image = xml.get_widget("picture_image")
        image.set_from_pixbuf(selected.scale_simple(width,
                                                    height,
                                                    gtk.gdk.INTERP_BILINEAR))
        self.xml.get_widget("file_path").set_text(
            liststore.get_value(treeiter,3))
        self.xml.get_widget("picture_type").set_text(
            liststore.get_value(treeiter,2))

    def open_file(self, *args):
        self.xml.get_widget('file_chooser').run()

    def track_selected(self, dialog, signal):
        chooser = self.xml.get_widget('file_chooser')
        chooser.hide()
        if (signal == -5):
            self.image_liststore.clear()
            xml.get_widget("picture_image").clear()
            xml.get_widget('file_path').set_text('')
            xml.get_widget('picture_type').set_text('')

            try:
                metadata = audiotools.open(
                    chooser.get_filename()).get_metadata()
                if (metadata is not None):
                    self.set_images([(chooser.get_filename(),img)
                                     for img in metadata.images()])

            except audiotools.UnsupportedFile:
                pass

    def image_resized(self, image, rectangle):
        if ((self.image_width,self.image_height) !=
            (rectangle.width,rectangle.height)):
            self.image_width = rectangle.width
            self.image_height = rectangle.height
            self.image_selected()

if (__name__ == '__main__'):
    cover_list = []

    gladepath = os.path.join(".","coverview.glade")
    if (os.path.isfile(gladepath)):
        xml = gtk.glade.XML(gladepath)
    else:
        gladepath = os.path.join(sys.prefix,"share/audiotools",
                                 "coverview.glade")
        if (os.path.isfile(gladepath)):
            xml = gtk.glade.XML(gladepath)
        else:
            print >>sys.stderr,"*** coverview.glade not found"
            sys.exit(1)

    parser = optparse.OptionParser(
        "%prog [options] <track 1> [track 2] ...",
        version="Python Audio Tools %s" % (audiotools.VERSION))

    (options,args) = parser.parse_args()

    for audiofile in audiotools.open_files(args):
        try:
            metadata = audiofile.get_metadata()

            if ((metadata != None) and
                (len(metadata.images()) > 0)):
                for image in metadata.images():
                    cover_list.append((audiofile.filename,image))
        except audiotools.UnsupportedFile:
            continue

    imagelist = ImageList(cover_list, xml)

    xml.signal_connect("gtk_main_quit",gtk.main_quit)
    xml.signal_connect("image_selected",imagelist.image_selected)
    xml.signal_connect("open_file",imagelist.open_file)
    xml.signal_connect("track_selected",imagelist.track_selected)
    xml.signal_connect("image_resize",imagelist.image_resized)
    gtk.main()

#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2009  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os
from optparse import OptionParser,make_option
import audiotools

if (__name__ == '__main__'):
    parser = OptionParser(usage="%prog [--cdrom CDROM device] [-p] [-s speed] [track] ...",
                          version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option('-c','--cdrom',action='store',
                      type='string',dest='cdrom',
                      default=audiotools.DEFAULT_CDROM)

    parser.add_option('-s','--speed',action='store',
                      type='int',dest='speed')

    parser.add_option('-t','--type',
                      action='store',
                      dest='type',
                      choices=audiotools.TYPE_MAP.keys(),
                      default='wav',
                      help='the type of audio value to convert to')

    parser.add_option('-q','--quality',
                      action='store',
                      type='string',
                      dest='quality',
                      help='the quality to store audio values at')

    parser.add_option('-x','--xmcd',
                      action='store',
                      type='string',
                      dest='xmcd',
                      help='an XMCD file to get audio metadata from')

    parser.add_option("-d","--dir",action='store',default='.',
                      dest='dir')

    parser.add_option('--format',
                      action='store',
                      type='string',
                      default=audiotools.FILENAME_FORMAT,
                      dest='format',
                      help='the format string for new filenames')

    parser.add_option('--album-number',
                      dest='album_number',
                      action='store',
                      type='int',
                      default=0,
                      help='the album number of this CD, if it is one of a series of albums')

    #if adding ReplayGain is a lossless process
    #(i.e. added as tags rather than modifying track data)
    #add_replay_gain should default to True
    #if not, add_replay_gain should default to False
    #which is which depends on the track type
    parser.add_option('--replay-gain',
                      action='store_true',
                      dest='add_replay_gain',
                      help='add ReplayGain metadata to newly created tracks')

    parser.add_option('--no-replay-gain',
                      action='store_false',
                      dest='add_replay_gain',
                      help='do not add ReplayGain metadata in newly created tracks')

    parser.add_option('-V','--verbose',
                      action='store',
                      dest='verbosity',
                      choices=["quiet","normal","debug"],
                      default="normal",
                      help='the verbosity level to execute at')

    (options,args) = parser.parse_args()

    #get the AudioFile class we are converted to
    AudioType = audiotools.TYPE_MAP[options.type]

    if (options.add_replay_gain is None):
        options.add_replay_gain = AudioType.lossless_replay_gain()

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            print >>sys.stderr,"*** Available compression types for %s:" % \
                  (AudioType.NAME)
            for mode in AudioType.COMPRESSION_MODES:
                print >>sys.stderr,mode
        else:
            print >>sys.stderr,"*** Audio type %s has no compression modes" % \
                  (AudioType.NAME)
        sys.exit(0)
    elif (options.quality == None):
        options.quality = AudioType.DEFAULT_COMPRESSION
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        print >>sys.stderr,"*** \"%s\" is not a supported compression " % \
              (options.quality) + "mode for type \"%s\"" % \
              (AudioType.NAME)
        sys.exit(1)


    #if we're using an XMCD file, use that file for MetaData
    if (options.xmcd != None):
        try:
            xmcd = audiotools.XMCD.read(options.xmcd).metadata()
        except audiotools.XMCDException:
            print sys.stderr,"*** Invalid XMCD file"
            sys.exit(1)
    else: #if we're not using an XMCD file, no MetaData
        xmcd = None

    quality = options.quality
    base_directory = options.dir

    try:
        cdda = audiotools.CDDA(options.cdrom,options.speed)
    except IOError, err:
        print >>sys.stderr,"***", str(err) +". Is that an audio cd ?"
        sys.exit(-1)

    if (len(cdda) == 0xFF):
        print >>sys.stderr,"*** No CD in drive"
        sys.exit(1)

    encoded = []

    if (len(args) == 0):
        to_rip = [track for track in cdda]
    else:
        to_rip = []
        for arg in args:
            try:
                to_rip.append(cdda[int(arg)])
            except IndexError:
                continue
            except ValueError:
                continue
        to_rip.sort(lambda x,y: cmp(x.track_number,y.track_number))

    for cd_track in to_rip:
        try:
            if (xmcd != None):  #we have metadata
                try:
                    metadata = xmcd[cd_track.track_number]
                    if (options.album_number != 0):
                        metadata.album_number = options.album_number
                except KeyError:
                    metadata = None

                filename = os.path.join(
                    base_directory,
                    AudioType.track_name(cd_track.track_number,
                                         track_metadata=metadata,
                                         album_number=options.album_number,
                                         format=options.format))

                audiotools.make_dirs(filename)

                track = AudioType.from_pcm(
                    filename,
                    cd_track,
                    quality)

                track.set_metadata(metadata)
                encoded.append(track)
            else:               #no metadata
                filename = os.path.join(
                    base_directory,
                    AudioType.track_name(cd_track.track_number,
                                         track_metadata=None,
                                         album_number=options.album_number,
                                         format=options.format))

                audiotools.make_dirs(filename)

                track = AudioType.from_pcm(
                    filename,
                    cd_track,
                    quality)

                #even if no MetaData is given,
                #set track number and album number if possible
                track.set_metadata(audiotools.MetaData(
                        track_number=cd_track.track_number,
                        album_number=options.album_number))

                encoded.append(track)

            if (options.verbosity != 'quiet'):
                print "track %2.2d: %s" % (cd_track.track_number,
                                           str(cd_track.rip_log))
                print (u"track %2.2d -> %s" % (cd_track.track_number,
                                               track.filename.decode(
                            audiotools.FS_ENCODING))).encode(
                    audiotools.IO_ENCODING)
        except audiotools.UnsupportedTracknameField,msg:
            sys.stderr.write(unicode(msg).encode(audiotools.IO_ENCODING))
            sys.exit(1)
        except KeyError:
            continue
        except audiotools.InvalidFormat,msg:
            print >>sys.stderr,"*** %2.2d: %s" % (cd_track.track_number,
                                                  str(msg))
            continue

    if (options.add_replay_gain and AudioType.can_add_replay_gain()):
        if (options.verbosity != 'quiet'):
            if (AudioType.lossless_replay_gain()):
                print >>sys.stderr,"* Adding ReplayGain metadata.  This may take some time."
            else:
                print >>sys.stderr,"* Applying ReplayGain.  This may take some time."
        AudioType.add_replay_gain([track.filename for track in encoded])

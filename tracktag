#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import audiotools
import audiotools.ui
import os.path
import gettext

gettext.install("audiotools", unicode=True)

if (audiotools.ui.AVAILABLE):
    urwid_present = True
    urwid = audiotools.ui.urwid

    class Tracktag(urwid.Pile):
        def __init__(self, tracks):
            self.status = urwid.Text(u"")

            #a dict of track_id -> (AudioFile, MetaData) values
            self.edited_tracks = {}
            track_data = []
            for track in tracks:
                filename = audiotools.Filename(track.filename)
                metadata = track.get_metadata()
                self.edited_tracks[filename] = (track, metadata)
                track_data.append((filename,
                                   unicode(filename.basename()),
                                   metadata))

            self.metadata = audiotools.ui.MetaDataEditor(track_data,
                                                         self.changed,
                                                         self.swiveled)

            self.save_button = urwid.Button("Apply", on_press=self.save)
            cancel = urwid.Button("Quit", on_press=self.exit)

            urwid.Pile.__init__(
                self,
                [("weight", 1, self.metadata),
                 ("fixed", 1, urwid.Filler(urwid.Divider(u"\u2500"))),
                 ("fixed", 1, urwid.Filler(urwid.GridFlow([self.save_button,
                                                           cancel],
                                                          10, 5, 1, 'center'))),
                 ("fixed", 1, urwid.Filler(self.status))])

            self.modified = False

        def unhandled_input(self, i):
            if (i == 'esc'):
                raise urwid.ExitMainLoop()
            elif (i == 'f1'):
                self.metadata.select_previous_item()
            elif (i == 'f2'):
                self.metadata.select_next_item()

        def save(self, button, arg=None):
            if (self.modified):
                self.status.set_text(u"updating tracks")
                self.draw_screen()

                total = 0
                for (track_id, updated_metadata) in self.metadata.metadata():
                    (track, original_metadata) = self.edited_tracks[track_id]
                    if (updated_metadata != original_metadata):
                        for attr in audiotools.MetaData.FIELDS:
                            original_value = getattr(original_metadata, attr)
                            updated_value = getattr(updated_metadata, attr)
                            if (original_value != updated_value):
                                #if updated_value is None,
                                #this will work like delattr
                                setattr(original_metadata,
                                        attr,
                                        updated_value)

                        #FIXME - check for errors here
                        track.update_metadata(original_metadata)
                        total += 1

                if (total != 1):
                    self.status.set_text(u"%d tracks updated" % (total))
                else:
                    self.status.set_text(u"%d track updated" % (total))

                self.save_button.set_label(u"Apply")
                self.modified = False

        def exit(self, button, arg=None):
            raise urwid.ExitMainLoop()

        def changed(self, widget, new_text):
            self.save_button.set_label(('modified', u"Apply"))
            self.status.set_text(u"")
            self.modified = True

        def swiveled(self, radio_button, selected, swivel):
            if (selected):
                keys = []
                if (radio_button.previous_radio_button() is not None):
                    keys.extend([('key', u"F1"),
                                 u" - previous %s" % (swivel.swivel_type)])
                if (radio_button.next_radio_button() is not None):
                    if (len(keys) > 0):
                        keys.append(u"   ")
                    keys.extend([('key', u"F2"),
                                 u" - next %s" % (swivel.swivel_type)])

                if (len(keys) > 0):
                    self.status.set_text(keys)
                else:
                    self.status.set_text(u"")

else:
    urwid_present = False


#tries to return a populated Image object of the appropriate type
#raises InvalidImage if something goes wrong during opening or parsing
def get_raw_image(filename, type):
    try:
        f = open(filename, 'rb')
        data = f.read()
        f.close()

        return audiotools.Image.new(data, u'', type)
    except IOError:
        raise audiotools.InvalidImage(_(u"Unable to open file"))


def get_thumbnailed_image(filename, type):
    image = get_raw_image(filename, type)
    if ((image.width > audiotools.THUMBNAIL_SIZE) or
        (image.height > audiotools.THUMBNAIL_SIZE)):
        return image.thumbnail(audiotools.THUMBNAIL_SIZE,
                               audiotools.THUMBNAIL_SIZE,
                               audiotools.THUMBNAIL_FORMAT)
    else:
        return image


#given a comment filename
#returns the comment as a unicode string
#or exits with an error if the file cannot be read
#or is not UTF-8 text
def read_comment(filename, messenger):
    try:
        f = open(filename, 'rb')
        data = f.read().decode('utf-8', 'replace')
        f.close()

        if (((data.count(u"\uFFFD") * 100) / len(data)) >= 10):
            messenger.error(
                _(u"Comment file \"%s\" does not appear to be UTF-8 text") %
                (audiotools.Filename(filename),))
            sys.exit(1)
        else:
            return data
    except IOError:
        messenger.error(_(u"Unable to open comment file \"%s\"") %
                        (audiotools.Filename(filename),))
        sys.exit(1)


if (__name__ == '__main__'):
    #add an enormous number of options to the parser
    #neatly categorized for convenience
    parser = audiotools.OptionParser(
        usage=_(u"%prog [options] <track 1> [track 2] ..."),
        version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option(
        '-I', '--interactive',
        action='store_true',
        default=False,
        dest='interactive',
        help=_(u'run in interactive mode'))

    text_group = audiotools.OptionGroup(parser, _(u"Text Options"))

    for (option, destination, helptext) in [
        ('--name', 'track_name', _(u"the name of the track")),
        ('--artist', 'artist_name', _(u'the name of the artist')),
        ('--performer', 'performer_name', _(u'the name of the performer')),
        ('--composer', 'composer_name', _(u'the name of the composer')),
        ('--conductor', 'conductor_name', _(u'the name of the conductor')),
        ('--album', 'album_name', _(u'the name of the album')),
        ('--catalog', 'catalog', _(u'the catalog number of the album')),
        ('--number', 'track_number',
         _(u"the number of the track in the album")),
        ('--track-total', 'track_total',
         _(u"the total number of tracks in the album")),
        ('--album-number', 'album_number',
         _(u'the number of the album in a set of albums')),
        ('--album-total', 'album_total',
         _(u"the total number of albums in a set of albums")),
        ('--ISRC', 'ISRC', _(u'the ISRC of the track')),
        ('--publisher', 'publisher', _(u'the publisher of the album')),
        ('--media-type', 'media_type',
         _(u'the media type of the album, such as "CD"')),
        ('--year', 'year', _(u'the year of release')),
        ('--date', 'date', _(u'the date of recording')),
        ('--copyright', 'copyright', _(u'copyright information')),
        ('--comment', 'comment', _(u'a text comment'))]:
        if (destination not in audiotools.MetaData.INTEGER_FIELDS):
            text_group.add_option(option,
                                  action='store',
                                  type='string',
                                  dest=destination,
                                  help=helptext)
        else:
            text_group.add_option(option,
                                  action='store',
                                  type='int',
                                  dest=destination,
                                  help=helptext)

    text_group.add_option(
        '--comment-file',
        action='store',
        type='string',
        dest='comment_file',
        metavar='FILENAME',
        help=_(u'a file containing comment text'))

    parser.add_option_group(text_group)

    parser.add_option(
        '-r', '--replace',
        action='store_true',
        default=False,
        dest='replace',
        help=_(u'completely replace all metadata'))

    parser.add_option(
        '--cue',
        action='store',
        type='string',
        dest='cue',
        metavar='FILENAME',
        help=_(u'a cuesheet to import or get audio metadata from'))

    img_group = audiotools.OptionGroup(parser, _(u"Image Options"))

    img_group.add_option(
        '--remove-images',
        action='store_true',
        default=False,
        dest='remove_images',
        help=_(u'remove existing images prior to adding new ones'))

    for (option, destination, helptext) in [
        ('--front-cover', 'front_cover',
         _(u'an image file of the front cover')),
        ('--back-cover', 'back_cover',
         _(u'an image file of the back cover')),
        ('--leaflet', 'leaflet', _(u'an image file of a leaflet page')),
        ('--media', 'media', _(u'an image file of the media')),
        ('--other-image', 'other_image',
         _(u'an image file related to the track'))]:
        img_group.add_option(
            option,
            action='append',
            type='string',
            dest=destination,
            metavar='FILENAME',
            help=helptext)

    img_group.add_option(
        '-T', '--thumbnail',
        action='store_true',
        default=False,
        dest='thumbnail',
        help=_(u'convert given images to smaller thumbnails ' +
               u'before adding'))

    parser.add_option_group(img_group)

    remove_group = audiotools.OptionGroup(parser, _(u"Removal Options"))

    for (option, destination, helptext) in [
        ('--remove-name', 'remove_track_name', _(u'remove track name')),
        ('--remove-artist', 'remove_artist_name', _(u'remove track artist')),
        ('--remove-performer', 'remove_performer_name',
         _(u'remove track performer')),
        ('--remove-composer', 'remove_composer_name',
         _(u'remove track composer')),
        ('--remove-conductor', 'remove_conductor_name',
         _(u'remove track conductor')),
        ('--remove-album', 'remove_album_name', _(u'remove album name')),
        ('--remove-catalog', 'remove_catalog', _(u'remove catalog number')),
        ('--remove-number', 'remove_track_number',
         _(u'remove track number')),
        ('--remove-track-total', 'remove_track_total',
         _(u'remove total number of tracks')),
        ('--remove-album-number', 'remove_album_number',
         _(u'remove album number')),
        ('--remove-album-total', 'remove_album_total',
         _(u'remove total number of albums')),
        ('--remove-ISRC', 'remove_ISRC', _(u'remove ISRC')),
        ('--remove-publisher', 'remove_publisher', _(u'remove publisher')),
        ('--remove-media-type', 'remove_media_type',
         _(u'remove album\'s media type')),
        ('--remove-year', 'remove_year', _(u'remove release year')),
        ('--remove-date', 'remove_date', _(u'remove recording date')),
        ('--remove-copyright', 'remove_copyright',
         _(u'remove copyright information')),
        ('--remove-comment', 'remove_comment', _(u'remove text comment'))]:
        remove_group.add_option(
            option,
            action='store_true',
            default=False,
            dest=destination,
            help=helptext)

    parser.add_option_group(remove_group)

    parser.add_option(
        '--replay-gain',
        action='store_true',
        default=False,
        dest='add_replay_gain',
        help=_(u'add ReplayGain metadata to track(s)'))

    parser.add_option(
        '-j', '--joint',
        action='store',
        type='int',
        default=audiotools.MAX_JOBS,
        dest='max_processes',
        help=_(u'the maximum number of processes to run at a time'))

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=_(u'the verbosity level to execute at'))

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("tracktag", options)

    #open our set of input files for tagging
    try:
        audiofiles = audiotools.open_files(args,
                                           messenger=msg,
                                           no_duplicates=True)
    except audiotools.DuplicateFile, err:
        msg.error(u"File \"%s\" included more than once" %
                  (err.filename,))
        sys.exit(1)

    #and the --cue file
    isrcs = {}
    import_cuesheet = None
    if (options.cue is not None):
        try:
            cuesheet = audiotools.read_sheet(options.cue)

            #if there's a single audio file
            #and the cuesheet is sized to fit that file
            #attempt to embed the cuesheet in the file
            if ((len(audiofiles) == 1) and
                (list(cuesheet.pcm_lengths(
                            audiofiles[0].total_frames()))[-1] > 0)):
                import_cuesheet = cuesheet
            else:
                #otherwise, treat the cuesheet as a source of ISRC data
                isrcs = dict([(k, v.decode('ascii', 'replace'))
                              for (k, v) in
                              cuesheet.ISRCs().items()])
        except audiotools.SheetException, err:
            msg.error(unicode(err))
            sys.exit(1)

    if (options.thumbnail):
        if (not audiotools.can_thumbnail()):
            msg.error(_(u"Unable to generate thumbnails"))
            msg.info(
                _(u"Please install the Python Imaging Library"))
            msg.info(
                _(u"available at http://www.pythonware.com/products/pil/"))
            msg.info(_(u"to enable image resizing"))
            sys.exit(1)

        if (audiotools.THUMBNAIL_FORMAT.upper() not in
            audiotools.thumbnail_formats()):
            msg.error(_(u"Unsupported thumbnail format \"%s\"") %
                      (audiotools.THUMBNAIL_FORMAT))
            msg.info(_(u"Available formats are: %s") %
                     (", ".join(audiotools.thumbnail_formats())))
            sys.exit(1)

        get_image = get_thumbnailed_image
    else:
        get_image = get_raw_image

    for file in audiofiles:
        track_modified = False

        #determine which MetaData to use as our base
        #depending on whether we're performing a full replacement
        if (not options.replace):
            metadata = file.get_metadata()
            if (metadata is not None):
                update_method = "update_metadata"
            else:
                metadata = audiotools.MetaData()
                update_method = "set_metadata"
        else:
            metadata = audiotools.MetaData()
            update_method = "set_metadata"

        #apply tagging options to that metadata in reverse order of precedence

        #perform the image tagging
        try:
            if (metadata.supports_images()):
                if (options.remove_images):
                    for i in metadata.images():
                        metadata.delete_image(i)
                        track_modified = True

                if (options.front_cover is not None):
                    for path in options.front_cover:
                        metadata.add_image(get_image(path, 0))
                        track_modified = True

                if (options.leaflet is not None):
                    for path in options.leaflet:
                        metadata.add_image(get_image(path, 2))
                        track_modified = True

                if (options.back_cover is not None):
                    for path in options.back_cover:
                        metadata.add_image(get_image(path, 1))
                        track_modified = True

                if (options.media is not None):
                    for path in options.media:
                        metadata.add_image(get_image(path, 3))
                        track_modified = True

                if (options.other_image is not None):
                    for path in options.other_image:
                        metadata.add_image(get_image(path, 4))
                        track_modified = True
        except audiotools.InvalidImage, err:
            msg.error(_(u"%(filename)s: %(message)s") % \
                          {"filename": audiotools.Filename(file.filename),
                           "message": unicode(err)})
            sys.exit(1)

        #apply text field removal
        for field in ('track_name',
                      'artist_name',
                      'performer_name',
                      'composer_name',
                      'conductor_name',
                      'album_name',
                      'catalog',
                      'track_number',
                      'track_total',
                      'album_number',
                      'album_total',
                      'ISRC',
                      'publisher',
                      'media_type',
                      'year',
                      'date',
                      'copyright',
                      'comment'):
            if (getattr(options, 'remove_' + field)):
                delattr(metadata, field)
                track_modified = True

        if (options.track_number is not None):
            track_number = options.track_number
        else:
            track_number = file.track_number()

        #handle cuesheet ISRC data
        if (track_number in isrcs):
            metadata.ISRC = isrcs[track_number]
            track_modified = True

        #update fields from the command line
        for field in ('track_name',
                      'artist_name',
                      'performer_name',
                      'composer_name',
                      'conductor_name',
                      'album_name',
                      'catalog',
                      'track_number',
                      'track_total',
                      'album_number',
                      'album_total',
                      'ISRC',
                      'publisher',
                      'media_type',
                      'year',
                      'date',
                      'copyright',
                      'comment'):
            if (getattr(options, field) is not None):
                attr = getattr(options, field)
                if (isinstance(attr, str)):
                    attr = attr.decode(audiotools.IO_ENCODING, 'replace')
                setattr(metadata, field, attr)
                track_modified = True

        #add comment-file
        if (options.comment_file is not None):
            metadata.comment = read_comment(options.comment_file, msg)
            track_modified = True

        #check if there's been any modifications made
        if (track_modified or
            (import_cuesheet is not None) or
            options.replace):
            try:
                #either set or update metadata
                #depending on whether we're performing a full replacement
                getattr(file, update_method)(metadata)

                #insert embedded cuesheet file
                if (import_cuesheet is not None):
                    file.set_cuesheet(import_cuesheet)
            except IOError:
                msg.error(_(u"Unable to modify \"%s\"") %
                          (audiotools.Filename(file.filename),))
                sys.exit(1)

    #add/apply replay_gain to tracks if indicated
    if (options.add_replay_gain and (len(audiofiles) > 0)):
        queue = audiotools.ExecProgressQueue(
            audiotools.ProgressDisplay(msg))

        for album in audiotools.group_tracks(audiofiles):
            #add ReplayGain to groups of files
            #belonging to the same album

            album_number = set([t.album_number() for t in album]).pop()

            audio_type = album[0].__class__

            if (audio_type.can_add_replay_gain(album)):
                progress_text = \
                    (u"%s ReplayGain%s" %
                     ((u"Adding" if audio_type.lossless_replay_gain() else
                       u"Applying"),
                      (u"" if album_number is None else
                       (u" to album %d" % (album_number)))))

                completion_output = \
                    (u"ReplayGain %s%s" %
                     ((u"added" if audio_type.lossless_replay_gain() else
                       u"applied"),
                      (u"" if album_number is None else
                       (u" to album %d" % (album_number)))))

                queue.execute(audio_type.add_replay_gain,
                              progress_text,
                              completion_output,
                              [a.filename for a in album])

        try:
            queue.run(options.max_processes)
        except ValueError, err:
            msg.error(unicode(err))
            sys.exit(1)

    #finally, after all the command-line arguments are processed
    #run interactive mode if indicated
    if (options.interactive):
        if (not urwid_present):
            audiotools.ui.not_available_message(msg)
            sys.exit(1)

        tracktag = Tracktag(audiofiles)
        loop = urwid.MainLoop(tracktag,
                              [('label', 'default,bold', 'default'),
                               ('key', 'white', 'dark blue'),
                               ('modified', 'default,bold', 'default', '')],
                              unhandled_input=tracktag.unhandled_input)
        tracktag.draw_screen = loop.draw_screen
        loop.run()

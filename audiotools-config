#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys


def check_binaries(msg, binary_list):
    from audiotools import BIN
    import audiotools.text as _

    for binary in binary_list:
        msg.new_row()
        if (BIN.can_execute(audiotools.BIN[binary])):
            msg.output_column(u"+ ")
            msg.output_column(_.LAB_AT_CONFIG_FOUND, True)
            msg.output_column(u" : ")
            msg.output_column(binary.decode('ascii'))
        else:
            msg.output_column(u"- ")
            msg.output_column(_.LAB_AT_CONFIG_NOT_FOUND, True)
            msg.output_column(u" : ")
            msg.output_column(binary.decode('ascii'))
    msg.output_rows()


class FormatSummary:
    def __init__(self, format, quality, binaries, replaygain):
        """format and quality are unicode.  The rest are list of unicode.

        All should be formatted for output."""

        self.format = format
        self.quality = quality
        self.binaries = binaries
        self.replaygain = replaygain

    @classmethod
    def headers(cls, messenger):
        import audiotools.text as _

        messenger.new_row()
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")
        messenger.output_column(u" default ")
        messenger.output_column(u" ")
        messenger.output_column(u" ")

        messenger.new_row()
        messenger.output_column(_.LAB_AT_CONFIG_TYPE)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_BINARIES)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_QUALITY)
        messenger.output_column(u" ")
        messenger.output_column(_.LAB_AT_CONFIG_REPLAY_GAIN)
        messenger.divider_row([u"-", u"+", u"-",
                                   u"+", u"-", u"+", u"-"])

    def output_rows(self, messenger):
        #first, put our rows of data into lists of columns

        format_col = [self.format]
        quality_col = [self.quality]
        binaries_col = self.binaries[:]
        replaygain_col = self.replaygain[:]

        #then, make our columns consistently-sized
        total_rows = max(map(len, [format_col,
                                   quality_col,
                                   binaries_col,
                                   replaygain_col]))

        for col in [format_col, quality_col, binaries_col, replaygain_col]:
            col.extend([u""] * (total_rows - len(col)))

        #finally, output our rows to the Messenger
        for (format, quality, binary, replaygain) in zip(format_col,
                                                         quality_col,
                                                         binaries_col,
                                                         replaygain_col):
            messenger.new_row()
            messenger.output_column(u" %s " % (format), True)
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (binary))
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (quality))
            messenger.output_column(u"|")
            messenger.output_column(u" %s " % (replaygain))
        messenger.divider_row([u"-", u"+", u"-",
                               u"+", u"-", u"+", u"-"])

    @classmethod
    def from_audiofile(cls, messenger, audiofile, binaries):
        if (audiofile.has_binaries(binaries)):
            code = [messenger.FG_GREEN]
        else:
            code = [messenger.FG_RED]

        if (audiofile.NAME == audiotools.DEFAULT_TYPE):
            code.append(messenger.BOLD)
            code.append(messenger.UNDERLINE)

        format = messenger.ansi(audiofile.NAME.decode('ascii'), code)

        binaries_list = []
        for binary in audiofile.BINARIES:
            if (binaries.can_execute(binaries[binary])):
                code = [messenger.FG_GREEN]
            else:
                code = [messenger.FG_RED]
            binaries_list.append(messenger.ansi(binaries[binary], code))

        replaygain = []
        if (len(audiofile.REPLAYGAIN_BINARIES) > 0):
            for binary in audiofile.REPLAYGAIN_BINARIES:
                if (binaries.can_execute(binaries[binary])):
                    code = [messenger.FG_GREEN]
                else:
                    code = [messenger.FG_RED]
                replaygain.append(messenger.ansi(binaries[binary], code))
        elif (audiofile.supports_replay_gain()):
            replaygain.append(messenger.ansi("YES", [messenger.FG_GREEN]))
        else:
            replaygain.append("N/A")

        return cls(format,
                   audiotools.__default_quality__(
                audiofile.NAME).decode('ascii'),
                   binaries_list,
                   replaygain)


if (__name__ == '__main__'):
    #There's no good way to make these dynamic
    #since the configurable text comes from the audiotools.text module
    #which we can't load because the module isn't installed correctly.
    try:
        import audiotools
    except ImportError:
        print "* audiotools Python module not found!"
        print "Perhaps you should re-install the Python Audio Tools"
        sys.exit(1)
    try:
        import audiotools.player
    except ImportError:
        print "* audiotools.player Python module not found!"
        print "Perhaps you should re-install the Python Audio Tools"
        sys.exit(1)

    import audiotools.text as _

    parser = audiotools.OptionParser(
        usage=_.USAGE_AT_CONFIG,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    opt_map = {"system_cdrom": ("System", "cdrom"),
               "system_cdrom_read_offset": ("System", "cdrom_read_offset"),
               "system_cdrom_write_offset": ("System", "cdrom_write_offset"),
               "system_fs_encoding": ("System", "fs_encoding"),
               "system_io_encoding": ("System", "io_encoding"),
               "system_maximum_jobs": ("System", "maximum_jobs"),

               "freedb_server": ("FreeDB", "server"),
               "freedb_port": ("FreeDB", "port"),
               "use_freedb": ("FreeDB", "service"),

               "musicbrainz_server": ("MusicBrainz", "server"),
               "musicbrainz_port": ("MusicBrainz", "port"),
               "use_musicbrainz": ("MusicBrainz", "service"),

               "filename_format": ("Filenames", "format"),
               "verbosity": ("Defaults", "verbosity"),

               "id3_digit_padding": ("ID3", "pad"),
               "id3v2_version": ("ID3", "id3v2"),
               "id3v1_version": ("ID3", "id3v1"),
               "add_replaygain": ("ReplayGain", "add_by_default")}

    system = audiotools.OptionGroup(parser, _.OPT_CAT_SYSTEM)

    system.add_option('-c', '--cdrom',
                      action='store',
                      dest='system_cdrom',
                      metavar='PATH')

    system.add_option('--cdrom-read-offset',
                      action='store',
                      type='int',
                      metavar='INT',
                      dest='system_cdrom_read_offset',
                      help=_.OPT_AT_CONFIG_READ_OFFSET)

    system.add_option('--cdrom-write-offset',
                      action='store',
                      type='int',
                      metavar='INT',
                      dest='system_cdrom_write_offset',
                      help=_.OPT_AT_CONFIG_WRITE_OFFSET)

    system.add_option(
        '--fs-encoding',
        action='store',
        metavar='ENCODING',
        dest='system_fs_encoding',
        help=_.OPT_AT_CONFIG_FS_ENCODING)

    system.add_option(
        '--io-encoding',
        action='store',
        metavar='ENCODING',
        dest='system_io_encoding',
        help=_.OPT_AT_CONFIG_IO_ENCODING)

    parser.add_option_group(system)

    transcoding = audiotools.OptionGroup(parser, _.OPT_CAT_TRANSCODING)

    transcoding.add_option(
        '-t', '--type',
        action='store',
        dest='type',
        choices=audiotools.TYPE_MAP.keys(),
        help=_.OPT_TYPE_AT_CONFIG)

    transcoding.add_option(
        '-q', '--quality',
        action='store',
        type='string',
        dest='quality',
        help=_.OPT_QUALITY_AT_CONFIG)

    transcoding.add_option(
        '-j', '--joint',
        action='store',
        type='int',
        metavar='MAX_PROCESSES',
        dest='system_maximum_jobs',
        help=_.OPT_JOINT)

    parser.add_option_group(transcoding)

    lookup = audiotools.OptionGroup(parser, _.OPT_CAT_CD_LOOKUP)

    lookup.add_option(
        '--use-freedb',
        metavar='yes/no',
        choices=("yes", "no"),
        dest='use_freedb')

    lookup.add_option(
        '--freedb-server',
        action='store',
        metavar='HOSTNAME',
        dest='freedb_server')

    lookup.add_option(
        '--freedb-port',
        action='store',
        metavar='PORT',
        type='int',
        dest='freedb_port')

    lookup.add_option(
        '--use-musicbrainz',
        metavar='yes/no',
        choices=("yes", "no"),
        dest='use_musicbrainz')

    lookup.add_option(
        '--musicbrainz-server',
        action='store',
        metavar='HOSTNAME',
        dest='musicbrainz_server')

    lookup.add_option(
        '--musicbrainz-port',
        action='store',
        metavar='PORT',
        type='int',
        dest='musicbrainz_port')

    parser.add_option_group(lookup)

    id3 = audiotools.OptionGroup(parser, _.OPT_CAT_ID3)

    id3.add_option(
        '--id3v2-version',
        action='store',
        type='choice',
        choices=('id3v2.2', 'id3v2.3', 'id3v2.4', 'none'),
        dest='id3v2_version',
        metavar='VERSION',
        help=_.OPT_AT_CONFIG_ID3V2_VERSION)

    id3.add_option(
        '--id3v1-version',
        action='store',
        type='choice',
        choices=('id3v1.1', 'none'),
        dest='id3v1_version',
        metavar='VERSION',
        help=_.OPT_AT_CONFIG_ID3V1_VERSION)

    id3.add_option(
        '--id3v2-pad',
        action='store',
        type='choice',
        choices=('true', 'false'),
        dest='id3_digit_padding',
        metavar='true / false',
        help=_.OPT_AT_CONFIG_ID3V2_PAD)

    parser.add_option_group(id3)

    replaygain = audiotools.OptionGroup(parser, _.OPT_CAT_REPLAYGAIN)

    replaygain.add_option(
        '--replay-gain',
        action='store',
        type='choice',
        choices=('yes', 'no'),
        dest='add_replaygain',
        metavar='yes / no',
        help=_.OPT_REPLAY_GAIN)

    parser.add_option_group(replaygain)

    binaries = audiotools.OptionGroup(parser, _.OPT_CAT_BINARIES)

    bins = set([])
    for audioclass in audiotools.AVAILABLE_TYPES:
        for binary in audioclass.BINARIES:
            bins.add(binary)

    for binary in sorted(list(bins)):
        binaries.add_option('--' + binary,
                            action='store',
                            metavar='PATH',
                            dest='binary_' + binary)
        opt_map["binary_" + binary] = ("Binaries", binary)

    parser.add_option_group(binaries)

    parser.add_option(
        '--format',
        action='store',
        metavar='FORMAT',
        dest='filename_format',
        help=_.OPT_FORMAT)

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=_.OPT_VERBOSE_AT_CONFIG)

    (options, args) = parser.parse_args()

    msg = audiotools.Messenger("audiotools-config", None)

    if (len(sys.argv) < 2):
        FormatSummary.headers(msg)
        for audiotype in sorted(audiotools.AVAILABLE_TYPES,
                                lambda x, y: cmp(x.NAME, y.NAME)):
            FormatSummary.from_audiofile(
                msg, audiotype, audiotools.BIN).output_rows(msg)
        msg.output_rows()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CD_BURNING, True)
        msg.output_column(u" : ")
        burning_options = []
        if (audiotools.BIN.can_execute(audiotools.BIN["cdrecord"])):
            burning_options.append(_.LAB_AT_CONFIG_WITHOUT_CUE)
        if (audiotools.BIN.can_execute(audiotools.BIN["cdrdao"])):
            burning_options.append(_.LAB_AT_CONFIG_WITH_CUE)
        if (len(burning_options) == 0):
            burning_options.append(_.LAB_AT_CONFIG_NO)
        msg.output_column(u", ".join([s.decode('ascii')
                                      for s in burning_options]))
        msg.output_rows()
        check_binaries(msg, ["cdrecord", "cdrdao"])

        msg.output(u"-" * 30)

        msg.output(_.LAB_AT_CONFIG_SYS_CONFIG)
        msg.output(u"")

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_USE_MUSICBRAINZ, True)
        msg.output_column(u" : ")
        msg.output_column({True: _.LAB_AT_CONFIG_YES,
                           False: _.LAB_AT_CONFIG_NO}[
                audiotools.MUSICBRAINZ_SERVICE])

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_MUSICBRAINZ_SERVER, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.MUSICBRAINZ_SERVER.decode('ascii',
                                                               'replace'))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_MUSICBRAINZ_PORT, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.MUSICBRAINZ_PORT))
        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_USE_FREEDB, True)
        msg.output_column(u" : ")
        msg.output_column({True: _.LAB_AT_CONFIG_YES,
                           False: _.LAB_AT_CONFIG_NO}[audiotools.FREEDB_SERVICE])

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FREEDB_SERVER, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.FREEDB_SERVER.decode('ascii',
                                                          'replace'))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FREEDB_PORT, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.FREEDB_PORT))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_DEFAULT_CDROM, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.DEFAULT_CDROM.decode(
                audiotools.FS_ENCODING))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CDROM_READ_OFFSET, True)
        msg.output_column(u" : ")
        msg.output_column(
            unicode(audiotools.config.getint_default("System",
                                                     "cdrom_read_offset", 0)))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_CDROM_WRITE_OFFSET, True)
        msg.output_column(u" : ")
        msg.output_column(
            unicode(audiotools.config.getint_default("System",
                                                     "cdrom_write_offset", 0)))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_JOBS, True)
        msg.output_column(u" : ")
        msg.output_column(unicode(audiotools.MAX_JOBS))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_VERBOSITY, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.DEFAULT_VERBOSITY.decode('ascii'))

        output_options = []
        for player in audiotools.player.AUDIO_OUTPUT:
            if (player.available()):
                if (len(output_options) == 0):
                    output_options.append(msg.ansi(player.NAME.decode('ascii'),
                                                   [msg.BOLD,
                                                    msg.UNDERLINE]))
                else:
                    output_options.append(player.NAME.decode('ascii'))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_AUDIO_OUTPUT, True)
        msg.output_column(u" : ")
        msg.output_column(u", ".join(output_options))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_FS_ENCODING, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.FS_ENCODING.decode('ascii'))

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_IO_ENCODING, True)
        msg.output_column(u" : ")
        msg.output_column(audiotools.IO_ENCODING.decode('ascii'))

        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V2_VERSION, True)
        msg.output_column(u" : ")
        msg.output_column({"id3v2.2":_.LAB_AT_CONFIG_ID3V2_ID3V22,
                           "id3v2.3":_.LAB_AT_CONFIG_ID3V2_ID3V23,
                           "id3v2.4":_.LAB_AT_CONFIG_ID3V2_ID3V24,
                           "none":_.LAB_AT_CONFIG_ID3V2_NONE}.get(
                audiotools.config.get_default("ID3", "id3v2", "id3v2.3"),
                u"ID3v2.3"))
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V2_PADDING, True)
        msg.output_column(u" : ")
        msg.output_column({True:_.LAB_AT_CONFIG_ID3V2_PADDING_YES,
                           False:_.LAB_AT_CONFIG_ID3V2_PADDING_NO}[
                audiotools.config.getboolean_default("ID3", "pad", False)])
        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ID3V1_VERSION, True)
        msg.output_column(u" : ")
        msg.output_column({"id3v1.1":_.LAB_AT_CONFIG_ID3V1_ID3V11,
                           "none":_.LAB_AT_CONFIG_ID3V1_NONE}.get(
                audiotools.config.get_default("ID3", "id3v1", "id3v1.1"),
                u"ID3v1.1"))
        msg.blank_row()

        msg.new_row()
        msg.output_column(_.LAB_AT_CONFIG_ADD_REPLAY_GAIN, True)
        msg.output_column(u" : ")
        msg.output_column({True: _.LAB_AT_CONFIG_YES,
                           False: _.LAB_AT_CONFIG_NO}[audiotools.ADD_REPLAYGAIN])

        msg.blank_row()
        msg.output_rows()

        msg.output(_.LAB_AT_CONFIG_FORMAT %
                   (audiotools.FILENAME_FORMAT.decode('ascii', 'replace')))
    else:
        import os.path

        config = audiotools.config
        for attr in dir(options):
            if ((not attr.startswith('_')) and
                (not callable(getattr(options, attr))) and
                (getattr(options, attr) is not None)):
                if (attr in opt_map):
                    (section, option) = opt_map[attr]
                    if (not config.has_section(section)):
                        config.add_section(section)
                    config.set(section, option, getattr(options, attr))

        if (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]

            if (options.quality is not None):
                if (options.quality == 'help'):
                    if (len(AudioType.COMPRESSION_MODES) > 1):
                        msg.info(_.LAB_AVAILABLE_COMPRESSION_TYPES %
                                 (AudioType.NAME))
                        for mode in AudioType.COMPRESSION_MODES:
                            msg.new_row()
                            if (mode == audiotools.__default_quality__(
                                    AudioType.NAME)):
                                msg.output_column(
                                    msg.ansi(mode.decode('ascii'),
                                             [msg.BOLD, msg.UNDERLINE]), True)
                            else:
                                msg.output_column(mode.decode('ascii'), True)
                            if (mode in AudioType.COMPRESSION_DESCRIPTIONS):
                                msg.output_column(u" : ")
                            else:
                                msg.output_column(u"   ")
                            msg.output_column(
                                AudioType.COMPRESSION_DESCRIPTIONS.get(mode,
                                                                       u""))
                        msg.info_rows()
                    else:
                        msg.error(
                            _.ERR_NO_COMPRESSION_MODES %
                            (AudioType.NAME))
                    sys.exit(0)
                elif (options.quality not in AudioType.COMPRESSION_MODES):
                    msg.error(
                        _.ERR_UNSUPPORTED_COMPRESSION_MODE %
                        {"quality": options.quality,
                         "type": AudioType.NAME})
                    sys.exit(1)

                #we're setting the quality level for a given type
                if (not config.has_section("Quality")):
                    config.add_section("Quality")
                config.set("Quality", options.type, options.quality)
            else:
                #we're setting the default type
                if (not config.has_section("System")):
                    config.add_section("System")
                config.set("System", "default_type", options.type)

        configpath = os.path.expanduser('~/.audiotools.cfg')
        configfile = open(configpath, 'w')
        config.write(configfile)
        configfile.close()
        msg.info(_.LAB_AT_CONFIG_FILE_WRITTEN %
                 (audiotools.Filename(configpath),))

#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import audiotools
import optparse,sys,os,os.path

MAX_CPUS = audiotools.MAX_JOBS

def convert_file(destination_class, destination_filename,
                 source_audiofile, metadata, compression,
                 display_output=True, thumbnail_images=False):
    if (display_output):
        print (u"%s -> %s" % \
               (source_audiofile.filename.decode(audiotools.FS_ENCODING),
                destination_filename.decode(audiotools.FS_ENCODING))).encode(
            audiotools.IO_ENCODING)

    try:
        if (isinstance(source_audiofile,audiotools.WaveAudio)):
            #if we're converting from a WAVE file, use from_wave()
            destination_audiofile = destination_class.from_wave(
                destination_filename,
                source_audiofile.filename,
                compression)
        elif (destination_class == audiotools.WaveAudio):
            #if we're converting to a WAVE file, use to_wave()
            source_audiofile.to_wave(destination_filename)
            destination_audiofile = audiotools.WaveAudio(destination_filename)

        elif ((source_audiofile.supports_foreign_riff_chunks()) and
              (destination_class.supports_foreign_riff_chunks())):
            #if both the source and target classes support foreign chunks
            #route the data through a temporary WAVE file
            import tempfile

            temp_wave = tempfile.NamedTemporaryFile(suffix='.wav')
            try:
                source_audiofile.to_wave(temp_wave.name)
                destination_audiofile = destination_class.from_wave(
                    destination_filename,
                    temp_wave.name,
                    compression)
            finally:
                temp_wave.close()

        else:
            #otherwise, route the data through PCM
            destination_audiofile = destination_class.from_pcm(
                destination_filename,
                source_audiofile.to_pcm(),
                compression)

        if (metadata is not None):
            if (thumbnail_images):
                for img in metadata.images():
                    metadata.delete_image(img)
                    metadata.add_image(img.thumbnail(
                            audiotools.THUMBNAIL_SIZE,
                            audiotools.THUMBNAIL_SIZE,
                            audiotools.THUMBNAIL_FORMAT))

            destination_audiofile.set_metadata(metadata)
        else:
            destination_audiofile.set_metadata(audiotools.MetaData(
                    track_number=source_audiofile.track_number(),
                    album_number=source_audiofile.album_number()))

    except audiotools.InvalidFormat,msg:
        print >>sys.stderr,(u"*** %s: %s" % \
                            (source_audiofile.filename.decode(
                             audiotools.FS_ENCODING),
                             str(msg))).encode(audiotools.IO_ENCODING)

if (__name__ == '__main__'):
    parser = optparse.OptionParser(
        '%prog [-t track type ] [-x XMCD file] ' + \
        '[-d directory] [-q quality] ' + \
        '<track 1> [track 2] ...',
        version="Python Audio Tools %s" % (audiotools.VERSION))

    parser.add_option('-t','--type',
                      action='store',
                      dest='type',
                      choices=audiotools.TYPE_MAP.keys(),
                      help='the type of audio value to convert to')

    parser.add_option('-q','--quality',
                      action='store',
                      type='string',
                      dest='quality',
                      help='the quality to store audio values at')

    parser.add_option('-x','--xmcd',
                      action='store',
                      type='string',
                      dest='xmcd',
                      help='an XMCD file to get audio metadata from')

    parser.add_option('-d','--dir',
                      action='store',
                      type='string',
                      dest='dir',
                      default='.',
                      help='the directory to store converted audio files')

    parser.add_option('--format',
                      action='store',
                      type='string',
                      default=audiotools.FILENAME_FORMAT,
                      dest='format',
                      help='the format string for new filenames')

    parser.add_option('-o','--output',
                      action='store',
                      dest='output',
                      help='output filename to use, overriding default and -d')

    parser.add_option('--album-number',
                      dest='album_number',
                      action='store',
                      type='int',
                      default=None,
                      help='the album number, if these tracks are one of a series of albums')

    parser.add_option('-j','--joint',
                      action='store',
                      type='int',
                      default=MAX_CPUS,
                      dest='max_processes',
                      help='the maximum number of processes to run at a time')

    parser.add_option('-T','--thumbnail',
                      action='store_true',
                      default=False,
                      dest='thumbnail',
                      help='convert embedded images to smaller thumbnails during conversion')


    #if adding ReplayGain is a lossless process
    #(i.e. added as tags rather than modifying track data)
    #add_replay_gain should default to True
    #if not, add_replay_gain should default to False
    #which is which depends on the track type
    parser.add_option('--replay-gain',
                      action='store_true',
                      dest='add_replay_gain',
                      help='add ReplayGain metadata to newly created tracks')

    parser.add_option('--no-replay-gain',
                      action='store_false',
                      dest='add_replay_gain',
                      help='do not add ReplayGain metadata to newly created tracks')

    (options,args) = parser.parse_args()

    #if one specifies incompatible output options,
    #complain about it right away
    if (options.output is not None):
        if (options.dir != "."):
            print >>sys.stderr,"*** -o and -d options are not compatible"
            print >>sys.stderr,"*** please specify the full output file path with -o"
            print >>sys.stderr,"*** or an output directory with -d"
            print >>sys.stderr,"*** but not both"
            sys.exit(1)

        if (options.format is not None):
            print >>sys.stderr,"* warning: --format has no effect when used with -o"

    #get the AudioFile class we are converted to
    if (options.output is None):
        if (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]
        else:
            AudioType = audiotools.TYPE_MAP['wav']
    else:
        if (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]
        else:
            (path,ext) = os.path.splitext(options.output)
            if (len(ext) > 0):
                ext = ext[1:]   #remove the "."
                SUFFIX_MAP = {}
                for audio_type in audiotools.TYPE_MAP.values():
                    SUFFIX_MAP.setdefault(audio_type.SUFFIX,[]).append(
                        audio_type)
                if (ext in SUFFIX_MAP.keys()):
                    if (len(SUFFIX_MAP[ext]) == 1):
                        AudioType = SUFFIX_MAP[ext][0]
                    else:
                        print >>sys.stderr,"*** Ambiguious suffix type \"%s\"" % \
                            (ext)
                        print >>sys.stderr,"*** Please use the -t option to specify %s" % \
                            (" or ".join(["\"%s\"" % (t.NAME)
                                          for t in SUFFIX_MAP[ext]]))
                        sys.exit(1)
                else:
                    print >>sys.stderr,"*** Unsupported audio type \"%s\"" % \
                        (ext)
                    sys.exit(1)
            else:
                AudioType = audiotools.TYPE_MAP['wav']

    if (options.add_replay_gain is None):
        options.add_replay_gain = AudioType.lossless_replay_gain()

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            print >>sys.stderr,"*** Available compression types for %s:" % \
                  (AudioType.NAME)
            for mode in AudioType.COMPRESSION_MODES:
                print >>sys.stderr,mode
        else:
            print >>sys.stderr,"*** Audio type %s has no compression modes" % \
                  (AudioType.NAME)
        sys.exit(0)
    elif (options.quality == None):
        options.quality = AudioType.DEFAULT_COMPRESSION
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        print >>sys.stderr,"*** \"%s\" is not a supported compression " % \
              (options.quality) + "mode for type \"%s\"" % \
              (AudioType.NAME)
        sys.exit(1)

    #grab the list of AudioFile objects we are converting from
    audiofiles = audiotools.open_files(args)
    if (len(audiofiles) < 1):
        print >>sys.stderr,"*** You must specify at least 1 supported audio file"
        sys.exit(1)

    if (options.max_processes < 1):
        print >>sys.stderr,'*** You must run at least 1 process at a time'
        sys.exit(1)

    if ((options.output != None) and
        (len(audiofiles) != 1)):
        print >>sys.stderr,'*** You may specify only 1 input file for use with -o'
        sys.exit(1)


    #if we're using an XMCD file, use that file for MetaData
    if (options.xmcd != None):
        try:
            xmcd = audiotools.parse_xmcd_file(options.xmcd)
        except audiotools.XMCDException:
            print >>sys.stderr,"*** Invalid XMCD file"
            sys.exit(1)
    else: #if we're not using an XMCD file, use the AudioFile objects' data
        xmcd = None

    if (options.thumbnail):
        if (not audiotools.can_thumbnail()):
            print >>sys.stderr,"*** Unable to generate thumbnails"
            print >>sys.stderr,"Please install the Python Imaging Library"
            print >>sys.stderr,"available at http://www.pythonware.com/products/pil/"
            print >>sys.stderr,"to enable image resizing"
            sys.exit(1)

        if (audiotools.THUMBNAIL_FORMAT.upper() not in audiotools.thumbnail_formats()):
            print >>sys.stderr,"*** Unsupported thumbnail format \"%s\"" % \
                (audiotools.THUMBNAIL_FORMAT)
            print >>sys.stderr,"available formats are: %s" % \
                (", ".join(audiotools.thumbnail_formats()))
            sys.exit(1)

    quality = options.quality
    max_processes = options.max_processes


    if (options.output == None):
        #the default encoding method, without an output file

        base_directory = options.dir

        queue = audiotools.ExecQueue()
        encoded_filenames = []

        for audiofile in audiofiles:
            try:
                track_number = audiofile.track_number()
                if (options.album_number is None):
                    album_number = audiofile.album_number()
                else:
                    album_number = options.album_number

                if (xmcd is not None):
                    filename = os.path.join(
                                base_directory,
                                AudioType.track_name(track_number,
                                                     xmcd[track_number],
                                                     album_number=album_number,
                                                     format=options.format))

                    audiotools.make_dirs(filename)

                    metadata = xmcd[track_number]
                    metadata.album_number = album_number

                    queue.execute(convert_file,
                                  (AudioType,
                                   filename,
                                   audiofile,
                                   metadata,
                                   quality))
                    encoded_filenames.append(filename)
                else:
                    filename = os.path.join(
                                base_directory,
                                AudioType.track_name(track_number,
                                                     audiofile.get_metadata(),
                                                     album_number=album_number,
                                                     format=options.format))

                    audiotools.make_dirs(filename)

                    metadata = audiofile.get_metadata()

                    queue.execute(convert_file,
                                  (AudioType,
                                   filename,
                                   audiofile,
                                   metadata,
                                   quality,
                                   True,
                                   options.thumbnail))
                encoded_filenames.append(filename)
            except audiotools.UnsupportedTracknameField,msg:
                sys.stderr.write(unicode(msg).encode(audiotools.IO_ENCODING))
                sys.exit(1)
            except KeyError:
                continue

        queue.run(max_processes)

        if (options.add_replay_gain and AudioType.can_add_replay_gain()):
            if (AudioType.lossless_replay_gain()):
                print >>sys.stderr,"* Adding ReplayGain metadata.  This may take some time."
            else:
                print >>sys.stderr,"* Applying ReplayGain.  This may take some time."
            AudioType.add_replay_gain(encoded_filenames)
    else:
        #encoding only a single file
        audiofile = audiofiles[0]

        if (xmcd is not None):
            metadata = xmcd[audiofile.track_number()]
        else:
            metadata = audiofile.get_metadata()

        if ((metadata is not None) and (options.album_number is not None)):
            metadata.album_number = options.album_number

        convert_file(AudioType,
                     options.output,
                     audiofile,
                     metadata,
                     quality,
                     False,
                     options.thumbnail)


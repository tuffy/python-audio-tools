#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2012  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import os
import os.path
import select
import cPickle
import audiotools
from audiotools.text import (USAGE_TRACK2TRACK,
                             OPT_CAT_CONVERSION,
                             OPT_OUTPUT_TRACK2TRACK,
                             OPT_JOINT,
                             OPT_TYPE,
                             OPT_DIR,
                             OPT_QUALITY,
                             OPT_FORMAT,
                             OPT_VERBOSE,
                             OPT_CAT_METADATA,
                             OPT_THUMBNAIL,
                             OPT_REPLAY_GAIN,
                             OPT_NO_REPLAY_GAIN,
                             LAB_ENCODE,
                             LAB_AVAILABLE_COMPRESSION_TYPES,
                             ERR_NO_COMPRESSION_MODES,
                             ERR_UNSUPPORTED_COMPRESSION_MODE,
                             ERR_FILES_REQUIRED,
                             ERR_INVALID_JOINT,
                             ERR_DUPLICATE_FILE,
                             ERR_OUTPUT_IS_INPUT,
                             ERR_DUPLICATE_FILE,
                             ERR_ENCODING_ERROR,
                             ERR_TRACK2TRACK_O_AND_D,
                             ERR_TRACK2TRACK_O_AND_D_SUGGESTION,
                             ERR_TRACK2TRACK_O_AND_FORMAT,
                             ERR_TRACK2TRACK_O_AND_MULTIPLE,
                             ERR_NO_THUMBNAILS,
                             ERR_THUMBNAIL_SUGGESTION1,
                             ERR_THUMBNAIL_SUGGESTION2,
                             ERR_THUMBNAIL_SUGGESTION3,
                             ERR_INVALID_THUMBNAIL_FORMAT,
                             ERR_AVAILABLE_THUMBNAIL_FORMATS)


MAX_CPUS = audiotools.MAX_JOBS


def convert(progress, source_audiofile, destination_filename,
            destination_class, compression,
            metadata, thumbnail_images):
    destination_audiofile = source_audiofile.convert(
        destination_filename,
        destination_class,
        compression,
        progress)

    if (metadata is not None):
        if (thumbnail_images):
            for img in metadata.images():
                metadata.delete_image(img)
                metadata.add_image(img.thumbnail(
                        audiotools.THUMBNAIL_SIZE,
                        audiotools.THUMBNAIL_SIZE,
                        audiotools.THUMBNAIL_FORMAT))

        destination_audiofile.set_metadata(metadata)
    elif ((source_audiofile.track_number() != 0) or
          (source_audiofile.album_number() != 0)):
        destination_audiofile.set_metadata(audiotools.MetaData(
                track_number=source_audiofile.track_number(),
                album_number=source_audiofile.album_number()))
    else:
        #don't set any metadata
        pass

    existing_cuesheet = source_audiofile.get_cuesheet()
    if (existing_cuesheet is not None):
        destination_audiofile.set_cuesheet(existing_cuesheet)

    return destination_filename


if (__name__ == '__main__'):
    parser = audiotools.OptionParser(
        usage=USAGE_TRACK2TRACK,
        version="Python Audio Tools %s" % (audiotools.VERSION))

    conversion = audiotools.OptionGroup(parser, OPT_CAT_CONVERSION)

    conversion.add_option(
        '-t', '--type',
        action='store',
        dest='type',
        choices=audiotools.TYPE_MAP.keys(),
        help=OPT_TYPE)

    conversion.add_option(
        '-q', '--quality',
        action='store',
        type='string',
        dest='quality',
        help=OPT_QUALITY)

    conversion.add_option(
        '-d', '--dir',
        action='store',
        type='string',
        dest='dir',
        default='.',
        help=OPT_DIR)

    conversion.add_option(
        '--format',
        action='store',
        type='string',
        default=None,
        dest='format',
        help=OPT_FORMAT)

    conversion.add_option(
        '-o', '--output',
        action='store',
        dest='output',
        help=OPT_OUTPUT_TRACK2TRACK)

    conversion.add_option(
        '-j', '--joint',
        action='store',
        type='int',
        default=MAX_CPUS,
        dest='max_processes',
        help=OPT_JOINT)

    parser.add_option_group(conversion)

    metadata = audiotools.OptionGroup(parser, OPT_CAT_METADATA)

    metadata.add_option(
        '-T', '--thumbnail',
        action='store_true',
        default=False,
        dest='thumbnail',
        help=OPT_THUMBNAIL)

    #if adding ReplayGain is a lossless process
    #(i.e. added as tags rather than modifying track data)
    #add_replay_gain should default to True
    #if not, add_replay_gain should default to False
    #which is which depends on the track type
    metadata.add_option(
        '--replay-gain',
        action='store_true',
        dest='add_replay_gain',
        help=OPT_REPLAY_GAIN)

    metadata.add_option(
        '--no-replay-gain',
        action='store_false',
        dest='add_replay_gain',
        help=OPT_NO_REPLAY_GAIN)

    parser.add_option_group(metadata)

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=OPT_VERBOSE)

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("track2track", options)

    #if one specifies incompatible output options,
    #complain about it right away
    if (options.output is not None):
        if (options.dir != "."):
            msg.error(ERR_TRACK2TRACK_O_AND_D)
            msg.info(ERR_TRACK2TRACK_O_AND_D_SUGGESTION)
            sys.exit(1)

        if (options.format is not None):
            msg.warning(ERR_TRACK2TRACK_O_AND_FORMAT)

    #get the AudioFile class we are converted to
    if (options.output is None):
        if (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]
        else:
            AudioType = audiotools.TYPE_MAP[audiotools.DEFAULT_TYPE]
    else:
        if (options.type is not None):
            AudioType = audiotools.TYPE_MAP[options.type]
        else:
            try:
                AudioType = audiotools.filename_to_type(options.output)
            except audiotools.UnknownAudioType, exp:
                exp.error_msg(msg)
                sys.exit(1)

    #ensure the selected compression is compatible with that class
    if (options.quality == 'help'):
        if (len(AudioType.COMPRESSION_MODES) > 1):
            msg.info(LAB_AVAILABLE_COMPRESSION_TYPES %
                     (AudioType.NAME))
            for mode in AudioType.COMPRESSION_MODES:
                msg.new_row()
                if (mode == audiotools.__default_quality__(AudioType.NAME)):
                    msg.output_column(msg.ansi(mode.decode('ascii'),
                                               [msg.BOLD,
                                                msg.UNDERLINE]), True)
                else:
                    msg.output_column(mode.decode('ascii'), True)
                if (mode in AudioType.COMPRESSION_DESCRIPTIONS):
                    msg.output_column(u" : ")
                else:
                    msg.output_column(u"   ")
                msg.output_column(
                    AudioType.COMPRESSION_DESCRIPTIONS.get(mode, u""))
            msg.info_rows()
        else:
            msg.error(ERR_NO_COMPRESSION_MODES % (AudioType.NAME))
        sys.exit(0)
    elif (options.quality is None):
        options.quality = audiotools.__default_quality__(AudioType.NAME)
    elif (options.quality not in AudioType.COMPRESSION_MODES):
        msg.error(ERR_UNSUPPORTED_COMPRESSION_MODE %
                  {"quality": options.quality,
                   "type": AudioType.NAME})
        sys.exit(1)

    #grab the list of AudioFile objects we are converting from
    input_filenames = set([])
    try:
        audiofiles = audiotools.open_files(args,
                                           messenger=msg,
                                           no_duplicates=True,
                                           opened_files=input_filenames)
    except audiotools.DuplicateFile, err:
        msg.error(ERR_DUPLICATE_FILE % (err.filename,))
        sys.exit(1)

    if (len(audiofiles) < 1):
        msg.error(ERR_FILES_REQUIRED)
        sys.exit(1)

    if (options.max_processes < 1):
        msg.error(ERR_INVALID_JOINT)
        sys.exit(1)

    if ((options.output is not None) and
        (len(audiofiles) != 1)):
        msg.error(ERR_TRACK2TRACK_O_AND_MULTIPLE)
        sys.exit(1)

    #determine whether to add ReplayGain by default
    if (options.add_replay_gain is None):
        options.add_replay_gain = (
            audiotools.ADD_REPLAYGAIN and
            AudioType.lossless_replay_gain())

    if (options.thumbnail):
        if (not audiotools.can_thumbnail()):
            msg.error(ERR_NO_THUMBNAILS)
            msg.info(ERR_THUMBNAIL_SUGGESTION1)
            msg.info(ERR_THUMBNAIL_SUGGESTION2)
            msg.info(ERR_THUMBNAIL_SUGGESTION3)
            sys.exit(1)

        if (audiotools.THUMBNAIL_FORMAT.upper() not in
            audiotools.thumbnail_formats()):
            msg.error(ERR_INVALID_THUMBNAIL_FORMAT %
                      (audiotools.THUMBNAIL_FORMAT))
            msg.info(ERR_AVAILABLE_THUMBNAIL_FORMATS %
                     (", ".join(audiotools.thumbnail_formats())))
            sys.exit(1)

    quality = options.quality
    max_processes = options.max_processes

    if (options.output is None):
        #the default encoding method, without an output file

        base_directory = options.dir
        output_filenames = set([])
        queue = audiotools.ExecProgressQueue(audiotools.ProgressDisplay(msg))

        for audiofile in audiofiles:
            track_metadata = audiofile.get_metadata()

            #use old track's metadata for new track, if any
            track_metadata = audiofile.get_metadata()

            try:
                output_filename = audiotools.Filename(os.path.join(
                        base_directory,
                        AudioType.track_name(file_path=audiofile.filename,
                                             track_metadata=track_metadata,
                                             format=options.format)))

                if (output_filename in input_filenames):
                    msg.error(ERR_OUTPUT_IS_INPUT %
                              (output_filename,))
                    sys.exit(1)
                if (output_filename in output_filenames):
                    msg.error(ERR_DUPLICATE_FILE %
                              (output_filename,))
                    sys.exit(1)
                else:
                    output_filenames.add(output_filename)
            except audiotools.UnsupportedTracknameField, err:
                err.error_msg(msg)
                sys.exit(1)

            #queue up conversion job
            queue.execute(function=convert,
                          progress_text=unicode(output_filename),
                          completion_output=LAB_ENCODE % \
                              {"source":audiotools.Filename(audiofile.filename),
                               "destination":output_filename},
                          source_audiofile=audiofile,
                          destination_filename=str(output_filename),
                          destination_class=AudioType,
                          compression=quality,
                          metadata=track_metadata,
                          thumbnail_images=options.thumbnail)

        #try to create subdirectories in advance
        #so as to bail out as early as possible
        for filename in output_filenames:
            try:
                audiotools.make_dirs(str(filename))
            except OSError:
                msg.error(ERR_ENCODING_ERROR % (filename,))
                sys.exit(1)

        #perform all queued conversion jobs
        try:
            queue.run(max_processes)
        except audiotools.EncodingError, err:
            msg.error(unicode(err))
            sys.exit(1)

        output_files = audiotools.open_files(queue.results.values())

        #add ReplayGain to converted files, if necessary
        if (options.add_replay_gain and
            AudioType.can_add_replay_gain(output_files)):
            #separate encoded files by album_name and album_number
            for album in audiotools.group_tracks(output_files):
                #add ReplayGain to groups of files
                #belonging to the same album

                album_number = set([a.album_number() for a in album]).pop()

                #FIXME - should pull ReplayGain text
                #from elsewhere
                queue.execute(
                    AudioType.add_replay_gain,
                    (u"%s ReplayGain%s" %
                     ((u"Adding" if AudioType.lossless_replay_gain() else
                       u"Applying"),
                      (u"" if album_number is None else
                       (u" to album %d" % (album_number))))),
                    (u"ReplayGain %s%s" %
                     ((u"added" if AudioType.lossless_replay_gain() else
                       u"applied"),
                      (u"" if album_number is None else
                       (u" to album %d" % (album_number))))),
                    [a.filename for a in album])

            try:
                queue.run(max_processes)
            except ValueError, err:
                msg.error(unicode(err))
                sys.exit(1)
    else:
        #encoding only a single file
        audiofile = audiofiles[0]
        input_filename = audiotools.Filename(audiofile.filename)
        output_filename = audiotools.Filename(options.output)
        track_metadata = audiofile.get_metadata()

        if (input_filename == output_filename):
            msg.error(ERR_OUTPUT_IS_INPUT %
                      (output_filename,))
            sys.exit(1)

        queue = audiotools.ExecProgressQueue(
            audiotools.ProgressDisplay(
                audiotools.SilentMessenger("track2track")))

        queue.execute(function=convert,
                      source_audiofile=audiofile,
                      destination_filename=options.output,
                      destination_class=AudioType,
                      compression=quality,
                      metadata=track_metadata,
                      thumbnail_images=options.thumbnail)

        try:
            queue.run(1)
        except audiotools.EncodingError, err:
            msg.error(unicode(err))
            sys.exit(1)
